---
title: Cotas
---
import ReadingTime from '@site/src/components/ReadingTime'
import { ProCons, Pros, Cons } from '@site/src/components/cajitas/ProCons'
import References from '@site/src/components/ReferencesComponent'
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'
import Exercise from '@site/src/components/exercise/Exercise'
import Solution from '@site/src/components/exercise/Solution'
import Hint from '@site/src/components/exercise/Hint'
import Definition from '@site/src/components/Definition'
import Corollary from '@site/src/components/Corollary'
import GithubRepoLink from '@site/src/components/GithubRepoLink'
import { LanguageCard, JavaCard, SwiftCard } from '@site/src/components/cards/LanguageCard'
import Explanation from '@site/src/components/admonitions/Explanation'
import RepoClone from '@site/src/components/admonitions/RepoClone'
import ModuleSetup from '@site/src/components/cajitas/ModuleSetup'
import BoxedTabs from '@site/src/components/cajitas/BoxedTabs'

<ReadingTime />
<GithubRepoLink user="r8vnhill" repo="generic-programming-kt" />
<ModuleSetup module='bounds' task='setupBoundsModule'>
```kotlin showLineNumbers title="convention-plugins/src/main/kotlin/bounds.gradle.kts"
import tasks.ModuleSetupTask

tasks.register<ModuleSetupTask>("setupBoundsModule") {
    description = "Creates the base module and files for the bounds lesson"
    module.set("bounds")

    doLast {
        createFiles(
            "repo",
            main to "Repository.kt",
            main to "Entity.kt",
            main to "Serializable.kt",
            test to "RepositoryTest.kt"
        )
        createFiles(
            "notifications",
            main to "EmailNotificationSystem.kt",
            main to "NotificationHandler.kt",
            main to "Notification.kt",
            test to "NotificationSystemTest.kt"
        )
    }
}
```
</ModuleSetup>

La **programaci√≥n gen√©rica** en Kotlin nos permite crear clases y funciones que pueden trabajar con cualquier tipo, proporcionando una gran flexibilidad y reutilizaci√≥n de c√≥digo. Sin embargo, a veces necesitamos restringir los tipos que pueden ser utilizados con un gen√©rico. Aqu√≠ es donde entran las **cotas superiores** y **cotas inferiores**.

En esta lecci√≥n, exploraremos:

- C√≥mo declarar **cotas superiores** en gen√©ricos de Kotlin.
- Las dos formas de declarar cotas superiores y c√≥mo utilizar `where` para m√∫ltiples cotas.
- Notas sobre **cotas inferiores**, c√≥mo Kotlin no las soporta nativamente, pero c√≥mo podemos emularlas hasta cierto punto usando **varianza en sitio de uso**.
- Ejemplos contextualizados en el desarrollo de **bibliotecas de software**.

## üìå Cotas superiores en gen√©ricos

Una **cota superior** restringe el tipo gen√©rico a un subtipo espec√≠fico. Esto significa que el tipo gen√©rico debe ser la cota superior o un subtipo de ella.

Imaginemos que estamos desarrollando una biblioteca de persistencia y queremos crear una clase gen√©rica `Repository` que solo acepte tipos que implementen la interfaz `Entity`. Esto garantiza que todas las entidades manejadas por la biblioteca sigan un contrato com√∫n, facilitando la manipulaci√≥n y persistencia de datos.

Queremos que el comportamiento de nuestra clase `Repository` sea el siguiente:

<BoxedTabs>
    <TabItem label="C√≥digo esencial" value="C√≥digo esencial">
        ```kotlin showLineNumbers
        with(repository) {
            entities.shouldBeEmpty()
            save(entity)
            entities shouldHaveSize 1
            entities.last() shouldBe entity
            serializeAll() shouldBe "[MockEntity(id=1)]"
        }
        ```
    </TabItem>
    <TabItem label="C√≥digo completo" value="C√≥digo completo">
        ```kotlin showLineNumbers title="bounds/src/test/kotlin/com/github/username/repo/RepositoryTest.kt"
        package com.github.username.repo
        
        import io.kotest.core.spec.style.FreeSpec
        import io.kotest.matchers.collections.shouldBeEmpty
        import io.kotest.matchers.collections.shouldHaveSize
        import io.kotest.matchers.shouldBe

        private class MockEntity(override val id: Int) : Entity, Serializable {

            override fun serialize() = "MockEntity(id=$id)"

            override fun deserialize(serialized: String) = serialized
                .substringAfter("id=").toInt()
                .let(::MockEntity)
        }

        class RepositoryTest : FreeSpec({
            "A repository" - {
                "when saving an entity" - {
                    "should contain the entity" {
                        val repository = Repository<MockEntity>()
                        val entity = MockEntity(1)
                        with(repository) {
                            entities.shouldBeEmpty()
                            save(entity)
                            entities shouldHaveSize 1
                            entities.last() shouldBe entity
                            serializeAll() shouldBe "[MockEntity(id=1)]"
                        }
                    }
                }
            }
        })
        ```
    </TabItem>
</BoxedTabs>

<Explanation>
    En este test, estamos verificando que el repositorio pueda almacenar una entidad correctamente. Despu√©s de guardar la entidad, comprobamos que la lista de entidades tenga un tama√±o de `1` y que la √∫ltima entidad en la lista sea la misma que hemos guardado. Este comportamiento es esencial para asegurar que la biblioteca de persistencia maneja las entidades de manera consistente y segura.
</Explanation>

### Primera forma: declaraci√≥n directa en el par√°metro gen√©rico

La forma m√°s com√∫n de declarar una cota superior es directamente en la declaraci√≥n del par√°metro gen√©rico usando `T : UpperBound`.

<BoxedTabs>
    <TabItem label={"C√≥digo esencial"} value={"C√≥digo esencial"}>
        ```kotlin showLineNumbers
        class Repository<T : Entity>
        ```
    </TabItem>
    <TabItem label={"C√≥digo completo"} value={"C√≥digo completo"}>
        ```kotlin showLineNumbers title="src/main/kotlin/com/github/username/repo/Entity.kt"
        package com.github.username.repo

        interface Entity {
            val id: Int
        }
        ```

        ```kotlin showLineNumbers title="src/main/kotlin/com/github/username/repo/Repository.kt"
        package com.github.username.repo

        class Repository<T : Entity> {
            private val _entities: MutableList<T> = mutableListOf()
            val entities: List<T> = _entities

            fun save(entity: T) {
                _entities += entity
            }
        }
        ```
    </TabItem>
</BoxedTabs>

<Explanation>
    - **`Entity`** es la cota superior.
    - **`T : Entity`** significa que `T` debe ser `Entity` o una clase que herede de `Entity`.
</Explanation>

### Segunda forma: Usar la cl√°usula `where` para m√∫ltiples cotas

Cuando es necesario aplicar **m√∫ltiples restricciones** a un tipo gen√©rico en Kotlin, la cl√°usula `where` proporciona una forma clara y organizada de hacerlo. Esta t√©cnica es √∫til cuando un tipo debe cumplir con m√°s de una condici√≥n, garantizando que todas las restricciones se definan de manera expl√≠cita y comprensible.

<BoxedTabs>
    <TabItem label={"C√≥digo esencial"} value={"C√≥digo esencial"}>
        ```kotlin showLineNumbers
        class Repository<T> where T : Entity,
                                  T : Serializable
        ```
    </TabItem>
    <TabItem label={"C√≥digo completo"} value={"C√≥digo completo"}>
        ```kotlin showLineNumbers title="src/main/kotlin/com/github/username/repo/Repository.kt"
        package com.github.username.repo

        class Repository<T> where T : Entity,
                                  T : Serializable {
            private val _entities: MutableList<T> = mutableListOf()
            val entities: List<T> = _entities

            fun save(entity: T) {
                _entities += entity
            }

            fun serializeAll() = entities
                .joinToString(prefix = "[", postfix = "]") {
                    it.serialize()
                }
        }
        ```
    </TabItem>
</BoxedTabs>

<Explanation>
   - En este caso, `T` debe ser un subtipo de `Entity` **y** tambi√©n implementar la interfaz `Serializable`. De esta manera, cualquier tipo que se utilice con esta clase cumplir√° ambas restricciones.
   - La cl√°usula `where` se coloca despu√©s de la lista de par√°metros gen√©ricos y antes del cuerpo de la funci√≥n o clase, proporcionando una estructura clara que facilita la lectura y comprensi√≥n de las restricciones aplicadas.
</Explanation>

:::tip ¬øCu√°l elegir?

La elecci√≥n entre usar la **declaraci√≥n directa** y la **cl√°usula `where`** depende de la complejidad de las restricciones y de la claridad del c√≥digo. Para restricciones simples, la **declaraci√≥n directa** es m√°s concisa y f√°cil de entender. En cambio, cuando hay m√∫ltiples restricciones o condiciones m√°s complejas, la **cl√°usula `where`** mejora la legibilidad y organiza mejor las relaciones entre tipos.

Por ejemplo, el siguiente c√≥digo que utiliza la **declaraci√≥n directa** para establecer cotas superiores puede resultar menos legible:

```kotlin showLineNumbers
interface Evolver<T, F : Feature<T, F>, R : Representation<T, F>, S : EvolutionState<T, F, R, S>>
```

En comparaci√≥n con el uso de la **cl√°usula `where`**, que distribuye las restricciones de forma m√°s clara:

```kotlin showLineNumbers
interface Evolver<T, F, R, S> 
    where F : Feature<T, F>, 
          R : Representation<T, F>,
          S : EvolutionState<T, F, R, S>
```

En √∫ltima instancia, la elecci√≥n se basa en las preferencias de lx desarrolladorx y en el enfoque que maximice la claridad y mantenibilidad del c√≥digo.

| **M√©todo** | **Ventajas** | **Cu√°ndo Usarlo** |
|------------|-------------|-------------------|
| **Declaraci√≥n directa** (`T : UpperBound`) | Simple y f√°cil de entender | Cuando solo hay una cota superior |
| **Cl√°usula `where`** | M√°s legible cuando hay m√∫ltiples restricciones | Cuando se requieren varias cotas superiores |

:::
 
### ‚öñÔ∏è Beneficios y limitaciones de las cotas superiores

<ProCons>
   <Pros>
      - **Seguridad de tipos en tiempo de compilaci√≥n**: Las cotas superiores aseguran que solo se acepten tipos que cumplan con ciertas restricciones, lo que permite detectar errores en tiempo de compilaci√≥n y garantiza que las operaciones solo se realicen sobre tipos compatibles.
      - **Flexibilidad y reutilizaci√≥n**: Al definir cotas superiores, se puede crear c√≥digo gen√©rico flexible que funcione con cualquier subtipo que cumpla las restricciones, permitiendo reutilizar clases y funciones sin necesidad de reescribirlas para cada caso espec√≠fico.
      - **Clara intenci√≥n de uso**: Especificar cotas superiores hace expl√≠citas las expectativas y restricciones de una clase o funci√≥n, lo que mejora la legibilidad y el mantenimiento del c√≥digo, ya que otrxs desarrolladorxs pueden entender r√°pidamente qu√© tipos se esperan.
      - **Integridad de la API**: En el contexto de bibliotecas de software, las cotas superiores ayudan a asegurar que solo los tipos adecuados interact√∫en con la API, previniendo usos incorrectos que podr√≠an llevar a errores en tiempo de ejecuci√≥n.
   </Pros>
   <Cons>
      - **Complejidad adicional**: Usar cotas superiores y m√∫ltiples restricciones puede hacer que las definiciones de funciones y clases gen√©ricas sean m√°s complicadas, lo que puede ser intimidante para desarrolladorxs menos experimentados.
      - **Rigidez**: Aunque las cotas superiores proporcionan flexibilidad dentro de ciertos l√≠mites, tambi√©n imponen restricciones que podr√≠an no ser necesarias en todos los contextos. Esto puede hacer que el c√≥digo sea menos adaptable en casos que no cumplan exactamente con las restricciones impuestas.
      - **Mensajes de error dif√≠ciles de interpretar**: Los errores relacionados con restricciones gen√©ricas y cotas superiores pueden ser complicados de diagnosticar y entender, lo que puede ralentizar el proceso de depuraci√≥n y desarrollo.
   </Cons>
</ProCons>

## üìâ Cotas inferiores

En Kotlin, las **cotas inferiores** no son compatibles de forma nativa, lo que significa que no se pueden declarar directamente en la definici√≥n de un gen√©rico. Sin embargo, es posible **emular** las cotas inferiores utilizando **varianza en sitio de uso**.

### üîÑ Emulando cotas inferiores con varianza en sitio de uso

La varianza en Kotlin permite especificar c√≥mo los subtipos y supertipos se relacionan entre s√≠ en el contexto de una clase gen√©rica. Al utilizar la varianza de manera estrat√©gica, podemos **emular** el comportamiento de las cotas inferiores.

Por ejemplo, supongamos que estamos desarrollando una biblioteca de notificaciones y queremos crear un sistema que pueda manejar diferentes tipos de notificaciones.

Imaginemos que tenemos una clase `NotificationHandler` que puede manejar notificaciones de diferentes tipos. Para poder reusar un mismo handler para m√∫ltiples notificaciones, definimos un campo mutable `notification` que puede ser de cualquier tipo de notificaci√≥n, o nulo.

```kotlin showLineNumbers
package com.github.username.notifications

class NotificationHandler<N: Notification> {
    var notification: N? = null
}
```

Supongamos que queremos crear un sistema que maneje exclusivamente notificaciones de correos electr√≥nicos. Para ello, definiremos una clase `EmailNotificationSystem` que registre un `NotificationHandler` dise√±ado espec√≠ficamente para notificaciones de correos electr√≥nicos. Dado que un correo electr√≥nico es un subtipo de notificaci√≥n, esperar√≠amos poder utilizar un `NotificationHandler<Notification>` (que maneja cualquier tipo de notificaci√≥n) para procesar notificaciones de correo electr√≥nico sin problemas.

Esto quiere decir que necesitamos un m√©todo `registerHandler` en `EmailNotificationSystem` que acepte un `NotificationHandler<T>` donde `T` es un supertipo de `EmailNotification`. Es decir, necesitamos una **cota inferior** en el par√°metro gen√©rico de `registerHandler`.

<BoxedTabs>
    <TabItem label={"C√≥digo esencial"} value={"C√≥digo esencial"}>
        ```kotlin showLineNumbers
        val system = EmailNotificationSystem()
        val generalHandler = NotificationHandler<Notification>()
        with(system) {
            handlers.shouldBeEmpty()
            registerHandler(generalHandler)
            handlers shouldHaveSize 1
            handlers.last() shouldBe generalHandler
        }
        ```
    </TabItem>
    <TabItem label={"C√≥digo completo"} value={"C√≥digo completo"}>
        ```kotlin showLineNumbers title="bounds/src/test/kotlin/com/github/username/notifications/EmailNotificationSystemTest.kt"
        package cl.ravenhill.notifications

        import io.kotest.core.spec.style.FreeSpec
        import io.kotest.matchers.collections.shouldBeEmpty
        import io.kotest.matchers.collections.shouldHaveSize
        import io.kotest.matchers.shouldBe

        class NotificationSystemTest : FreeSpec({
            "A notification system" - {
                "when registering a handler" - {
                    "should contain the handler" {
                        val system = EmailNotificationSystem()
                        val generalHandler = NotificationHandler<Notification>()
                        with(system) {
                            handlers.shouldBeEmpty()
                            registerHandler(generalHandler)
                            handlers shouldHaveSize 1
                            handlers.last() shouldBe generalHandler
                        }
                    }
                }
            }
        })
        ```
    </TabItem>
</BoxedTabs>

Del concepto de **contravarianza**, sabemos que si `A` es un subtipo de `B`, entonces `Consumer<B>` es un subtipo de `Consumer<A>`. Aplicando esto, si `EmailNotification` es un subtipo de `Notification`, entonces un `NotificationHandler<Notification>` puede ser utilizado en cualquier lugar donde se espere un `NotificationHandler<EmailNotification>`. Esto nos permite aceptar un `NotificationHandler<Notification>` en contextos que requieren un `NotificationHandler<EmailNotification>`, emulando efectivamente una **cota inferior** en Kotlin.

```kotlin showLineNumbers title="bounds/src/main/kotlin/com/github/username/notifications/EmailNotificationSystem.kt"
package com.github.username.notifications

typealias EmailNotificationHandler = 
        NotificationHandler<in EmailNotification>

class EmailNotificationSystem {
    private val _handlers = mutableListOf<EmailNotificationHandler>()
    val handlers: List<EmailNotificationHandler> = _handlers

    fun registerHandler(handler: EmailNotificationHandler) {
        _handlers += handler
    }
}
```

<Explanation>
    - **`EmailNotificationHandler`** es un alias para `NotificationHandler<in EmailNotification>`, que representa un handler que acepta notificaciones de correo electr√≥nico o cualquier supertipo de `EmailNotification`.
    - **`registerHandler`** acepta un `EmailNotificationHandler`, que puede ser un `NotificationHandler<EmailNotification>` o un supertipo de `EmailNotification`.
</Explanation>

### üí° Beneficios y limitaciones de emular cotas inferiores

<ProCons>
   <Pros>
      - **Flexibilidad y reutilizaci√≥n de c√≥digo**: Emular cotas inferiores mediante la contravarianza permite que los mismos handlers gen√©ricos puedan ser reutilizados en m√∫ltiples contextos, ampliando la flexibilidad de la biblioteca y evitando la duplicaci√≥n de c√≥digo.
      - **Compatibilidad con jerarqu√≠as de tipos**: Esta t√©cnica permite que sistemas o clases que trabajan con jerarqu√≠as de tipos puedan aceptar handlers que funcionen con tipos m√°s generales. Esto es especialmente √∫til cuando se manejan entidades o eventos que tienen m√∫ltiples subtipos.
      - **Seguridad de tipos en tiempo de compilaci√≥n**: A pesar de no soportar cotas inferiores nativamente, el uso de contravarianza sigue siendo seguro en tiempo de compilaci√≥n, garantizando que solo se acepten tipos v√°lidos seg√∫n las restricciones establecidas.
   </Pros>
   <Cons>
      - **Complejidad conceptual**: La emulaci√≥n de cotas inferiores usando varianza en sitio de uso puede ser dif√≠cil de entender para desarrolladorxs que no est√°n familiarizadxs con la contravarianza y sus implicaciones, lo que puede llevar a errores o malentendidos en el dise√±o de la API.
      - **Limitaciones en la flexibilidad**: A diferencia de las cotas inferiores nativas, esta t√©cnica tiene limitaciones, ya que solo se aplica en situaciones espec√≠ficas donde es posible usar contravarianza. En casos m√°s complejos, puede que no sea suficiente o se requiera un enfoque alternativo.
      - **Mensajes de error dif√≠ciles de diagnosticar**: Los mensajes de error del compilador relacionados con la contravarianza y las restricciones de tipos pueden ser dif√≠ciles de interpretar, lo que puede hacer que la depuraci√≥n y el desarrollo sean m√°s complicados y menos intuitivos.
   </Cons>
</ProCons>

## üéØ Conclusiones

A lo largo de esta lecci√≥n, hemos explorado el uso de **cotas superiores** y la emulaci√≥n de **cotas inferiores** en **Kotlin**, entendiendo c√≥mo estas t√©cnicas afectan la seguridad y flexibilidad de los tipos en **programaci√≥n gen√©rica**. En el contexto del desarrollo de **bibliotecas de software**, estas herramientas permiten definir APIs m√°s expresivas y seguras, restringiendo los tipos aceptados sin comprometer la reutilizaci√≥n del c√≥digo.

### üîë **Puntos clave**

1. **Cotas superiores**  
   - Permiten restringir el tipo gen√©rico a un subtipo espec√≠fico.  
   - Se pueden declarar directamente (`T : UpperBound`) o mediante `where` cuando hay m√∫ltiples restricciones.  
   - Aseguran que las operaciones se realicen sobre tipos compatibles, evitando errores en tiempo de ejecuci√≥n.  
2. **Cotas inferiores (emulaci√≥n en Kotlin)**  
   - Kotlin **no soporta** cotas inferiores de manera nativa.  
   - Se pueden emular mediante **contravarianza (`in`)**, permitiendo aceptar supertipos en contextos espec√≠ficos.  
   - Son √∫tiles para dise√±ar APIs que trabajen con jerarqu√≠as de tipos, pero tienen **limitaciones** y pueden ser **m√°s dif√≠ciles de entender**.
3. **Casos de uso en bibliotecas de software**  
   - En bibliotecas de **persistencia**, las cotas superiores permiten definir repositorios gen√©ricos que solo acepten tipos compatibles con la persistencia de datos.  
   - En **sistemas de eventos y notificaciones**, la emulaci√≥n de cotas inferiores facilita la reutilizaci√≥n de handlers sin romper la seguridad de tipos.  
4. **Beneficios y limitaciones**  
   - **Las cotas superiores** mejoran la **seguridad de tipos y reutilizaci√≥n**, pero pueden hacer que la API sea m√°s r√≠gida.  
   - **La emulaci√≥n de cotas inferiores** permite m√°s flexibilidad, pero tiene **restricciones y mensajes de error dif√≠ciles de interpretar**.  

### ‚öñÔ∏è **¬øC√≥mo elegir la mejor opci√≥n?**

| **Caso** | **Recomendaci√≥n** |
|----------|------------------|
| Necesitas restringir un tipo gen√©rico a una clase base o interfaz espec√≠fica | Usa **cotas superiores** (`T : BaseType`) |
| Un tipo debe cumplir con m√∫ltiples restricciones | Usa **la cl√°usula `where`** |
| Necesitas aceptar supertipos en una API gen√©rica | Usa **contravarianza (`in`)** para emular cotas inferiores |
| Quieres dise√±ar una API flexible sin perder seguridad de tipos | Eval√∫a si la restricci√≥n aporta m√°s claridad o si genera m√°s complejidad |

### üöÄ Reflexi√≥n final

El uso de cotas en Kotlin es fundamental para dise√±ar **APIs s√≥lidas y mantenibles** en bibliotecas de software. Las **cotas superiores** proporcionan una manera clara de definir restricciones, asegurando que el c√≥digo se mantenga seguro y reutilizable. Mientras que las **cotas inferiores no son nativas en Kotlin**, la contravarianza permite lograr efectos similares en ciertos casos. Sin embargo, su uso debe evaluarse cuidadosamente, ya que puede **introducir complejidad innecesaria**.

Al dise√±ar una API, **la clave est√° en encontrar un balance** entre **restricciones claras y flexibilidad**, asegurando que la biblioteca sea **f√°cil de usar** sin comprometer la **seguridad de tipos**. üöÄ

<div className="language-card-container">
    <JavaCard link="/docs/generics/bounds/java" />
    <SwiftCard link="/docs/generics/bounds/swift" />
</div>

<References references={[
    {
        title: "Generics",
        bookTitle: "Kotlin in action",
        publisher: "Manning Publications Co.",
        pages: "223‚Äì253",
        year: "2017",
        author: "Dmitry Jemerov & Svetlana Isakova",
        type: "book",
    },
]} additionalReferences={[
    {
        title: "Generics",
        bookTitle: "Effective Java",
        publisher: "Addison-Wesley",
        pages: "117‚Äì155",
        year: "2018",
        author: "Joshua Bloch",
        type: "book",
    },
]}/>
