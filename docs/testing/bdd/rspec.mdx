---
title: BDD con RSpec
---
import ReadingTime from '@site/src/components/ReadingTime'
import { ProCons, Pros, Cons } from '@site/src/components/cajitas/ProCons'
import References from '@site/src/components/ReferencesComponent'
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'
import Exercise from '@site/src/components/exercise/Exercise'
import Solution from '@site/src/components/exercise/Solution'
import Hint from '@site/src/components/exercise/Hint'
import Definition from '@site/src/components/Definition'
import Corollary from '@site/src/components/Corollary'
import GithubRepoLink from '@site/src/components/GithubRepoLink'
import Explanation from '@site/src/components/admonitions/Explanation'
import RepoClone from '@site/src/components/admonitions/RepoClone'
import ModuleSetup from '@site/src/components/cajitas/ModuleSetup'
import BoxedTabs from '@site/src/components/cajitas/BoxedTabs'

<ReadingTime />
<GithubRepoLink user="r8vnhill" repo="" />

Ya exploramos c√≥mo escribir especificaciones BDD en Kotlin usando Kotest. Ahora veremos c√≥mo se implementa un enfoque similar usando [RSpec](https://rspec.info/), el framework de pruebas m√°s utilizado en Ruby, especialmente en el desarrollo de bibliotecas y aplicaciones web con Ruby on Rails.

A lo largo de la comparaci√≥n, veremos similitudes en estilo y estructura, pero tambi√©n se√±alaremos diferencias clave que pueden influir al elegir herramientas seg√∫n el lenguaje y el dominio del proyecto.

## üß™ Registro de usuarixs: estructura b√°sica

Tanto Kotest como RSpec permiten una sintaxis descriptiva. En RSpec, las pruebas tambi√©n se estructuran con `describe`, `context` y `it`, que corresponden conceptualmente a `given`, `when` y `then`.

```ruby showLineNumbers
require 'user_service'

RSpec.describe UserService do
  context "when registering a new user" do
    it "adds the user to the database" do
      service = UserService.new
      service.register("saiki.kusuo", "pkpsychic1000")
      expect(service.users).to include("saiki.kusuo")
    end
  end
end
```

<Explanation>
    - **Estructura Given/When/Then**: En RSpec, la combinaci√≥n de `describe`, `context` e `it` permite modelar pruebas siguiendo una estructura similar a `given`, `when`, `then`. En este ejemplo:
        - `describe` define el sujeto bajo prueba (`UserService`).
        - `context` representa la condici√≥n inicial (cuando se registra un nuevo usuarix).
        - `it` describe el comportamiento esperado (debe a√±adirse a la base de datos).
    - **Legibilidad natural**: La sintaxis de RSpec favorece la lectura fluida y la escritura expresiva, permitiendo que las pruebas se entiendan f√°cilmente como especificaciones del comportamiento del sistema.
    - **Estado aislado**: Al crear una nueva instancia de `UserService` dentro del test, se garantiza un entorno limpio para cada prueba, algo equivalente al uso de `beforeEach` en Kotest.
</Explanation>

## ‚ö†Ô∏è Manejo de duplicados

```ruby showLineNumbers
RSpec.describe UserService do
  context "when registering an existing user" do
    it "raises an exception" do
      service = UserService.new
      service.register("spawn", "hellpowers")
      expect {
        service.register("spawn", "hellpowers")
      }.to raise_error(ArgumentError, "User already exists")
    end
  end
end
```

<Explanation>

Este test verifica que el servicio no permita registrar un usuario que ya existe. Primero se registra el usuario con un nombre y contrase√±a. Luego, se intenta registrarlo nuevamente, y se espera que eso genere una excepci√≥n.

La l√≠nea `expect { ... }.to raise_error(...)` le indica a RSpec que el bloque de c√≥digo dentro de las llaves debe lanzar una excepci√≥n. En este caso, se espera que sea una excepci√≥n de tipo `ArgumentError`, y que el mensaje de error sea `"User already exists"`. Esto permite verificar no solo que se lanz√≥ una excepci√≥n, sino tambi√©n que fue la correcta y con el mensaje esperado.

</Explanation>

Por supuesto. Aqu√≠ tienes la secci√≥n actualizada, contextualizada en el desarrollo de bibliotecas de software:

## ‚ôªÔ∏è Reutilizaci√≥n con `shared_examples` y `shared_context`

Al desarrollar bibliotecas de software, es com√∫n que distintas implementaciones deban cumplir con un contrato o comportamiento com√∫n. RSpec permite reutilizar fragmentos de pruebas mediante `shared_examples` y `shared_context`, lo que facilita validar que distintas clases de la biblioteca respeten los mismos requisitos.

### `shared_examples`

`shared_examples` permite definir ejemplos reutilizables para comprobar que varias clases cumplen con el mismo comportamiento. Esto es especialmente √∫til cuando tu biblioteca define una interfaz (o protocolo informal) que varias implementaciones deben respetar.

```ruby
# En una biblioteca de validaci√≥n de datos:
RSpec.shared_examples "a constraint" do
  it "returns a valid result for valid input" do
    expect(subject.validate("valid input")).to be_success
  end

  it "returns an error for invalid input" do
    expect(subject.validate(nil)).to be_failure
  end
end

# Uso con una implementaci√≥n concreta
RSpec.describe PresenceConstraint do
  subject { described_class.new }
  it_behaves_like "a constraint"
end
```

<Explanation>
    En este ejemplo, una biblioteca de validaci√≥n define una serie de pruebas compartidas bajo el nombre `"a constraint"`. Cualquier clase que implemente el contrato de `Constraint` puede incluir estos ejemplos con `it_behaves_like`.

    Esto asegura que todas las implementaciones respondan correctamente a los mismos casos de uso, sin tener que duplicar las pruebas. Esta t√©cnica permite escalar la cobertura de la biblioteca de forma consistente y facilita agregar nuevas implementaciones que respeten el comportamiento esperado.
</Explanation>

### `shared_context`

`shared_context` es √∫til para compartir configuraci√≥n com√∫n entre distintas especificaciones. Por ejemplo, si una biblioteca requiere registrar objetos o configurar componentes, un contexto compartido puede reducir la repetici√≥n de c√≥digo.

```ruby
# En una biblioteca que maneja usuarios registrados:
RSpec.shared_context "with registered user" do
  let(:service) { UserService.new }
  before { service.register("arthur", "ni!") }
end

RSpec.describe UserService do
  include_context "with registered user"

  it "does not allow duplicate registration" do
    expect {
      service.register("arthur", "ni!")
    }.to raise_error(ArgumentError)
  end
end
```

<Explanation>
    Este ejemplo define un contexto compartido llamado `"with registered user"` que prepara el sistema con un usuario ya registrado. Al incluir este contexto con `include_context`, cualquier prueba que lo necesite puede asumir que el usuario `"arthur"` ya est√° presente en el sistema.

    Esto permite escribir pruebas m√°s concisas, evitando repetir la configuraci√≥n inicial en cada especificaci√≥n. Adem√°s, al centralizar esta l√≥gica en un solo lugar, se facilita el mantenimiento y la evoluci√≥n del c√≥digo de pruebas en bibliotecas que manejan m√∫ltiples escenarios con usuarios registrados.
</Explanation>

## üîê Autenticaci√≥n

```ruby showLineNumbers
RSpec.describe UserService do
  before(:each) do
    @service = UserService.new
    @service.register("ichigo", "shinigami123")
  end

  context "when authenticating an existing user" do
    it "returns true for valid credentials" do
      expect(@service.authenticate("ichigo", "shinigami123")).to eq(true)
    end

    it "returns false for wrong password" do
      expect(@service.authenticate("ichigo", "wrongpass")).to eq(false)
    end
  end

  context "when authenticating a non-existent user" do
    it "raises an exception" do
      expect {
        @service.authenticate("aizen", "anything")
      }.to raise_error(ArgumentError, "User not found")
    end
  end
end
```

## üìä Resumen comparativo

| **Aspecto**                        | **RSpec (Ruby)**                                                                 | **Kotest (Kotlin)**                                                               |
|-----------------------------------|----------------------------------------------------------------------------------|-----------------------------------------------------------------------------------|
| **Lenguaje**                      | Ruby                                                                             | Kotlin                                                                            |
| **Estilo BDD**                    | Basado en `describe`, `context`, `it`                                           | Varios estilos disponibles; en esta lecci√≥n se us√≥ `FreeSpec`                    |
| **Estructura Given/When/Then**   | Impl√≠cita a trav√©s de `describe/context/it`                                     | Impl√≠cita en la estructura jer√°rquica de bloques (`"given" - { "when" - { ... }`)|
| **Reutilizaci√≥n de pruebas**     | `shared_examples`, `shared_context`                                             | `include`, `should behave like`, y funciones auxiliares comunes                  |
| **Manejo de excepciones**        | `expect { ... }.to raise_error`                                                 | `shouldThrow<T> { ... }`                                                         |
| **Inicializaci√≥n por prueba**    | `before(:each)`                                                                 | `beforeEach`                                                                      |
| **Popularidad**                  | Amplio uso en Ruby on Rails y bibliotecas Ruby                                  | Muy usado en proyectos Kotlin multiplataforma, Android y bibliotecas modernas    |
| **Legibilidad**                  | Alta legibilidad, cercano al lenguaje natural                                   | Alta legibilidad, especialmente con estilos como `FreeSpec`                      |
| **Integraci√≥n con herramientas** | Compatible con herramientas est√°ndar de Ruby (Rails, Rake, etc.)                | Integraci√≥n con Gradle, IntelliJ, Android Studio, etc.                           |
| **Madurez del ecosistema**       | Muy maduro, con muchos a√±os de evoluci√≥n y comunidad establecida                | En crecimiento, con fuerte soporte en el ecosistema Kotlin                       |

### ‚úÖ Beneficios / ‚ùå limitaciones

<ProCons>
    <Pros>
        - **Sintaxis expresiva y legible**: Permite escribir pruebas que se leen como especificaciones funcionales, facilitando la comprensi√≥n incluso para personas no t√©cnicas.
        - **Soporte maduro para BDD**: Fue uno de los primeros frameworks en adoptar y fomentar el estilo BDD, con convenciones establecidas como `describe`, `context` e `it`.
        - **Reutilizaci√≥n efectiva**: Herramientas como `shared_examples` y `shared_context` permiten mantener las pruebas DRY, especialmente √∫til en bibliotecas que implementan m√∫ltiples variantes de un mismo contrato.
        - **Integraci√≥n s√≥lida con herramientas Ruby**: Funciona perfectamente en entornos Ruby/Rails, lo que lo hace ideal para bibliotecas orientadas a ese ecosistema.
        - **Gran comunidad y documentaci√≥n**: RSpec cuenta con una comunidad activa y una extensa base de ejemplos y documentaci√≥n, facilitando el aprendizaje y resoluci√≥n de problemas.
    </Pros>
    <Cons>
        - **Dependencia del ecosistema Ruby**: Su utilidad se reduce fuera del entorno Ruby, por lo que no es adecuado si la biblioteca debe ser multiplataforma o interoperar con otros lenguajes.
        - **Curva de aprendizaje inicial**: Aunque su sintaxis es clara, entender completamente su DSL y todas sus capacidades (como `let`, `subject`, hooks, etc.) puede tomar tiempo para personas nuevas en Ruby o RSpec.
        - **Sobrecarga en proyectos peque√±os**: Para bibliotecas simples, la estructura detallada de BDD con RSpec puede sentirse innecesaria o demasiado formal.
        - **Ejecuci√≥n m√°s lenta en grandes suites**: En proyectos con muchas pruebas, el rendimiento de RSpec puede ser menor comparado con frameworks m√°s minimalistas, especialmente si se abusa de `before`/`let` anidados.
    </Cons>
</ProCons>

## üéØ Conclusiones

RSpec es una herramienta poderosa y expresiva para escribir especificaciones orientadas al comportamiento en proyectos Ruby. Su dise√±o favorece la legibilidad, la colaboraci√≥n y la claridad, lo que lo hace ideal para bibliotecas que necesitan comunicar su comportamiento de forma precisa.

Aunque originalmente popularizado en el contexto de Rails, RSpec tambi√©n se adapta muy bien al desarrollo de bibliotecas de software. Sus capacidades como `shared_examples` y `shared_context` permiten construir suites de pruebas reutilizables, escalables y alineadas con principios de dise√±o s√≥lido.

Sin embargo, su utilidad est√° fuertemente ligada al ecosistema Ruby, por lo que su aplicaci√≥n fuera de este contexto puede ser limitada. Adem√°s, su flexibilidad puede volverse una desventaja si no se usa con disciplina, especialmente en proyectos peque√±os o con equipos nuevos en Ruby.

### üîë Puntos clave

- RSpec modela las pruebas siguiendo la estructura BDD con `describe`, `context` e `it`, lo que permite escribir especificaciones legibles y alineadas con el comportamiento esperado.
- La estructura `expect { ... }.to raise_error` es fundamental para validar condiciones excepcionales, especialmente en bibliotecas donde la robustez ante entradas inv√°lidas es cr√≠tica.
- Las herramientas de reutilizaci√≥n como `shared_examples` y `shared_context` ayudan a reducir la duplicaci√≥n y reforzar contratos comunes en m√∫ltiples implementaciones.
- La claridad de las pruebas escritas en RSpec puede servir como documentaci√≥n viviente del sistema, facilitando el mantenimiento y la colaboraci√≥n entre personas t√©cnicas y no t√©cnicas.

### üß∞ ¬øQu√© nos llevamos?

Adoptar RSpec con enfoque BDD no es solo una decisi√≥n t√©cnica, sino tambi√©n una apuesta por mejorar la comunicaci√≥n, la claridad y la calidad del software desde su dise√±o. En el desarrollo de bibliotecas, donde m√∫ltiples implementaciones pueden compartir un mismo contrato, la expresividad de RSpec y sus herramientas para la reutilizaci√≥n permiten construir pruebas que no solo verifican el c√≥digo, sino que lo explican.

Al escribir pruebas que se leen como especificaciones, reforzamos la idea de que el comportamiento es el centro del dise√±o. Nos permite anticipar errores, capturar expectativas y generar confianza, tanto en el c√≥digo como en las personas que lo usan o lo mantienen.

En √∫ltima instancia, lo que nos llevamos no es solo un conjunto de herramientas, sino una forma m√°s deliberada y emp√°tica de construir software: pensando en c√≥mo se comporta, c√≥mo se comunica y c√≥mo evoluciona junto a quienes lo utilizan.

## üìñ Referencias

### üî• Recomendadas

üìö Martin, R. C., & Carter, J. (Eds.). (2011). The Case for BDD. En D. Chelimsky, D. Astels, D. Zach, A. Helles√∏y, B. Helmkamp, & D. North, The RSpec book: Behaviour-driven development with RSpec, Cucumber, and friends (P2.0 printing, version: 2011-4-7, pp. 89‚Äì103). The Pragmatic Bookshelf.
