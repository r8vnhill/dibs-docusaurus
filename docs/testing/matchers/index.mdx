---
title: "Matchers: Testing Declarativo"
---
import ReadingTime from '@site/src/components/ReadingTime'
import { ProCons, Pros, Cons } from '@site/src/components/cajitas/ProCons'
import References from '@site/src/components/ReferencesComponent'
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'
import Exercise from '@site/src/components/exercise/Exercise'
import Solution from '@site/src/components/exercise/Solution'
import Hint from '@site/src/components/exercise/Hint'
import Definition from '@site/src/components/Definition'
import Corollary from '@site/src/components/Corollary'
import GithubRepoLink from '@site/src/components/git/GithubRepoLink'
import { LanguageCard } from '@site/src/components/cards/LanguageCard'
import Explanation from '@site/src/components/admonitions/Explanation'
import RepoClone from '@site/src/components/admonitions/RepoClone'

<ReadingTime />

Cuando escribimos pruebas automatizadas, es fundamental que el c칩digo de test sea **claro, expresivo y f치cil de mantener**. Las aserciones tradicionales (`assertEquals`, `assertTrue`, etc.) cumplen su prop칩sito, pero pueden resultar poco legibles o verbosas, especialmente en escenarios complejos. 

Los **matchers** surgen como una soluci칩n declarativa para expresar expectativas de forma m치s natural. En lugar de enfocarnos en c칩mo comparar valores, nos enfocamos en **qu칠 esperamos** de ellos. Esta aproximaci칩n no solo mejora la legibilidad, sino que tambi칠n produce mensajes de error m치s informativos y uniformes.

## 游눠 쯇or qu칠 usar Matchers en tus pruebas?

<ProCons>
    <Pros>
        - **Declarativos y Expresivos**: Hacen que las pruebas sean m치s legibles, ya que expresan las expectativas de manera m치s natural.
        - **Mensajes de error claros:** Ofrecen descripciones detalladas que facilitan el diagn칩stico r치pido cuando una prueba falla.
        - **Consistencia en el c칩digo de pruebas:** Promueven un estilo uniforme y f치cil de mantener a lo largo del proyecto.
        - **Amplio Soporte**: Son compatibles con diversos frameworks de testing como **AssertJ** (Java), **NUnit** (C#), **Scalatest** (Scala), **Jest** (TypeScript), **PyHamcrest** (Python), **RSpec** (Ruby), **GoogleTest** (C++), y **XCTest** (Swift), entre otros.        
    </Pros>
</ProCons>

## 丘뒲잺 Comparaci칩n: Aserciones vs. Matchers

| **Aserciones**                                                                                  | **Matchers**                                                                                                          |
|-------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------|
| Verificaciones b치sicas que comparan valores y lanzan una excepci칩n si la condici칩n no se cumple | Encapsulan las comparaciones y mensajes de error, proporcionando una API m치s limpia y expresiva para escribir pruebas |
| `assertNotEquals(user.username, null)`                                                          | `user.username.shouldNotBeNull()`                                                                                     |

Como vemos, los Matchers hacen que las pruebas sean m치s legibles, concisas y autoexplicativas. Al eliminar ruido visual y mejorar los mensajes de error, se vuelven una herramienta clave para escribir tests sostenibles y expresivos.

### 游빍 Ejemplos con Matchers en Kotlin

```kotlin
val survivor = Survivor(name = "Rick", location = "Alexandria")

// En lugar de:
assertNotNull(survivor.name)
assertEquals("Alexandria", survivor.location)

// Usamos:
survivor.name.shouldNotBeNull()
survivor.location shouldBe "Alexandria"
```

## 游빐 Pr칩ximos pasos

Ahora que comprendemos la importancia de los matchers y c칩mo mejoran la claridad de nuestras pruebas, estamos listxs para profundizar en su uso y personalizaci칩n. En las pr칩ximas secciones abordaremos:

- **Matchers predefinidos**: Exploraremos el conjunto de matchers que ya vienen listos para usar, cubriendo casos comunes como igualdad, nulidad, contenido de listas, rangos y expresiones regulares.
- **Matchers personalizados**: Aprenderemos a escribir nuestros propios matchers para adaptar las validaciones a nuestro dominio, haciendo que las pruebas sean a칰n m치s expresivas y reutilizables.
- **Matchers compuestos**: Veremos c칩mo combinar m칰ltiples condiciones en un solo matcher, lo que permite verificar comportamientos complejos de manera concisa y coherente.

Estas herramientas nos permitir치n escribir pruebas m치s precisas, legibles y alineadas con el dise침o del dominio, tanto en bibliotecas reutilizables como en aplicaciones completas.
