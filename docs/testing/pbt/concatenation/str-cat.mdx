---
title: "Caso de estudio: Concatenaci√≥n de cadenas"
---
import ReadingTime from '@site/src/components/ReadingTime'
import { ProCons, Pros, Cons } from '@site/src/components/cajitas/ProCons'
import References from '@site/src/components/ReferencesComponent'
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'
import Exercise from '@site/src/components/exercise/Exercise'
import Solution from '@site/src/components/exercise/Solution'
import Hint from '@site/src/components/exercise/Hint'
import Definition from '@site/src/components/Definition'
import Corollary from '@site/src/components/Corollary'
import GitHubRepoLink from '@site/src/components/git/GitHubRepoLink'
import { LanguageCard, JqwikCard } from '@site/src/components/cards/LanguageCard'
import Explanation from '@site/src/components/admonitions/Explanation'
import RepoClone from '@site/src/components/admonitions/RepoClone'
import ModuleSetup from '@site/src/components/cajitas/ModuleSetup'
import BoxedTabs from '@site/src/components/cajitas/BoxedTabs'

<ReadingTime />
<GitHubRepoLink repo={"property-based-testing-kt"} user={"r8vnhill"}/>
<ModuleSetup module='str-cat' task='setupStrCatModule'>
    ```kotlin showLineNumbers title="convention-plugins/src/main/kotlin/str-cat.gradle.kts"
    import tasks.ModuleSetupTask

    tasks.register<ModuleSetupTask>("setupStrCatModule") {
        description = "Creates the base module and files for the string concatenation properties lesson"
        module.set("str-cat")

        doLast {
            createFiles(
                packageName = "string",
                test to "StringConcatenationLengthTest.kt",
                test to "StringConcatenationMonoidTest.kt",
            )
        }
    }
    ```
</ModuleSetup>

Supongamos que queremos asegurarnos de que la concatenaci√≥n de strings en nuestro proyecto funciona de forma correcta. En lugar de probar casos espec√≠ficos con entradas puntuales, podemos buscar definir propiedades generales que deber√≠an cumplirse sin importar los valores de entrada. Esto nos lleva a preguntarnos: ¬øqu√© propiedades fundamentales debe respetar la concatenaci√≥n de strings?

## üì¶ Integrando Property-Based Testing en Nuestro Proyecto

Para comenzar a utilizar **Property-Based Testing** en tu proyecto, lo primero que debes hacer es agregar las dependencias necesarias en tu cat√°logo de versiones. Esto incluye las bibliotecas de Kotest para pruebas basadas en propiedades.

A√±ade las dependencias correspondientes en el archivo `versions.toml`:

<BoxedTabs>
    <TabItem label={"C√≥digo esencial"} value={"C√≥digo esencial"}>
        ```toml showLineNumbers
        [libraries]
        kotest-property = { module = "io.kotest:kotest-property", version.ref = "kotest" }
        [bundles]
        kotest = ["kotest-runner-junit5", "kotest-datatest", "kotest-property"]
        ```
    </TabItem>
    <TabItem label={"C√≥digo completo"} value={"C√≥digo completo"}>
        ```toml showLineNumbers title="gradle/libs.versions.toml"
        [versions]
        kotlin = "2.1.10"
        testing = "1.0.0"
        detekt = "1.23.8"
        kotest-framework = "5.9.1"

        [libraries]
        kotlin-gradle-plugin = { module = "org.jetbrains.kotlin:kotlin-gradle-plugin", version.ref = "kotlin" }
        detekt-formatting = { module = "io.gitlab.arturbosch.detekt:detekt-formatting", version.ref = "detekt" }
        kotest-runner-junit5 = { module = "io.kotest:kotest-runner-junit5", version.ref = "kotest-framework" }
        kotest-datatest = { module = "io.kotest:kotest-framework-datatest", version.ref = "kotest-framework" }
        kotest-property = { module = "io.kotest:kotest-property", version.ref = "kotest-framework" }

        [plugins]
        detekt = { id = "io.gitlab.arturbosch.detekt", version.ref = "detekt" }

        [bundles]
        kotest = ["kotest-runner-junit5", "kotest-datatest", "kotest-property"]
        ```
    </TabItem>
</BoxedTabs>

Con este **bundle** configurado, ya no es necesario a√±adir las dependencias de Kotest manualmente en el bloque `dependencies` de tu archivo de configuraci√≥n `build.gradle.kts`. Simplemente, puedes referenciar el bundle `kotest` y asegurarte de tener todas las herramientas necesarias para realizar pruebas basadas en propiedades.

Con este enfoque, el archivo de dependencias se mantiene limpio y organizado, facilitando futuras actualizaciones o la adici√≥n de herramientas de prueba.

## üõ†Ô∏è Implementaci√≥n del Test

Queremos asegurarnos de que al concatenar dos strings, la longitud del resultado siempre sea igual a la suma de sus longitudes. Esto es una propiedad **universal** de la concatenaci√≥n de cadenas, y podemos verificarlo con Property-Based Testing de la siguiente manera:

<BoxedTabs>
    <TabItem label={"C√≥digo esencial"} value={"C√≥digo esencial"}>
        ```kotlin showLineNumbers
        checkAll(Arb.string(), Arb.string()) { s1, s2 ->
            (s1 + s2) shouldHaveLength (s1.length + s2.length)
        }
        ```
    </TabItem>
    <TabItem label={"C√≥digo completo"} value={"C√≥digo completo"}>
        ```kotlin showLineNumbers title="str-cat/src/test/kotlin/com/github/username/strings/StringConcatenationLengthTest.kt"
        package com.github.username.strings

        import io.kotest.core.spec.style.FreeSpec
        import io.kotest.property.Arb
        import io.kotest.property.arbitrary.string
        import io.kotest.property.checkAll
        import io.kotest.matchers.string.shouldHaveLength

        class StringConcatenationLengthTest : FreeSpec({
            "A String" - {
                "when concatenated" - {
                    "should have the sum of the lengths of the original strings" {
                        checkAll(Arb.string(), Arb.string()) { s1, s2 ->
                            (s1 + s2) shouldHaveLength (s1.length + s2.length)
                        }
                    }
                }
            }
        })
        ```
    </TabItem>
</BoxedTabs>

<Explanation>
    - Usamos `checkAll` para realizar **testing basado en propiedades**, probando con diferentes combinaciones de inputs generados autom√°ticamente.
    - `Arb.string()` es un generador arbitrario que proporciona strings aleatorios, incluyendo casos de borde como el string vac√≠o.
    - La propiedad que estamos verificando es que la **longitud de la concatenaci√≥n de dos strings debe ser igual a la suma de las longitudes de los strings originales**. Esto se mantiene sin importar los valores espec√≠ficos de los strings generados.
</Explanation>

Esta t√©cnica permite probar de forma exhaustiva la propiedad del c√≥digo, garantizando que funcione correctamente bajo una variedad de condiciones.

## üîç Probando m√°s propiedades

Adem√°s de la propiedad de longitud que ya hemos probado, podemos definir otras propiedades fundamentales sobre los strings, que deber√≠an mantenerse sin importar la implementaci√≥n. Aqu√≠ es √∫til introducir el concepto de **monoide**.

### üìñ ¬øQu√© es un Monoide?

Un **monoide** es una estructura algebraica formada por:

- Un conjunto $A$
- Una operaci√≥n binaria $+$ que combina dos elementos de $A$
- Un elemento neutro $0$ que no altera el valor de ning√∫n elemento al ser combinado con √©l

Dicha estructura debe cumplir con las siguientes propiedades:

- **Asociatividad**: Para todo $a$, $b$, y $c$ en $A$, se cumple que $(a + b) + c = a + (b + c)$.
- **Elemento Neutro**: Para todo $a$ en $A$, se cumple que $a + 0 = 0 + a = a$.

En el contexto de strings, la operaci√≥n de **concatenaci√≥n** cumple con estas propiedades, y el string vac√≠o act√∫a como el **elemento neutro**. Diremos entonces que los strings forman un monoide bajo la operaci√≥n de concatenaci√≥n.

### üß™ Definiendo Propiedades del Monoide para Strings

Podemos verificar que la concatenaci√≥n de strings sigue las leyes de los monoides: la **identidad** (izquierda y derecha) y la **asociatividad**.

<BoxedTabs>
    <TabItem label={"C√≥digo esencial"} value={"C√≥digo esencial"}>
        ```kotlin showLineNumbers
        "left identity" {
            checkAll(Arb.string()) { s ->
                ("" + s) shouldBe s
            }
        }

        "right identity" {
            checkAll(Arb.string()) { s ->
                (s + "") shouldBe s
            }
        }

        "associativity" {
            checkAll(Arb.string(), Arb.string(), Arb.string()) { s1, s2, s3 ->
                ((s1 + s2) + s3) shouldBe (s1 + (s2 + s3))
            }
        }
        ```
    </TabItem>
    <TabItem label={"C√≥digo completo"} value={"C√≥digo completo"}>
        ```kotlin showLineNumbers
        package com.github.username.strings

        import io.kotest.core.spec.style.FreeSpec
        import io.kotest.matchers.shouldBe
        import io.kotest.property.Arb
        import io.kotest.property.arbitrary.string
        import io.kotest.property.checkAll

        class StringConcatenationMonoidTest : FreeSpec({
            "String concatenation" - {
                "should follow monoid laws" - {
                    "left identity" {
                        checkAll(Arb.string()) { s ->
                            ("" + s) shouldBe s
                        }
                    }

                    "right identity" {
                        checkAll(Arb.string()) { s ->
                            (s + "") shouldBe s
                        }
                    }

                    "associativity" {
                        checkAll(Arb.string(), Arb.string(), Arb.string()) { s1, s2, s3 ->
                            ((s1 + s2) + s3) shouldBe (s1 + (s2 + s3))
                        }
                    }
                }
            }
        })
        ```
    </TabItem>
</BoxedTabs>

<Explanation>
    - **Identidad por la izquierda**: Concatenar el string vac√≠o por la izquierda no cambia el valor original del string.
    - **Identidad por la derecha**: Concatenar el string vac√≠o por la derecha tampoco altera el valor original.
    - **Asociatividad**: La concatenaci√≥n de strings es asociativa, es decir, el orden en que se agrupan las operaciones de concatenaci√≥n no afecta el resultado.
</Explanation>

Este enfoque nos permite probar formalmente propiedades importantes de los strings y asegurar que el comportamiento esperado se mantenga bajo cualquier circunstancia.

## üìå Conclusiones

En esta lecci√≥n, exploramos c√≥mo **Property-Based Testing** nos permite verificar propiedades fundamentales de la concatenaci√≥n de strings, asegurando su comportamiento correcto sin depender de casos de prueba espec√≠ficos.  

### üîë Puntos clave

- **Testing basado en propiedades**: Probamos **principios generales** en lugar de valores concretos, lo que nos permite detectar m√°s errores de manera autom√°tica.  
- **Concatenaci√≥n y longitud**: Verificamos que la longitud de una concatenaci√≥n siempre sea igual a la suma de las longitudes individuales.  
- **Monoides y concatenaci√≥n**: Demostramos que los strings forman un **monoide**, cumpliendo con las propiedades de **asociatividad** e **identidad**.  

Al aplicar estos principios, aseguramos que la concatenaci√≥n de strings sea **correcta en cualquier situaci√≥n**, sin importar los valores de entrada.  

<div className="language-card-container">
    <JqwikCard link="/docs/testing/pbt/concatenation/jqwik"/>
    <LanguageCard
        logoSrc="https://spockframework.org/spock/docs/2.3/images/spock-main-logo.png"
        language="JVM: Spock"
        link="/docs/testing/pbt/concatenation/spock"
    />
    <LanguageCard
        logoSrc="https://www.svgrepo.com/show/354313/scala.svg"
        language="Scala: ScalaTest"
        link="/docs/testing/pbt/concatenation/scalatest"
    />
</div>

<References references={[
    {
        title: "8. Property-based testing",
        bookTitle: "Functional Programming in Kotlin",
        publisher: "Manning Publications Co. LLC",
        location: "Shelter Island, NY",
        pages: "150‚Äì176",
        year: "2021",
        author: "Marco Vermeulen, R√∫nar Bjarnason, Paul Chiusano",
        type: "book",
    },
]} additionalReferences={[
    {
        title: "Estructuras Algebr√°icas como Ejemplos de 2-Gr√°ficas",
        bookTitle: "Gr√°ficas De Gr√°ficas: Introducci√≥n a Teor√≠a De Categor√≠as",
        publisher: "",
        pages: "29‚Äì34",
        year: "2012",
        author: "Zbigniew Oziewicz & Fernando Raymundo Vel√°zquez Quesada",
        type: "book",
    },
]}/>
