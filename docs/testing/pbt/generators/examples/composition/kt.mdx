---
title: Composici贸n de Generadores
---

import ReadingTime from '@site/src/components/ReadingTime'
import { ProCons, Pros, Cons } from '@site/src/components/cajitas/ProCons'
import References from '@site/src/components/ReferencesComponent'
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'
import Exercise from '@site/src/components/exercise/Exercise'
import Solution from '@site/src/components/exercise/Solution'
import Hint from '@site/src/components/exercise/Hint'
import Definition from '@site/src/components/Definition'
import Corollary from '@site/src/components/Corollary'
import GitHubRepoLink from '@site/src/components/git/GitHubRepoLink'
import { LanguageCard } from '@site/src/components/cards/LanguageCard'
import Explanation from '@site/src/components/admonitions/Explanation'
import RepoClone from '@site/src/components/admonitions/RepoClone'
import ModuleSetup from '@site/src/components/cajitas/ModuleSetup'
import BoxedTabs from '@site/src/components/cajitas/BoxedTabs'

<ReadingTime />
<GitHubRepoLink user="r8vnhill" repo="testing-kt" />
<ModuleSetup module='stats' task='setupArbCompositionModule'>
    ```kotlin showLineNumbers
    import tasks.ModuleSetupTask

    tasks.register<ModuleSetupTask>("setupArbCompositionModule") {
        description = "Creates the base module and files for the arbitrary composition lesson"
        module.set("pbt:arbitrary:composition")
        doLast {
            createFiles(
                "forms",
                main to "UserInput.kt",
                test to "FormValidationTest.kt",
            )
            createFiles(
                "config",
                test to "ConfigGenerators.kt"
            )
        }
    }
    ```
</ModuleSetup>

En **property-based testing (PBT)**, la clave es generar datos variados y realistas para verificar que una biblioteca de software funcione correctamente en distintos escenarios. En **Behavior-Driven Development (BDD)**, primero definimos las expectativas sobre el comportamiento de la funcionalidad antes de implementar los generadores. 

Kotest nos permite definir pruebas expresivas siguiendo BDD y generar datos complejos mediante **composici贸n de generadores**. Esto es 煤til en bibliotecas de software que manejan estructuras configurables o datos extensibles.

##  Definiendo los Tests Antes de los Generadores

Antes de crear los generadores, escribiremos los tests que definir谩n el comportamiento esperado de la biblioteca. Supongamos que estamos desarrollando una **biblioteca de validaci贸n de formularios**, donde validamos que los datos generados cumplan ciertas condiciones.

Usaremos Kotest con **property-based testing** para definir las siguientes pruebas:

<BoxedTabs>
    <TabItem label={"C贸digo esencial"} value={"C贸digo esencial"}>
        ```kotlin showLineNumbers
        checkAll(arbUserInput()) { user ->
            user.name shouldHaveMinLength 3
        }
        ```

        ```kotlin showLineNumbers
        checkAll(arbUserInput()) { user ->
            user.email shouldMatch Regex("[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}")
        }
        ```

        ```kotlin showLineNumbers
        checkAll(arbUserInput()) { user ->
            (user.age shouldBeGreaterThanOrEqual 18) and
                    (user.age shouldBeLessThanOrEqual 99)
        }
        ```
    </TabItem>
    <TabItem label={"C贸digo completo"} value={"C贸digo completo"}>
        ```kotlin showLineNumbers title="pbt/arbitrary/composition/src/test/kotlin/cl/ravenhill/forms/FormValidationTest.kt"
        package cl.ravenhill.forms

        import io.kotest.core.spec.style.FreeSpec
        import io.kotest.matchers.ints.shouldBeGreaterThanOrEqual
        import io.kotest.matchers.ints.shouldBeLessThanOrEqual
        import io.kotest.matchers.string.shouldHaveMinLength
        import io.kotest.matchers.string.shouldMatch
        import io.kotest.property.Arb
        import io.kotest.property.arbitrary.bind
        import io.kotest.property.arbitrary.int
        import io.kotest.property.arbitrary.string
        import io.kotest.property.arbitrary.stringPattern
        import io.kotest.property.checkAll

        class FormValidationTest : FreeSpec({
            "Given a user input" - {
                "when validating it" - {
                    "then it should have at least 3 characters" {
                        checkAll(arbUserInput()) { user ->
                            user.name shouldHaveMinLength 3
                        }
                    }

                    "then it should have the correct format" {
                        checkAll(arbUserInput()) { user ->
                            user.email shouldMatch Regex("[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}")
                        }
                    }

                    "then it should be between 18 and 99" {
                        checkAll(arbUserInput()) { user ->
                            (user.age shouldBeGreaterThanOrEqual 18) and
                                    (user.age shouldBeLessThanOrEqual 99)
                        }
                    }
                }
            }
        })
        ```
    </TabItem>
</BoxedTabs>

Aqu铆, cada prueba define una propiedad que debe cumplirse para todos los datos generados. Ahora, implementaremos los generadores para que los tests pasen.

##  Construyendo Generadores para Validaciones

Kotest proporciona herramientas para construir generadores reutilizables. Vamos a definir generadores para nombres, correos electr贸nicos y edades, asegur谩ndonos de que cumplan con los requisitos de validaci贸n.

<BoxedTabs>
    <TabItem label={"C贸digo esencial"} value={"C贸digo esencial"}>
        ```kotlin showLineNumbers
        fun arbName(): Arb<String> = Arb.string(3..20)  // Nombres de m铆nimo 3 caracteres
        fun arbEmail(): Arb<String> = Arb.stringPattern("[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}") // Emails v谩lidos
        fun arbAge(): Arb<Int> = Arb.int(18..99)  // Edad dentro del rango permitido
        ```

        Ahora, combinemos estos generadores en una sola estructura con `Arb.bind`:

        ```kotlin showLineNumbers
        fun arbUserInput(): Arb<UserInput> = Arb.bind(
            arbName(),
            arbEmail(),
            arbAge()
        ) { name, email, age -> UserInput(name, email, age) }
        ```
    </TabItem>
    <TabItem label={"C贸digo completo"} value={"C贸digo completo"}>
        ```kotlin showLineNumbers title="pbt/arbitrary/composition/src/test/kotlin/cl/ravenhill/forms/FormValidationTest.kt"
        package cl.ravenhill.forms

        import io.kotest.core.spec.style.FreeSpec
        import io.kotest.matchers.ints.shouldBeGreaterThanOrEqual
        import io.kotest.matchers.ints.shouldBeLessThanOrEqual
        import io.kotest.matchers.string.shouldHaveMinLength
        import io.kotest.matchers.string.shouldMatch
        import io.kotest.property.Arb
        import io.kotest.property.arbitrary.bind
        import io.kotest.property.arbitrary.int
        import io.kotest.property.arbitrary.string
        import io.kotest.property.arbitrary.stringPattern
        import io.kotest.property.checkAll

        class FormValidationTest : FreeSpec({
            "Given a user input" - {
                "when validating it" - {
                    "then it should have at least 3 characters" {
                        checkAll(arbUserInput()) { user ->
                            user.name shouldHaveMinLength 3
                        }
                    }

                    "then it should have the correct format" {
                        checkAll(arbUserInput()) { user ->
                            user.email shouldMatch Regex("[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}")
                        }
                    }

                    "then it should be between 18 and 99" {
                        checkAll(arbUserInput()) { user ->
                            (user.age shouldBeGreaterThanOrEqual 18) and
                                    (user.age shouldBeLessThanOrEqual 99)
                        }
                    }
                }
            }
        })

        // highlight-start
        private fun arbName(): Arb<String> = Arb.string(3..20)  // Nombres de m铆nimo 3 caracteres
        private fun arbEmail(): Arb<String> = Arb.stringPattern("[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}") // Emails v谩lidos
        private fun arbAge(): Arb<Int> = Arb.int(18..99)  // Edad dentro del rango permitido
        private fun arbUserInput(): Arb<UserInput> = Arb.bind(
            arbName(), 
            arbEmail(), 
            arbAge()
        ) { name, email, age -> UserInput(name, email, age) }
        // highlight-end
        ```
    </TabItem>
</BoxedTabs>

<Explanation>
    `Arb.bind` combina m煤ltiples generadores en una estructura de datos compleja. En este caso, generamos un `UserInput` con un nombre, un correo electr贸nico y una edad v谩lidos.
</Explanation>

Con este generador, cada ejecuci贸n de `arbUserInput()` producir谩 un usuario con datos aleatorios pero v谩lidos.

##  Generaci贸n de Datos en Colecciones

Si nuestra biblioteca maneja **listas de usuarios**, podemos definir un generador de listas:

```kotlin showLineNumbers
fun arbUserList(): Arb<List<UserInput>> = Arb.list(arbUserInput(), 1..10)
```

Si queremos garantizar que los emails no se repitan en una lista de usuarios, usamos un conjunto:

```kotlin showLineNumbers
fun arbUniqueUsers(): Arb<Set<UserInput>> = Arb.set(arbUserInput(), 1..10)
```

##  Ejercicio Pr谩ctico: Generar Configuraci贸n de una Biblioteca

<Exercise>
    Supongamos que estamos dise帽ando una **biblioteca para gestionar configuraciones de una aplicaci贸n**. Los usuarios pueden definir **opciones de configuraci贸n**, que pueden incluir valores de diferentes tipos, como:

    - `String` para nombres de usuario.
    - `Boolean` para opciones de activaci贸n/desactivaci贸n.
    - `Int` para l铆mites num茅ricos.

     **Objetivo:** Crea un generador que produzca una lista de opciones de configuraci贸n. Cada opci贸n debe ser representada como un par `<clave, valor>`, donde la clave es un `String` y el valor puede ser un `String`, `Int` o `Boolean`.

    <Hint hints={[
        <>
            Utiliza el generador <code>Arb.pair: (Arb&lt;A&gt;, Arb&lt;B&gt;) -&gt; Arb&lt;Pair&lt;A, B&gt;&gt;</code> para combinar generadores de claves y valores.
        </>,
        <>
            Utiliza <code>Arb.choice: (Arb&lt;A&gt;, Arb&lt;A&gt;, ...) -&gt; Arb&lt;A&gt;</code> para elegir entre diferentes tipos de valores. Puedes considerar el tipo de <code>A</code> como un <code>Any</code>.
        </>
    ]}/>

    <Solution>
        <BoxedTabs>
            <TabItem label={"C贸digo esencial"} value={"C贸digo esencial"}>
                ```kotlin showLineNumbers
                fun arbConfigOption(): Arb<Pair<String, Any>> = Arb.pair(
                    Arb.string(5..15), // Clave con longitud entre 5 y 15 caracteres
                    Arb.choice(Arb.string(1..20), Arb.int(1..100), Arb.boolean()) // Valores de diferentes tipos
                )

                fun arbConfigList(): Arb<List<Pair<String, Any>>> = Arb.list(arbConfigOption(), 3..10)
                ```
            </TabItem>
            <TabItem label={"C贸digo completo"} value={"C贸digo completo"}>
                ```kotlin showLineNumbers title="pbt/arbitrary/composition/src/test/kotlin/cl/ravenhill/config/ConfigGenerators.kt"
                package cl.ravenhill.config

                import io.kotest.core.spec.style.FreeSpec
                import io.kotest.matchers.collections.shouldHaveAtLeastSize
                import io.kotest.matchers.collections.shouldHaveAtMostSize
                import io.kotest.matchers.or
                import io.kotest.matchers.should
                import io.kotest.matchers.string.shouldHaveMinLength
                import io.kotest.matchers.types.beInstanceOf
                import io.kotest.property.Arb
                import io.kotest.property.arbitrary.*
                import io.kotest.property.checkAll

                class ConfigGeneratorsTest : FreeSpec({

                    "Given a configuration option generator" - {
                        "when generating a configuration option" - {
                            "then the key should be a non-empty string with at least 5 characters" {
                                checkAll(arbConfigOption()) { (key, _) ->
                                    key shouldHaveMinLength 5
                                }
                            }

                            "then the value should be a String, Int, or Boolean" {
                                checkAll(arbConfigOption()) { (_, value) ->
                                    value should (beInstanceOf<String>()
                                            or beInstanceOf<Int>()
                                            or beInstanceOf<Boolean>())
                                }
                            }
                        }
                    }

                    "Given a configuration list generator" - {
                        "when generating a list of configuration options" - {
                            "then the list should contain between 3 and 10 elements" {
                                checkAll(arbConfigList()) { configList ->
                                    configList
                                        .shouldHaveAtLeastSize(3)
                                        .shouldHaveAtMostSize(10)
                                }
                            }

                            "then each configuration option should have a valid key-value pair" {
                                checkAll(arbConfigList()) { configList ->
                                    configList.forEach { (key, value) ->
                                        key.shouldHaveMinLength(5)
                                        value should (beInstanceOf<String>()
                                                or beInstanceOf<Int>()
                                                or beInstanceOf<Boolean>())
                                    }
                                }
                            }
                        }
                    }
                })

                // highlight-start
                private fun arbConfigOption(): Arb<Pair<String, Any>> = Arb.pair(
                    Arb.string(5..15),
                    Arb.choice(Arb.string(1..20), Arb.int(1..100), Arb.boolean())
                )

                private fun arbConfigList(): Arb<List<Pair<String, Any>>> = Arb.list(arbConfigOption(), 3..10)
                // highlight-end
                ```
            </TabItem>
        </BoxedTabs>
    </Solution>
</Exercise>

##  Conclusiones

La composici贸n de generadores es una herramienta poderosa para dise帽ar pruebas expresivas y robustas en el desarrollo de bibliotecas de software. Al combinar generadores b谩sicos en estructuras m谩s complejas, no solo validamos el comportamiento esperado, sino que tambi茅n acercamos nuestros tests a los escenarios reales de uso.

Este enfoque resulta especialmente 煤til cuando desarrollamos bibliotecas que operan sobre datos configurables, entradas din谩micas o estructuras heterog茅neas. Gracias a herramientas como Kotest, podemos aplicar **property-based testing** de forma sencilla y declarativa, manteniendo los tests legibles, reutilizables y alineados con los principios de BDD.

###  Puntos clave

- **Composici贸n con `Arb.bind`**: Permite generar estructuras complejas combinando generadores simples.
- **Tests primero, generadores despu茅s**: Al definir primero los tests, guiamos el dise帽o de nuestros generadores en funci贸n del comportamiento esperado.
- **Colecciones y restricciones**: Podemos generar listas, conjuntos o mapas aplicando restricciones adicionales como unicidad o tama帽o.
- **Adaptabilidad a distintos dominios**: El patr贸n se aplica bien a bibliotecas de validaci贸n, configuraci贸n, procesamiento de datos, parsers, entre otros.

### О 驴Qu茅 nos llevamos?

El uso de composici贸n de generadores nos permite construir pruebas m谩s expresivas, minimizar falsos positivos y detectar errores ocultos al cubrir una mayor variedad de escenarios. Esto no solo aumenta la calidad del software que entregamos, sino que tambi茅n promueve un dise帽o m谩s claro, modular y orientado a comportamiento.

Adoptar este enfoque en nuestras bibliotecas contribuye a un desarrollo m谩s seguro y colaborativo, ya que los generadores tambi茅n documentan las expectativas del dominio de manera precisa y reutilizable.

##  Referencias

###  Recomendadas

-  Generator Operations | Kotest. (s.f.). Recuperado 20 de marzo de 2025, de https://kotest.io/docs/proptest/generator-operations.html
