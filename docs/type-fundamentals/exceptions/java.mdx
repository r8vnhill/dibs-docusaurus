---
title: Excepciones en Java
---
import ReadingTime from '@site/src/components/ReadingTime'
import { ProCons, Pros, Cons } from '@site/src/components/cajitas/ProCons'
import References from '@site/src/components/ReferencesComponent'
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'
import Exercise from '@site/src/components/exercise/Exercise'
import Solution from '@site/src/components/exercise/Solution'
import Hint from '@site/src/components/exercise/Hint'
import Definition from '@site/src/components/Definition'
import Corollary from '@site/src/components/Corollary'
import GithubRepoLink from '@site/src/components/git/GithubRepoLink'
import { LanguageCard } from '@site/src/components/cards/LanguageCard'
import Explanation from '@site/src/components/admonitions/Explanation'
import RepoClone from '@site/src/components/admonitions/RepoClone'
import ModuleSetup from '@site/src/components/cajitas/ModuleSetup'
import BoxedTabs from '@site/src/components/cajitas/BoxedTabs'

<ReadingTime />
<GithubRepoLink user="r8vnhill" repo="java-dibs" />

Al igual que **Kotlin**, **Java** es conocido por su manejo de excepciones robusto. Sin embargo, aunque comparten muchas similitudes, existen diferencias clave entre c√≥mo se gestionan las excepciones en estos lenguajes. A continuaci√≥n, exploraremos esas diferencias y similitudes.

## üéØ Lanzar Excepciones

En ambos lenguajes, para lanzar una excepci√≥n se utiliza `throw`. En Java, al igual que en Kotlin, podemos lanzar cualquier subclase de `Throwable`, como `Exception` o `RuntimeException`.

<BoxedTabs>
    <TabItem label={"C√≥digo esencial"} value={"C√≥digo esencial"}>
        ```java showLineNumbers
        throw new IllegalArgumentException("Divisor can't be zero");
        ```
    </TabItem>
    <TabItem label={"C√≥digo completo"} value={"C√≥digo completo"}>
        ```java showLineNumbers title="type-fundamentals/exceptions/src/main/java/cl/ravenhill/math/Divider.java"
        package cl.ravenhill.math;

        public class Divider {
            public static double divide(double dividend, double divisor) {
                if (divisor == 0) {
                    throw new IllegalArgumentException("Divisor can't be zero");
                }
                return dividend / divisor;
            }

            public static void main(String[] args) {
                System.out.println(divide(10, 2));
                System.out.println(divide(10, 0));
                /* Output:
                5.0
                Exception in thread "main" java.lang.IllegalArgumentException: Divisor can't be zero
                    at cl.ravenhill.math.Divider.divide(Divider.java:6)
                    at cl.ravenhill.math.Divider.main(Divider.java:13)
                */
            }
        }
        ```
    </TabItem>
</BoxedTabs>

## ‚úÖ Excepciones Chequeadas

Una diferencia fundamental entre **Java** y **Kotlin** es el concepto de **excepciones chequeadas**. En **Java**, las excepciones se dividen en dos categor√≠as: **chequeadas** y **no chequeadas**. Las excepciones chequeadas (subclases de `Exception`, excepto `RuntimeException`) deben ser gestionadas expl√≠citamente ya sea mediante un bloque `try-catch` o declarando la excepci√≥n en la firma del m√©todo utilizando la palabra clave `throws`. Esto impone una obligaci√≥n en el c√≥digo, exigiendo que cada posible excepci√≥n sea tratada en tiempo de compilaci√≥n.

Por otro lado, **Kotlin no tiene excepciones chequeadas**, lo que simplifica el c√≥digo, ya que no es necesario declarar expl√≠citamente las excepciones que un m√©todo puede lanzar, ni forzar su captura. Aunque este enfoque reduce el c√≥digo boilerplate, puede generar un riesgo potencial de no tratar adecuadamente excepciones cr√≠ticas.

<BoxedTabs>
    <TabItem label={"C√≥digo esencial"} value={"C√≥digo esencial"}>
        ```java showLineNumbers
        public static void main(String[] args)
                // highlight-next-line
                throws IOException {
            throw new IOException("This is a risky operation");
        }
        ```
    </TabItem>
    <TabItem label={"C√≥digo completo"} value={"C√≥digo completo"}>
        ```java showLineNumbers title="type-fundamentals/exceptions/src/main/java/cl/ravenhill/RiskyOperation.java"
        package cl.ravenhill;

        import java.io.IOException;

        public class RiskyOperation {
            public static void main(String[] args)
                    // highlight-next-line
                    throws IOException {
                throw new IOException("This is a risky operation");
            }
        }
        ```
    </TabItem>
</BoxedTabs>

<Explanation>
    En este ejemplo, Java obliga a declarar que el m√©todo `main` puede lanzar una excepci√≥n `IOException` mediante `throws IOException`. Si el m√©todo no gestiona esta excepci√≥n dentro de un bloque `try-catch`, es obligatorio declararla. En Kotlin, no se necesitar√≠a esta declaraci√≥n, ya que no existen excepciones chequeadas.
</Explanation>

### ‚ö†Ô∏è Limitaciones para Lambdas con Excepciones Chequeadas

En **Java**, las excepciones chequeadas tambi√©n limitan el uso de **lambdas** y expresiones funcionales. Dado que las lambdas no pueden lanzar excepciones chequeadas sin declarar expl√≠citamente esas excepciones, esto complica el c√≥digo y puede hacer que las lambdas sean menos flexibles en escenarios donde ocurran operaciones riesgosas. A menudo, se recurre a estrategias alternativas, como envolver la lambda en una excepci√≥n no chequeada o usar constructos adicionales para gestionar las excepciones.

## üõë Capturar Excepciones

Ambos lenguajes utilizan bloques `try-catch` para manejar excepciones, pero la sintaxis de Kotlin es m√°s compacta y puede devolver valores directamente dentro del bloque `try`.

<BoxedTabs>
    <TabItem label={"C√≥digo esencial"} value={"C√≥digo esencial"}>
        ```java showLineNumbers
        try {
            return Optional.of(Divider.divide(dividend, divisor));
        } catch (IllegalArgumentException e) {
            return Optional.empty();
        }
        ```
    </TabItem>
    <TabItem label={"C√≥digo completo"} value={"C√≥digo completo"}>
        ```java showLineNumbers title="type-fundamentals/exceptions/src/main/java/cl/ravenhill/math/SafeDivider.java"
        package cl.ravenhill.math;

        import java.util.Optional;

        public class SafeDivider {
            public static Optional<Double> divide(double dividend, double divisor) {
                try {
                    return Optional.of(Divider.divide(dividend, divisor));
                } catch (IllegalArgumentException e) {
                    return Optional.empty();
                }
            }

            public static void main(String[] args) {
                System.out.println(divide(10, 2));
                System.out.println(divide(10, 0));
                /* Output:
                Optional[5.0]
                Optional.empty
                */
            }
        }
        ```
    </TabItem>
</BoxedTabs>

### üîÑ Bloque `finally`

El comportamiento del bloque `finally` es id√©ntico en ambos lenguajes: se ejecuta siempre, tanto si ocurre una excepci√≥n como si no. Esto se utiliza normalmente para liberar recursos como conexiones a bases de datos o archivos.

<BoxedTabs>
    <TabItem label={"C√≥digo esencial"} value={"C√≥digo esencial"}>
        ```java showLineNumbers
        try {
            // Operaci√≥n que puede lanzar una excepci√≥n
        } catch (FileNotFoundException e) {
            // Manejar la excepci√≥n
        } catch (IOException e) {
            // Manejar la excepci√≥n
        } finally {
            // Liberar recursos
        }
        ```
    </TabItem>
    <TabItem label={"C√≥digo completo"} value={"C√≥digo completo"}>
        ```java showLineNumbers title="type-fundamentals/exceptions/src/main/java/cl/ravenhill/io/FileProcessor.java"
        package cl.ravenhill.io;

        import org.jetbrains.annotations.NotNull;

        import java.io.BufferedReader;
        import java.io.File;
        import java.io.FileNotFoundException;
        import java.io.IOException;
        import java.util.Optional;

        public class FileProcessor {
            @NotNull
            public static String processFile(String fileName) {
                Optional<BufferedReader> reader = Optional.empty();
                var content = new StringBuilder();
                try {
                    var file = new File(fileName);
                    reader = Optional.of(new BufferedReader(new java.io.FileReader(file)));
                    String line;
                    while ((line = reader.get().readLine()) != null) {
                        content.append(line).append("\n");
                    }
                } catch (FileNotFoundException e) {
                    System.err.println("File not found: " + e.getMessage());
                } catch (IOException e) {
                    System.err.println("Error reading file: " + e.getMessage());
                } finally {
                    reader.ifPresent(r -> {
                        try {
                            r.close();
                        } catch (IOException e) {
                            System.err.println("Error closing file: " + e.getMessage());
                        }
                    });
                }
                return content.toString();
            }

            public static void main(String[] args) {
                System.out.println(processFile("type-fundamentals/exceptions/src/main/java/cl/ravenhill/io/FileProcessor.java"));
                System.out.println(processFile("type-fundamentals/exceptions/src/main/java/cl/ravenhill/io/NonExistentFile.java"));
                /* Output:
                package cl.ravenhill.io;package cl.ravenhill.io;

                import org.jetbrains.annotations.NotNull;
                
                ...
                
                File not found: intro\exceptions\src\main\java\cl\ravenhill\io\NonExistentFile.java (The system cannot find the file specified)
                */
            }
        }
        ```
    </TabItem>
</BoxedTabs>

### üìå Try-With-Resources en Java

Java proporciona una sintaxis especial llamada `try-with-resources` para manejar recursos que implementan la interfaz `AutoCloseable`. Esto simplifica la liberaci√≥n de recursos, ya que no es necesario cerrar expl√≠citamente los recursos en el bloque `finally`.

<BoxedTabs>
    <TabItem label={"C√≥digo esencial"} value={"C√≥digo esencial"}>
        ```java showLineNumbers
        try (var reader = new BufferedReader(new FileReader(fileName))) {
            // Operaci√≥n que puede lanzar una excepci√≥n
        } catch (FileNotFoundException e) {
            // Manejar la excepci√≥n
        } catch (IOException e) {
            // Manejar la excepci√≥n
        }
        ```
    </TabItem>
    <TabItem label={"C√≥digo completo"} value={"C√≥digo completo"}>
        ```java showLineNumbers title="type-fundamentals/exceptions/src/main/java/cl/ravenhill/io/AutoCloseableFileProcessor.java"
        package cl.ravenhill.io;

        import org.jetbrains.annotations.NotNull;

        import java.io.BufferedReader;
        import java.io.FileReader;

        public class AutoCloseableFileProcessor {
            public static @NotNull String processFile(String fileName) {
                try (var reader = new BufferedReader(new FileReader(fileName))) {
                    var content = new StringBuilder();
                    String line;
                    while ((line = reader.readLine()) != null) {
                        content.append(line).append("\n");
                    }
                    return content.toString();
                } catch (java.io.FileNotFoundException e) {
                    System.err.println("File not found: " + e.getMessage());
                } catch (java.io.IOException e) {
                    System.err.println("Error reading file: " + e.getMessage());
                }
                return "";
            }

            public static void main(String[] args) {
                System.out.println(processFile("type-fundamentals/exceptions/src/main/java/cl/ravenhill/io/AutoCloseableFileProcessor.java"));
                System.out.println(processFile("type-fundamentals/exceptions/src/main/java/cl/ravenhill/io/NonExistentFile.java"));
                /* Output:
                package cl.ravenhill.io;package cl.ravenhill.io;

                import org.jetbrains.annotations.NotNull;

                ...

                File not found: intro\exceptions\src\main\java\cl\ravenhill\io\NonExistentFile.java (The system cannot find the file specified)
                */
            }
        }
        ```
    </TabItem>
</BoxedTabs>

## üîß Excepciones Personalizadas

En ambos lenguajes, puedes crear excepciones personalizadas heredando de `Exception`. El proceso en Java es pr√°cticamente id√©ntico a Kotlin:

<BoxedTabs>
    <TabItem label={"C√≥digo esencial"} value={"C√≥digo esencial"}>
        ```java showLineNumbers
        public class EdSheeranException extends Exception {
            public EdSheeranException(String message) {
                super(message);
            }
        }
        ```
    </TabItem>
    <TabItem label={"C√≥digo completo"} value={"C√≥digo completo"}>
        ```java showLineNumbers title="type-fundamentals/exceptions/src/main/java/cl/ravenhill/sheeran/EdSheeran.java"
        package cl.ravenhill.sheeran;

        public class EdSheeranException extends Exception {
            public EdSheeranException(String message) {
                super(message);
            }
        }
        ```

        ```java showLineNumbers title="type-fundamentals/exceptions/src/main/java/cl/ravenhill/sheeran/EdSheeran.java"
        package cl.ravenhill.sheeran;

        public class EdSheeran {
            public static void validateAge(int age) throws EdSheeranException {
                if (age >= 70) {
                    throw new EdSheeranException(
                        "And, darling, I will be loving you 'til we're 70"
                    );
                }
            }

            public static void main(String[] args) {
                try {
                    validateAge(70);
                } catch (EdSheeranException e) {
                    System.out.println(e.getMessage());
                }
                /* Output:
                And, darling, I will be loving you 'til we're 70
                */
            }
        }
        ```
    </TabItem>
</BoxedTabs>

## üìä Resumen Comparativo

| **Caracter√≠stica**                    | **Java**                                                                                                                                                                  | **Kotlin**                                                                                                                                                  |
|---------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------|
| **Lanzar excepciones**                | Usa `throw` para lanzar excepciones. Cualquier subclase de `Throwable`, como `Exception` o `RuntimeException`, puede ser lanzada.                                         | Igual que en Java, permite lanzar cualquier subclase de `Throwable`.                                                                                        |
| **Excepciones chequeadas**            | Diferencia entre **excepciones chequeadas** y **no chequeadas**. Las chequeadas deben manejarse o declararse en la firma del m√©todo con `throws`.                         | No existen excepciones chequeadas, lo que simplifica el c√≥digo pero requiere manejar errores importantes expl√≠citamente.                                    |
| **Manejo de excepciones en lambdas**  | Las lambdas no pueden lanzar excepciones chequeadas sin declararlas expl√≠citamente, lo que limita su flexibilidad para operaciones que pueden fallar.                     | Las lambdas pueden lanzar excepciones sin restricciones de tipo chequeado, permitiendo un uso m√°s flexible en expresiones funcionales.                     |
| **Captura de excepciones**            | Utiliza `try-catch` para capturar excepciones. Los m√©todos que pueden fallar pueden devolver `Optional.empty()` para un manejo seguro de errores sin lanzar excepciones.  | Tambi√©n utiliza `try-catch`, con una sintaxis m√°s compacta. Permite devolver valores directamente en el bloque `try`, lo que simplifica algunos casos.     |
| **Bloque `finally`**                  | Igual que en Kotlin, el bloque `finally` se ejecuta siempre, tanto si ocurre una excepci√≥n como si no, generalmente para liberar recursos.                                | Funciona igual que en Java, permitiendo la limpieza de recursos tras la ejecuci√≥n de `try-catch`.                                                          |
| **Try-with-resources**                | Ofrece `try-with-resources` para manejar recursos de forma segura, simplificando la liberaci√≥n autom√°tica de recursos que implementan `AutoCloseable`.                    | Soporta el uso de la funci√≥n de extensi√≥n `use` para manejar recursos de manera segura y liberar autom√°ticamente recursos que implementan `Closeable`.     |
| **Excepciones personalizadas**        | Permite crear excepciones personalizadas heredando de `Exception`, facilitando un manejo de errores espec√≠fico.                                                           | Igual que en Java, permite crear excepciones personalizadas y lanzarlas sin distinci√≥n entre chequeadas y no chequeadas.                                   |
| **Creaci√≥n de excepciones**           | Se pueden crear clases de excepciones espec√≠ficas para cada tipo de error en el programa, mejorando la claridad del manejo de errores en aplicaciones grandes.            | Igual que en Java, facilita la creaci√≥n de clases de excepci√≥n espec√≠ficas, manteniendo el c√≥digo legible y modularizado en la gesti√≥n de errores.

### ‚úÖ Beneficios y ‚ùå limitaciones de Java

<ProCons>
    <Pros>
        - **Control de errores expl√≠cito**: Las excepciones chequeadas en Java obligan a quien desarrolla a manejar o declarar posibles errores, aumentando la robustez y previsibilidad del c√≥digo.
        - **Manejo de recursos seguro**: La sintaxis `try-with-resources` simplifica la liberaci√≥n de recursos y reduce el riesgo de fugas de memoria, especialmente en aplicaciones que interact√∫an con archivos o bases de datos.
        - **Compatibilidad y legado**: Java es ampliamente compatible con otros lenguajes y sistemas, y su sistema de excepciones chequeadas es familiar para desarrolladores que buscan controlar de manera rigurosa el flujo de errores.
    </Pros>
    <Cons>
        - **C√≥digo verboso**: Las excepciones chequeadas pueden hacer que el c√≥digo sea m√°s verboso, ya que cada m√©todo que lanza excepciones debe especificarlas en la firma o incluir bloques `try-catch`.
        - **Limitaci√≥n en lambdas**: Las lambdas no pueden lanzar excepciones chequeadas sin declararlas, lo cual puede complicar la utilizaci√≥n de funciones lambda y hacer que el c√≥digo sea menos flexible en contextos funcionales.
        - **Menor flexibilidad en expresiones funcionales**: La obligaci√≥n de manejar o declarar excepciones limita la composici√≥n de funciones y el uso fluido de expresiones funcionales en Java, haciendo el c√≥digo menos adaptable y conciso en ciertas situaciones.
    </Cons>
</ProCons>

## üèÅ Conclusiones  

El manejo de excepciones en **Java** es una de sus caracter√≠sticas distintivas, ofreciendo un sistema robusto con excepciones chequeadas y no chequeadas. En esta comparaci√≥n con **Kotlin**, hemos explorado las ventajas y limitaciones de ambos enfoques, resaltando sus diferencias en cuanto a flexibilidad, seguridad y verbosidad del c√≥digo.  

### üîë Puntos clave  

- **Excepciones chequeadas vs. no chequeadas**:  
    - Java diferencia entre **excepciones chequeadas**, que deben declararse o capturarse, y **no chequeadas**, que pueden propagarse libremente.  
    - Kotlin no tiene excepciones chequeadas, lo que simplifica la escritura del c√≥digo pero delega la responsabilidad de manejo de errores a quien desarrolla.  
- **Captura y manejo de excepciones**:  
    - Ambos lenguajes utilizan `try-catch`, pero Kotlin permite una sintaxis m√°s compacta y expresiva.  
    - Java permite `try-with-resources` para gestionar recursos de forma autom√°tica, mientras que Kotlin ofrece una alternativa similar con `use()`.  
- **Impacto en la programaci√≥n funcional**:  
    - Java impone restricciones en lambdas que pueden dificultar su uso con excepciones chequeadas.  
    - Kotlin, al eliminar estas restricciones, ofrece una mejor integraci√≥n con la programaci√≥n funcional.  
- **Excepciones personalizadas**:  
    - Ambos lenguajes permiten la creaci√≥n de excepciones personalizadas, pero en Java deben clasificarse entre chequeadas y no chequeadas.  

### üí° Reflexi√≥n final  

Java y Kotlin abordan el manejo de excepciones desde enfoques distintos:  
- **Java** favorece un control estricto, asegurando que quien desarrolla maneje expl√≠citamente las excepciones en tiempo de compilaci√≥n. Este enfoque es √∫til en sistemas cr√≠ticos y aplicaciones empresariales de gran escala.  
- **Kotlin**, al eliminar las excepciones chequeadas, **prioriza la flexibilidad** y una sintaxis m√°s limpia, lo que se traduce en una experiencia de desarrollo m√°s fluida, especialmente en entornos funcionales y modernos.  

:::tip ¬øCu√°l es mejor?

Depender√° del contexto:  
- Si se busca **mayor seguridad en tiempo de compilaci√≥n y control del flujo de errores**, Java es una opci√≥n m√°s adecuada.  
- Si se prefiere **un c√≥digo m√°s expresivo y menos verboso**, Kotlin es una mejor alternativa.  

:::

Ambos lenguajes ofrecen herramientas potentes para manejar errores de manera efectiva, permitiendo a quien desarrolla elegir el enfoque m√°s adecuado seg√∫n los requisitos del proyecto.

Melo, H., Coelho, R., & Treude, C. (2019). Unveiling Exception Handling Guidelines Adopted by Java Developers (No. arXiv:1901.08718). arXiv. https://doi.org/10.48550/arXiv.1901.08718

## üìñ Referencias

### üî• Recomendadas

üìö "Exceptions". (2018). Joshua Bloch, en Effective Java, (Third edition, pp. 293‚Äì310.) Addison-Wesley.

### üîπ Adicionales

üìÑ Melo, H., Coelho, R., & Treude, C. (2019). Unveiling Exception Handling Guidelines Adopted by Java Developers (No. arXiv:1901.08718). arXiv. https://doi.org/10.48550/arXiv.1901.08718
