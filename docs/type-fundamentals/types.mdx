---
title: Tipos de funciones
---
import ReadingTime from '../../src/components/ReadingTime';

<ReadingTime />

A lo largo de este curso, serÃ¡ importante poder **referirnos a las funciones por su tipo** y contar con una **notaciÃ³n estÃ¡ndar** que nos permita expresar de forma precisa quÃ© datos reciben y quÃ© valores devuelven. Esto no solo facilita la lectura y comprensiÃ³n de ejemplos, sino que tambiÃ©n nos permite **formalizar ideas** y **comparar distintas funciones** de manera clara y consistente.

En esta lecciÃ³n veremos cÃ³mo expresar el **tipo de una funciÃ³n**, incluyendo funciones normales, funciones miembro y funciones de extensiÃ³n. AdemÃ¡s, entenderemos por quÃ© en Kotlin â€”y en muchos lenguajes modernosâ€” las funciones son **ciudadanas de primera clase**, lo que nos permite tratarlas como cualquier otro valor dentro del lenguaje. Esta capacidad serÃ¡ fundamental para explorar temas como funciones de orden superior, composiciÃ³n y abstracciÃ³n funcional mÃ¡s adelante en el curso.

## ğŸ“ NotaciÃ³n para Funciones

:::warning Nota pedagÃ³gica

La notaciÃ³n que usamos para describir tipos de funciones, como `(A, B) -> C` o `W.(X, Y) -> Z`, **no pretende ser una notaciÃ³n formal ni universal**. Es una convenciÃ³n adoptada para este curso por su **claridad visual y compatibilidad con Kotlin**, y nos servirÃ¡ para **razonar con precisiÃ³n** sobre el comportamiento de las funciones.  
 
MÃ¡s adelante, veremos que distintos lenguajes pueden expresar tipos funcionales de formas distintas, pero el concepto que subyace es el mismo: describir **cÃ³mo se transforman datos a travÃ©s de funciones**.

:::

En el contexto de este curso, necesitaremos **referirnos frecuentemente a funciones por su tipo**, ya que eso nos permite razonar con precisiÃ³n sobre su comportamiento, combinarlas y documentarlas de forma mÃ¡s clara y estandarizada.

El **tipo de una funciÃ³n** se define en funciÃ³n de los tipos de sus parÃ¡metros y su tipo de retorno. En Kotlin, podemos expresar esto asÃ­:

```kotlin
f: (A, B) -> C
```

AquÃ­, `A` y `B` representan los tipos de los parÃ¡metros que la funciÃ³n acepta, y `C` es el tipo del valor que devuelve como resultado. Esta notaciÃ³n es especialmente Ãºtil para analizar cÃ³mo las funciones transforman datos.

Cuando se trata de una **funciÃ³n miembro** o una **funciÃ³n de extensiÃ³n**, tambiÃ©n incluimos el tipo del receptor â€”es decir, el objeto sobre el que opera la funciÃ³nâ€”:

```kotlin
f: W.(X, Y) -> Z
```

En este caso, `W` es el tipo del objeto que "posee" la funciÃ³n; `X` y `Y` son los parÃ¡metros, y `Z` es el tipo de retorno.

<details>
  <summary>ğŸ“˜ ComparaciÃ³n con otros lenguajes</summary>

  #### TypeScript

  En TypeScript, una funciÃ³n `(A, B) -> C` se expresa como:

  ```ts
  const f: (a: A, b: B) => C
  ```

  Y una funciÃ³n con receptor (por ejemplo, un mÃ©todo dentro de una clase `W`) se ve como:

  ```ts
  class W {
    f(x: X, y: Y): Z { ... }
  }
  ```

  #### Haskell

  En Haskell, el tipo `(A, B) -> C` se expresa utilizando currying:

  ```haskell
  f :: A -> B -> C
  ```

  Y funciones que operan sobre estructuras (como `W`) se suelen representar como:

  ```haskell
  f :: W -> X -> Y -> Z
  ```

  donde `W` serÃ­a un argumento explÃ­cito en lugar de receptor implÃ­cito.
</details>

Tu secciÃ³n estÃ¡ clara y bien estructurada, pero aquÃ­ van algunas sugerencias para mejorarla ligeramente:

## ğŸ«‚ Ciudadanos de Primera Clase

En programaciÃ³n, una entidad se considera un **"ciudadano de primera clase"** si puede ser manipulada como cualquier otro valor del lenguaje. EspecÃ­ficamente, debe poder:

- Crearse dinÃ¡micamente durante la ejecuciÃ³n del programa.
- Asignarse a variables.
- Pasarse como argumento a otras funciones.
- Retornarse desde funciones.
- Almacenarse en estructuras de datos como listas o mapas.

En Kotlin, **las funciones son ciudadanos de primera clase**, lo que significa que puedes usarlas como valores: asignarlas a variables, almacenarlas, combinarlas, o pasarlas entre funciones. Esto habilita un estilo de programaciÃ³n mÃ¡s expresivo, reutilizable y modular.

### ğŸ§ª Ejemplo

```kotlin
fun add(a: Int, b: Int): Int = a + b

val add2: (Int, Int) -> Int = ::add
```

AquÃ­, `add2` es una referencia a la funciÃ³n `add`, lo que demuestra cÃ³mo una funciÃ³n puede almacenarse en una variable del tipo `(Int, Int) -> Int`.

:::info Operador de Referencia de FunciÃ³n

El operador `::` en Kotlin se llama **operador de referencia de funciÃ³n** y se utiliza para obtener una referencia a una funciÃ³n existente. En el ejemplo, `::add` toma la funciÃ³n `add` y la convierte en un valor que puede ser asignado, pasado o retornado.

:::

Esta propiedad tambiÃ©n estÃ¡ presente en otros lenguajes modernos como Python, TypeScript, Haskell, Scala y Ruby, donde tratar funciones como valores permite construir abstracciones poderosas, como funciones de orden superior o APIs declarativas.

## ğŸ¯ Conclusiones

En esta lecciÃ³n sentamos una base clave para el resto del curso: aprendimos a expresar funciones mediante una notaciÃ³n precisa y a reconocerlas como **valores de primera clase**. Esta perspectiva serÃ¡ esencial para los enfoques funcionales y declarativos que exploraremos mÃ¡s adelante.

Al definir funciones reutilizables, componer comportamientos o construir DSLs, pensar en funciones como valores nos permitirÃ¡ diseÃ±ar bibliotecas mÃ¡s expresivas, robustas y elegantes.

### ğŸ”‘ Puntos clave

- Los tipos de funciones describen quÃ© datos reciben y quÃ© valores devuelven, usando notaciÃ³n como `(A, B) -> C` o `W.(X, Y) -> Z`.
- Esta notaciÃ³n serÃ¡ central para razonar, abstraer y comunicar ideas a lo largo del curso.
- Las funciones en Kotlin son **ciudadanas de primera clase**: pueden asignarse a variables, pasarse como argumentos y devolverse como resultados.

### ğŸ§° Â¿QuÃ© nos llevamos?

Tener una notaciÃ³n clara para describir funciones â€”y entender que pueden manipularse como cualquier otro valorâ€” nos brinda una herramienta poderosa para construir abstracciones. Esta capacidad serÃ¡ fundamental para abordar conceptos como funciones de orden superior, composiciÃ³n, validaciones declarativas y diseÃ±o de APIs expresivas.
