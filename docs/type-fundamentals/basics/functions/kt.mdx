---
title: "Declaraci√≥n de funciones"
sidebar_label: "Funciones"
---

import ReadingTime from '@site/src/components/reading-time/ReadingTime';
import Solution from '@site/src/components/exercise/Solution';
import BoxedTabs from '@site/src/components/cajitas/BoxedTabs';
import TabItem from '@theme/TabItem';

import Box from '@site/src/components/cajitas/Box';

import TableFigure from '@site/src/components/Figure/TableFigure';
import { FigureCounterProvider } from '@site/src/components/Figure/FigureCounter';
import { TableCounterProvider } from '@site/src/components/Figure/TableCounter';

import RepoLinks from '@site/src/components/git/RepoLinks';
import GitHubRepo from '@site/src/components/git/GitHubRepo';
import GitLabRepo from '@site/src/components/git/GitLabRepo';

import LangLinks from '@site/src/components/LangLinks/LangLinks';
import PythonLink from '@site/src/components/LangLinks/PythonLink';

import ReferenceList from '@site/src/components/references/ReferenceList';
import WebPage from '@site/src/components/references/WebPage';

import OfficialDocumentation from '@site/src/components/Tooltip/OfficialDocumentation';

<ReadingTime multiplier={2}/>
<RepoLinks children={[
  <GitLabRepo user="r8vnhill" repo="intro-kt"/>,
  <GitHubRepo user="r8vnhill" repo="intro-kt"/>,
]}/>

<FigureCounterProvider>
<TableCounterProvider>

<section title="Introducci√≥n">
  Las funciones son una herramienta fundamental para construir software reutilizable, legible y organizado. Kotlin facilita su declaraci√≥n con una sintaxis concisa y expresiva, que incluye caracter√≠sticas como par√°metros con valores por defecto, funciones de una sola expresi√≥n e inferencia de tipos.

  En esta lecci√≥n aprender√°s a declarar funciones en Kotlin, entender c√≥mo funciona `vararg` para aceptar m√∫ltiples argumentos y cu√°ndo conviene especificar tipos de retorno. Tambi√©n explorar√°s funciones est√°ndar como `map` y `fold`, y conocer√°s las diferencias entre colecciones como `Array` y `List`.

  No es necesario dominar todos los detalles de inmediato: a medida que avancemos en el curso, retomaremos y profundizaremos en los elementos m√°s relevantes.
</section>
<section title="Funciones en Kotlin">
  ## üß© Funciones en Kotlin

  Una **funci√≥n** en Kotlin es un bloque de c√≥digo reutilizable que realiza una tarea espec√≠fica. La sintaxis b√°sica para declarar una funci√≥n es la siguiente:

  ```kotlin title="Estructura general"
  fun functionName(param1: Type1, param2: Type2 = defaultValue, ...): ReturnType {
      // Cuerpo de la funci√≥n
      return result
  }
  ```

  :::explanation Explicaci√≥n de la sintaxis

  - **`fun`**: Palabra clave para declarar una funci√≥n.
  - **`functionName`**: Nombre descriptivo que identifica la funci√≥n.
  - **Par√°metros (`param1`, `param2`)**: Lista de argumentos con sus tipos.
    - Una funci√≥n puede no tener par√°metros.
    - Es posible definir valores por defecto, haciendo que el par√°metro sea opcional.
  - **`ReturnType`**: Tipo del valor que retorna la funci√≥n.
    - Si la funci√≥n no devuelve un valor significativo, se usa `Unit`, que puede omitirse por ser impl√≠cito.
  - **Cuerpo de la funci√≥n**: Conjunto de instrucciones que se ejecutan al llamarla.

  :::

<section title="Ejemplo: Sumar dos n√∫meros">

### ‚ûï Ejemplo: Sumar dos n√∫meros

Supongamos que queremos crear una funci√≥n que sume dos n√∫meros enteros. La declaraci√≥n ser√≠a:

```kotlin showLineNumbers title="Versi√≥n con cuerpo de bloque (functions/src/main/kotlin/cl/ravenhill/math/add.kt)"
fun add(a: Int, b: Int): Int {
    return a + b
}
```

Si la funci√≥n contiene solo una expresi√≥n, puedes escribirla de forma m√°s concisa mediante **asignaci√≥n directa**:

```kotlin showLineNumbers title="Versi√≥n con asignaci√≥n directa y tipo expl√≠cito (functions/src/main/kotlin/cl/ravenhill/math/add.kt)"
fun add(a: Int, b: Int): Int = a + b
```

Kotlin incluso permite **inferir el tipo de retorno** autom√°ticamente:

```kotlin showLineNumbers title="Versi√≥n con inferencia de tipo (functions/src/main/kotlin/cl/ravenhill/math/add.kt)"
fun add(a: Int, b: Int) = a + b
```

Este estilo hace que el c√≥digo sea m√°s breve, pero √∫salo con moderaci√≥n: puede dificultar la lectura si el tipo de retorno no es evidente y volver el c√≥digo m√°s fr√°gil frente a cambios accidentales en el tipo devuelto.

:::more Si vienes de Scala...

En Kotlin, **la palabra clave `return` es obligatoria** cuando usas el bloque cl√°sico `{ ... }`.  
Esto contrasta con Scala, donde **la √∫ltima expresi√≥n de una funci√≥n se devuelve autom√°ticamente** sin necesidad de `return`.

En Kotlin, ese comportamiento impl√≠cito **solo se aplica** cuando utilizas la sintaxis de una sola expresi√≥n (`= ...`).    

:::

<section title="Inferencia de tipos">

::::info Inferencia de tipos

Kotlin es un lenguaje con **inferencia de tipos**, lo que significa que el compilador puede deducir el tipo de una variable o expresi√≥n a partir del contexto.  
En el ejemplo anterior, como la funci√≥n consiste en una sola expresi√≥n, **el tipo de retorno se infiere autom√°ticamente**.

:::warning No abuses de la inferencia

Aunque la inferencia puede hacer el c√≥digo m√°s limpio y conciso, **no siempre conviene omitir los tipos**.  
En funciones **p√∫blicas**, con l√≥gica **m√°s compleja** o expuestas como parte de una **API**, declarar el tipo expl√≠citamente mejora la **claridad**, act√∫a como **documentaci√≥n impl√≠cita** y facilita la **evoluci√≥n del c√≥digo**.

:::

::::

</section>

<section title="Estilo de nombres">

:::::tip Estilo de nombres

En Kotlin, **las funciones y variables deben nombrarse usando la convenci√≥n `camelCase`**. Esto significa:

- El nombre comienza con **min√∫scula**.
- Cada palabra siguiente se escribe **sin espacios**, comenzando con **may√∫scula**.

‚úÖ Ejemplos correctos:
- `calculateTotal`
- `printMessage`
- `main`

Usar un estilo de nombres consistente **mejora la legibilidad** y asegura que tu c√≥digo se mantenga alineado con las pr√°cticas idiom√°ticas de Kotlin.

::::danger Estilos incorrectos

Evita estilos heredados de otros lenguajes o no v√°lidos en Kotlin:

- `CalculateTotal` ‚Üí ‚ùå **PascalCase**, reservado para **clases** y **tipos**.
- `calculate_total` ‚Üí ‚ùå **snake_case**, t√≠pico en Python, **no se utiliza** en Kotlin.
- `calculate-total` ‚Üí ‚ùå **kebab-case**, **inv√°lido** como identificador.
- `CALCULATE_TOTAL` ‚Üí ‚ùå Reservado para **constantes** y **valores inmutables en tiempo de compilaci√≥n**.

::::

:::::

</section>

</section>

<section title="Funciones vari√°dicas">

### üî¢ Funciones vari√°dicas (`vararg`)

En Kotlin puedes definir funciones que aceptan una **cantidad variable de argumentos** usando la palabra clave `vararg`.  
Esto permite invocar la funci√≥n con **cero, uno o m√°s valores** del mismo tipo, de manera similar a `*args` en Python o `...args` en JavaScript.

```kotlin showLineNumbers title="Ejemplo: sumar m√∫ltiples n√∫meros (functions/src/main/kotlin/cl/ravenhill/math/sum.kt)"
fun sumAll(vararg nums: Int): Int =
    nums.sum()
```

:::more `sum()`

La funci√≥n [`sum()`](https://kotlinlang.org/api/core/kotlin-stdlib/kotlin.collections/sum.html) es una extensi√≥n que suma todos los elementos de una colecci√≥n o arreglo.

En el caso de `IntArray`, su firma es:

```kotlin
fun IntArray.sum(): Int
```

Esto equivale a `nums[0] + nums[1] + ... + nums[n-1]`.

Tambi√©n existen variantes para otros tipos de colecciones num√©ricas:

```kotlin
fun Array<out Int>.sum(): Int
fun Iterable<Double>.sum(): Double
// ...
```

- `Array<out T>` es covariante: puedes pasar cualquier subtipo de `T`, pero no modificar la colecci√≥n.[^1]
- Las versiones para `List`, `Set`, y otros `Iterable<T>` funcionan del mismo modo.

:::

```kotlin showLineNumbers title="Invocaci√≥n de la funci√≥n (functions/src/main/kotlin/cl/ravenhill/math/sum.kt)"
sumAll(1, 2, 3, 4)  // devuelve 10
sumAll()            // devuelve 0
```

Si tienes un arreglo existente, puedes **desempaquetarlo** usando el prefijo `*`:

```kotlin title="Desempaquetando un arreglo (functions/src/main/kotlin/cl/ravenhill/math/sum.kt)"
val extras = intArrayOf(5, 6)
sumAll(1, 2, *extras) // devuelve 14
```

::::tip Hack: Uno o m√°s argumentos

Si necesitas que una funci√≥n reciba **al menos un argumento obligatorio**, puedes declararlo como un par√°metro normal seguido de un `vararg`.

Una forma √∫til de entender esto es compararlo con expresiones regulares:

- `*` representa ‚Äú**cero o m√°s** repeticiones‚Äù  
- `+` representa ‚Äú**una o m√°s** repeticiones‚Äù

En este contexto:

- El par√°metro obligatorio representa el `+`  
- El `vararg` representa el `*`

Juntos, expresan la idea de ‚Äú**uno o m√°s argumentos**‚Äù.

```kotlin showLineNumbers title="Al menos un argumento requerido (functions/src/main/kotlin/cl/ravenhill/math/sum.kt)"
fun sumTo(first: Int, vararg rest: Int): Int =
    rest.fold(first) { acc, i -> acc + i }
```

:::more `fold()`

La funci√≥n [`fold()`](https://kotlinlang.org/api/core/kotlin-stdlib/kotlin.collections/fold.html) es una extensi√≥n que aplica una operaci√≥n acumulativa sobre los elementos de una colecci√≥n, comenzando desde un valor inicial.

En este caso:

```kotlin
fun IntArray.fold(initial: Int, operation: (acc: Int, Int) -> Int): Int
```

Esto se traduce a: `first + rest[0] + rest[1] + ...`.

`fold()` tambi√©n se puede usar con:

- Arreglos primitivos (`DoubleArray`, `FloatArray`, etc.)
- Arreglos gen√©ricos (`Array<T>`)
- Colecciones (`List<T>`, `Set<T>`, etc.)

Versiones generalizadas:

```kotlin
fun <T, R> Array<out T>.fold(initial: R, operation: (acc: R, T) -> R): R
fun <T, R> Iterable<T>.fold(initial: R, operation: (acc: R, T) -> R): R
```

Aqu√≠ `R` es el tipo del acumulador, `T` el tipo de los elementos, y `out` indica covarianza: puedes pasar subtipos de `T`.

:::

```kotlin showLineNumbers title="Invocaci√≥n de la funci√≥n (functions/src/main/kotlin/cl/ravenhill/math/sum.kt)"
sumTo(1)                                        // devuelve 1
sumTo(1, 2, 3, 4)                               // devuelve 10
sumTo(first = 1, rest = intArrayOf(2, 3, 4))    // devuelve 10
```

Este patr√≥n tambi√©n sirve para funciones con dos o m√°s par√°metros obligatorios, seguidos por una cantidad variable de argumentos opcionales.

::::

:::info `vararg` vs. `Array`

En Kotlin, `vararg` es una forma conveniente de permitir que una funci√≥n reciba **una cantidad variable de argumentos**.  
Internamente, el compilador convierte esos argumentos en un arreglo (`Array<T>`, `IntArray`, etc.).

**Esto significa que:**

- Usar `vararg` es **az√∫car sint√°ctico**[^2] sobre una funci√≥n que acepta un arreglo.
- Puedes seguir llamando a la funci√≥n con un arreglo existente usando el operador `*` para desempaquetarlo.

```kotlin showLineNumbers title="Usando vararg vs. pasando un arreglo"
fun sumAll(vararg nums: Int): Int = nums.sum()

val valores = intArrayOf(1, 2, 3)
sumAll(*valores)  // ‚úÖ correcto: desempaquetado con *
```

Kotlin optimiza los tipos primitivos (`Int`, `Double`, etc.) usando `IntArray`, `DoubleArray`, etc., en lugar de `Array<Int>` o `Array<Double>`.  
Esto mejora el rendimiento y evita el **[boxing](https://en.wikipedia.org/wiki/Boxing_(computer_programming)) innecesario**.

:::

::::more `Array<T>` vs. `List<T>`

Tanto `Array<T>` como `List<T>` representan **colecciones de tama√±o fijo** e **inmutables en cuanto a estructura** (es decir, no puedes agregar ni quitar elementos), pero se usan en contextos distintos:

- `Array<T>` es una **estructura de bajo nivel**, m√°s cercana al funcionamiento de los arreglos en lenguajes como Java.
- `List<T>` es parte de la API de colecciones de Kotlin, m√°s expresiva y flexible para la programaci√≥n funcional.

<TableFigure caption={<>Diferencias entre <code>Array&lt;T&gt;</code> y <code>List&lt;T&gt;</code></>}>
| Caracter√≠stica         | `Array<T>`                          | `List<T>`                          |
|------------------------|-------------------------------------|------------------------------------|
| Mutable                | S√≠ (`array[i] = ...`)               | No (`List<T>` es inmutable)        |
| Tama√±o fijo            | S√≠                                  | S√≠ (en `List`, no en `MutableList`)|
| Posiciones accesibles  | Por √≠ndice (`array[i]`)             | Por √≠ndice (`list[i]`)             |
| M√©todos funcionales    | Limitados                           | Amplia API funcional               |
| Uso com√∫n              | Eficiencia, interoperabilidad con Java | Estilo idiom√°tico, programaci√≥n funcional |
| Conversi√≥n             | `array.toList()`                    | `list.toTypedArray()`              |
</TableFigure>

:::tip En resumen

- Usa `List<T>` para la mayor√≠a de los casos, sobre todo si buscas **inmutabilidad l√≥gica** y una API m√°s rica y expresiva para manipulaci√≥n de datos.
- Usa `Array<T>` si necesitas interoperar con c√≥digo Java, o si el rendimiento al acceder/modificar por √≠ndice es cr√≠tico.

:::

::::

</section>

</section>

{/* #region Ejercicio pr√°ctico: Duplicar niveles de poder */}
<section title="Ejercicio pr√°ctico: Duplicar niveles de poder">

## Ejercicio

::::exercise Ejercicio de cierre: Duplicar niveles de poder

Vamos a practicar la declaraci√≥n de funciones en Kotlin aplicando una transformaci√≥n sobre una lista.  
Sup√≥n que tienes una lista de niveles de poder (`Int`) y quieres duplicar cada uno de ellos usando `map`.

Como recordatorio, `map` aplica una funci√≥n a cada elemento de una colecci√≥n y devuelve una nueva colecci√≥n con los resultados:

```kotlin
fun <T, R> Iterable<T>.map(transform: (T) -> R): List<R>
fun IntArray.map(transform: (Int) -> R): List<R>
```

Tu tarea es definir una funci√≥n llamada `doublePowers` que reciba una lista de enteros (`List<Int>`) o bien una cantidad variable de argumentos (`vararg`) y devuelva una nueva lista con cada valor duplicado.

:::more Ejemplos de uso

<BoxedTabs groupId="exercise">
  <TabItem value="Lista" label="Input como lista">
    ```kotlin showLineNumbers title="Ejemplo de uso como lista"
    doublePowers(listOf(5, 10, 15)) 
    // devuelve: [10, 20, 30]
    ```
  </TabItem>
  <TabItem value="Vararg" label="Input como vararg">
    ```kotlin showLineNumbers title="Ejemplo de uso como vararg"
    doublePowers(5, 10, 15)
    // devuelve: [10, 20, 30]
    doublePowers(*intArrayOf(5, 10, 15))
    // devuelve: [10, 20, 30]
    ```
  </TabItem>
</BoxedTabs>

:::

:::solution

<BoxedTabs groupId="exercise">
  <TabItem value="Lista" label="Input como lista">
    ```kotlin showLineNumbers title="Soluci√≥n: Input como lista"
    fun doublePowers(powers: List<Int>): List<Int> =
        powers.map { it * 2 }
    ```
  </TabItem>
  <TabItem value="Vararg" label="Input como vararg">
    ```kotlin showLineNumbers title="Soluci√≥n: Input como vararg"
    fun doublePowers(vararg powers: Int): List<Int> =
        powers.map { it * 2 }
    ```
  </TabItem>
</BoxedTabs>

Ambas versiones son equivalentes en funcionalidad, pero difieren en c√≥mo se pasan los argumentos al invocar la funci√≥n.

:::

::::

</section>
{/* #endregion */}

{/* #region Conclusiones */}
<section title="Conclusiones">
## üéØ Conclusiones

En esta lecci√≥n conocimos la sintaxis b√°sica para declarar funciones en Kotlin, un componente esencial para estructurar c√≥digo **reutilizable**, **expresivo** y **mantenible**. Tambi√©n exploramos algunas variantes idiom√°ticas como la **inferencia de tipos**, las **funciones vari√°dicas** y la diferencia entre colecciones como `Array` y `List`.

### üîë Puntos clave

- Las funciones se declaran con la palabra clave `fun` y pueden tener **par√°metros con valores por defecto**.
- El tipo de retorno puede **inferirse autom√°ticamente** si la funci√≥n se reduce a una sola expresi√≥n.
- `vararg` permite definir funciones que aceptan una **cantidad variable de argumentos**.
- Es posible requerir al menos un argumento junto a `vararg`, combin√°ndolos en la firma.
- `Array<T>` y `List<T>` parecen similares, pero tienen **diferencias clave en mutabilidad y uso**.
- Kotlin favorece un estilo conciso, pero tambi√©n **expl√≠cito y claro** cuando la funci√≥n es p√∫blica o compleja.

### üß∞ ¬øQu√© nos llevamos?

Esta lecci√≥n es una **primera aproximaci√≥n** al sistema de funciones de Kotlin.  
No necesitas memorizar todos los detalles ahora: puedes volver a este material como **referencia r√°pida**.

A lo largo del curso, retomaremos estos conceptos y profundizaremos en los aspectos m√°s relevantes seg√∫n el contexto de cada unidad.

</section>
{/* #endregion */}

</TableCounterProvider>
</FigureCounterProvider>

<LangLinks
  links={[
    <PythonLink href="/docs/type-fundamentals/basics/functions/py" />,
  ]}
/>

<section title="Referencias">
## üìñ ¬øCon ganas de m√°s?

<ReferenceList
  title="üî• Referencias recomendadas"
  items={[
    <WebPage
      title="Funciones | Kotlin"
      url="https://kotlinlang.org/docs/functions.html"
      location={<OfficialDocumentation>Kotlin docs</OfficialDocumentation>}
    >
      Esta documentaci√≥n ofrece una gu√≠a exhaustiva sobre la declaraci√≥n y uso de funciones en Kotlin. Aborda desde conceptos b√°sicos como la sintaxis con <code>fun</code>, el uso de par√°metros con tipo expl√≠cito y valores por defecto, hasta temas m√°s avanzados como funciones vari√°dicas (<code>vararg</code>), argumentos nombrados, funciones de una sola expresi√≥n, inferencia de tipos, funciones infijas (<code>infix</code>), gen√©ricas y recursivas de cola (<code>tailrec</code>). Tambi√©n detalla c√≥mo declarar funciones a nivel superior, funciones locales, de miembro y de extensi√≥n, promoviendo un estilo conciso, idiom√°tico y expresivo. Es una fuente esencial para comprender el modelo funcional y flexible de funciones en Kotlin.
    </WebPage>,
  ]}
/>

</section>

[^1]: El principio get-put establece que un tipo covariante puede ser usado como un tipo de retorno (`out`) pero no como un tipo de entrada (`in`). En este caso, `out` indica que el arreglo solo se usa para obtener valores, no para insertarlos.
[^2]: Se llama **az√∫car sint√°ctica** (*syntactic sugar*) a una forma m√°s conveniente o legible de escribir algo que, en realidad, se traduce a una forma m√°s b√°sica del  lenguaje.
