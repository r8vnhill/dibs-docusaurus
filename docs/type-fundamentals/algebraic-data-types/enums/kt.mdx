---
title: Tipos suma como enumeraciones
sidebar_label: Enumeraciones
---
import { ProCons, Pros, Cons } from '@site/src/components/cajitas/ProCons'
import Explanation from '@site/src/components/admonitions/Explanation'
import ReadingTime from '@site/src/components/reading-time/ReadingTime'

<ReadingTime />

## 游꿢 Motivaci칩n

Supongamos que est치s dise침ando una biblioteca para representar el **estado de una conexi칩n de red**. Algunos posibles estados son `Connected`, `Disconnected` o `InProgress`. 쮺칩mo podr칤as modelarlos de forma **segura y expresiva**?

Una soluci칩n fr치gil ser칤a usar una `String`:

```kotlin showLineNumbers
val state = "Connected"
```

Pero esto permite errores sutiles, como:

```kotlin showLineNumbers
val state = "Connnected" // error silencioso: compila, pero est치 mal escrito
```

## Enumeraciones

Las **enumeraciones** son una forma de representar un **tipo suma** en Kotlin. Permiten definir un conjunto cerrado de valores posibles, lo que mejora la seguridad y la legibilidad del c칩digo.
Adem치s, el compilador puede verificar que solo se usen valores v치lidos, evitando errores comunes como cadenas mal escritas o valores no v치lidos.

Conceptualmente, si un tipo suma $S$ tiene $N$ alternativas $S = A_1 + A_2 + ... + A_N$, podemos representarlo como una enumeraci칩n `enum class` en Kotlin:

```kotlin showLineNumbers title="Tipo suma como enumeraci칩n"
enum class TipoSuma {
    Alternativa1,
    Alternativa2,
    // ...
    AlternativaN
}
```

<Explanation>
    Hemos definido un **tipo suma** usando `enum class`, que nos permite modelar un conjunto de **alternativas fijas y conocidas**.  
    Cada valor dentro del `enum` representa **una opci칩n v치lida**, y el compilador se asegura de que **solo una alternativa est칠 presente a la vez**.  
    Este enfoque mejora la seguridad del modelo y evita errores como comparar cadenas mal escritas o usar valores no v치lidos.
</Explanation>

Cada instancia del `enum` es exactamente **una** de las alternativas posibles. Este enfoque es ideal cuando:

- Las alternativas son fijas y conocidas de antemano.
- No necesitas asociar datos adicionales a cada caso.

:::danger TODO:

Aqu칤 podr칤a ir un `details` con la notaci칩n `|` (equivalente a `+`) para representar el tipo suma que se usa en varios lenguajes de programaci칩n y tambi칠n en la teor칤a de tipos. Elegimos `+` para representar el tipo suma m치s arriba para seguir la notaci칩n de suma.

:::

## 游닍 Uso habitual en bibliotecas

Los `enum class` son especialmente 칰tiles para representar:

- **Estados finitos** (como el estado de una conexi칩n, sesi칩n o flujo de trabajo).
- **Modos de operaci칩n** (por ejemplo, modo oscuro/claro, lectura/escritura).
- **Resultados controlados** (como `OK`, `ERROR`, `TIMEOUT`, etc.).

Veamos un ejemplo t칤pico:

```kotlin showLineNumbers title="Ejemplo de uso de enum class"
enum class LogLevel {
    INFO,
    WARNING,
    ERROR
}

fun log(message: String, level: LogLevel) {
    if (level == LogLevel.ERROR) {
        System.err.println("$level: $message")
    } else {
        println("$level: $message")
    }
}

fun main() {
    log("Todo est치 bien", LogLevel.INFO)      // INFO: Todo est치 bien
    log("Algo sali칩 mal", LogLevel.ERROR)     // ERROR: Algo sali칩 mal
}
```

<Explanation>
    Hemos definido un conjunto cerrado de niveles de log (`LogLevel`) usando `enum class`.  
    Luego, lo usamos como par치metro en una funci칩n `log` que act칰a de forma distinta seg칰n el valor recibido.  
    Esto garantiza que **solo valores v치lidos y conocidos** pueden ser usados, evitando errores como cadenas mal escritas y habilitando el chequeo en tiempo de compilaci칩n.
</Explanation>

## `when` exhaustivo

:::danger TODO:

- [ ] Notaci칩n `|` para representar el tipo suma.
- [ ] Notar que usamos `==` para "preguntar por tipo" y no `is`.
- [ ] Explicar el `when` exhaustivo y su relaci칩n con los `enum class`.
- [ ] Ejemplo de uso del `when` exhaustivo con `enum class`.
- [ ] Conclusiones
- [ ] Introducci칩n

:::
