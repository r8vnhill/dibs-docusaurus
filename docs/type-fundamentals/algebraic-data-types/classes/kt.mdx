---
title: Tipos producto como clases
sidebar_label: Clases
---
import ReadingTime from '@site/src/components/ReadingTime'
import BoxedTabs from '@site/src/components/cajitas/BoxedTabs'
import TabItem from '@theme/TabItem'
import Glossary from '@site/src/components/admonitions/Glossary'

<ReadingTime multiplier={1.8}/>

En lecciones anteriores vimos que los **tipos producto** nos permiten agrupar m√∫ltiples valores en una sola entidad. Kotlin ofrece estructuras como `Pair` y `Triple` para resolver esto r√°pidamente, pero estas opciones gen√©ricas **no expresan claramente el prop√≥sito de cada campo**.

En esta lecci√≥n exploraremos c√≥mo las **clases comunes** en Kotlin permiten definir tipos producto m√°s expresivos y seguros. Ver√°s c√≥mo declarar clases con propiedades bien nombradas, c√≥mo funcionan los **constructores primarios y secundarios**, y c√≥mo encapsular l√≥gica relevante dentro del mismo tipo.

Este conocimiento es clave al dise√±ar bibliotecas reutilizables: nos permite representar estructuras de datos que no solo agrupan informaci√≥n, sino que **comunican claramente su intenci√≥n**. La pr√≥xima lecci√≥n profundizar√° en las `data class`, una forma m√°s idiom√°tica y concisa de construir estos tipos.

<Glossary>
    - **Tipo producto**: Tipo que agrupa varios valores (como campos) en una sola entidad.
    - **Clase**: Estructura que encapsula datos (propiedades) y operaciones (m√©todos) relacionadas.
    - **Constructor primario**: Forma principal de inicializar una clase en Kotlin, declarada junto al nombre de la clase.
    - **Constructor secundario**: Constructor adicional definido dentro del cuerpo de la clase.
</Glossary>

## üèóÔ∏è Clases comunes como tipos producto

Aunque estructuras como `Pair` y `Triple` permiten agrupar valores r√°pidamente, **las clases comunes de Kotlin** ofrecen una forma mucho m√°s expresiva y mantenible de definir **tipos producto personalizados**.

Un tipo producto es una estructura que **contiene un valor por cada uno de sus campos**, y una clase con varias propiedades cumple exactamente con esa definici√≥n. Esto permite modelar entidades del dominio con **nombres claros y significado sem√°ntico**, en lugar de depender de posiciones gen√©ricas.

Por ejemplo, para representar la posici√≥n de un personaje en un juego:

```kotlin showLineNumbers title="Posici√≥n como tipo producto"
class Position(val x: Int, val y: Int)
```

Este tipo modela el producto cartesiano $ \text{Int} \times \text{Int} $, agrupando ambos valores en una sola unidad coherente:

```kotlin showLineNumbers title="Uso de la clase Position"
val pos = Position(10, 5)
println(pos.x)  // 10
println(pos.y)  // 5
```

Al definir una clase como `Position`, **le damos nombre a cada campo y al conjunto en s√≠**, lo que hace que el c√≥digo sea m√°s f√°cil de leer, extender y mantener, especialmente en bibliotecas.

::::tip Instanciaci√≥n sin `new`

En Kotlin, **no se utiliza la palabra clave `new`** para crear objetos. Basta con invocar el constructor como si fuera una funci√≥n:

```kotlin showLineNumbers title="Kotlin"
val hunter = DemonHunter("Dante", "Rebellion")
```

Esta sintaxis es m√°s limpia y coherente con la idea de que una clase tambi√©n puede comportarse como una funci√≥n.

En contraste, lenguajes como **Java**, **C#** o **C++** requieren la palabra clave `new` para instanciar clases:

```java showLineNumbers title="Java"
final var hunter = new DemonHunter("Dante", "Rebellion");
```

:::note `final var` en Java

En Java, `var` permite **inferir el tipo** de la variable, mientras que `final` impide que la referencia sea **reasignada** despu√©s de su inicializaci√≥n. Esto se asemeja al uso de `val` en Kotlin, que tambi√©n declara una **constante referencial**.

Sin embargo, esta inmutabilidad **no es profunda**: si el objeto es mutable, su contenido a√∫n puede cambiar.

:::

Este detalle puede parecer menor, pero refleja el enfoque de Kotlin hacia una sintaxis m√°s **concisa**, **expresiva** y **orientada a la funcionalidad**, donde crear objetos no requiere ruido adicional como `new`.

::::

A diferencia de `Pair`, una clase permite **nombrar expl√≠citamente cada campo** y definir **comportamiento asociado al dominio**:

```kotlin showLineNumbers title="Clase con comportamiento"
class Position(val x: Int, val y: Int) {
    val isOrigin: Boolean
        get() = x == 0 && y == 0
}
```

Esto permite encapsular no solo los datos, sino tambi√©n las operaciones relevantes, lo que **mejora la legibilidad, la expresividad y la mantenibilidad** del c√≥digo. Al modelar el dominio con clases, es m√°s f√°cil transmitir la intenci√≥n detr√°s de cada tipo y prevenir usos incorrectos.

## üß± Constructores primarios y secundarios

En Kotlin, una clase puede tener **un constructor primario** y **uno o m√°s constructores secundarios**. El constructor primario se declara directamente en el encabezado de la clase y representa la **forma idiom√°tica de inicializar las propiedades** de una clase, promoviendo una sintaxis concisa y declarativa.

### üîπ Constructor primario

El constructor primario se escribe despu√©s del nombre de la clase. Si no incluye anotaciones ni modificadores de visibilidad, **se puede omitir** la palabra clave `constructor`:

```kotlin
class Person(val name: String, var age: Int)
```

Cuando se requiere una **anotaci√≥n** (como `@Inject`) o un **modificador de visibilidad** (`private`, `protected` o `internal`), es **necesario** incluir expl√≠citamente la palabra clave `constructor`:

```kotlin
class Person @Inject internal constructor(val name: String)
```

Este patr√≥n es com√∫n al usar frameworks de **inyecci√≥n de dependencias** como [Dagger](https://dagger.dev/), [Koin](https://insert-koin.io/) o [Hilt](https://developer.android.com/training/dependency-injection/hilt-android), que requieren anotar los constructores para poder generar c√≥digo o instancias autom√°ticamente.

:::info `internal` en Kotlin

El modificador `internal` restringe el uso del constructor a **dentro del mismo m√≥dulo**. Aunque todav√≠a no hemos visto qu√© es un m√≥dulo (lo exploraremos m√°s adelante en la unidad sobre *build systems*), puedes pensarlo como una **unidad de compilaci√≥n independiente**, como una biblioteca o subproyecto.

Este modificador es especialmente √∫til al dise√±ar bibliotecas: permite que una clase sea **visible para el exterior**, pero **limita qui√©n puede crear instancias**, ayudando a mantener el control sobre el uso y evitando construcciones fuera del contexto esperado.

:::

Cuando se necesita ejecutar l√≥gica adicional al crear una instancia, Kotlin ofrece los **bloques `init`**, que se colocan dentro del cuerpo de la clase:

```kotlin showLineNumbers title="Bloque init"
class Person(val name: String, var age: Int) {
    init {
        require(age >= 0) { "Age must be non-negative" }
    }
}
```

El bloque `init` se ejecuta justo despu√©s de evaluar los argumentos del constructor. Se pueden definir **m√∫ltiples bloques `init`**, y se ejecutar√°n en **orden de aparici√≥n**, lo que permite estructurar la inicializaci√≥n en pasos claros.

:::note `require`, `check` y `error`

- `require(Boolean) { String }: Unit` valida argumentos de entrada. Lanza `IllegalArgumentException`.
- `check(Boolean) { String }: Unit` valida el estado interno del objeto. Lanza `IllegalStateException`.
- `error(String): Nothing` lanza incondicionalmente un `IllegalStateException`.

Estas funciones permiten capturar errores de forma temprana y expresiva, con mensajes claros que facilitan el diagn√≥stico.

:::
### üîπ Constructor secundario

Los **constructores secundarios** permiten definir m√∫ltiples formas de instanciar una clase. Se declaran dentro del cuerpo de la clase y deben **delegar obligatoriamente al constructor primario** mediante `this(...)`:

```kotlin showLineNumbers
class Person(val name: String) {
    var age: Int = 0

    constructor(name: String, age: Int) : this(name) {
        this.age = age
    }
}
```

Esta delegaci√≥n debe realizarse **en la cabecera del constructor**, no dentro de su cuerpo. Esto asegura que el constructor primario **siempre se ejecute primero**, evitando ambig√ºedades y errores de inicializaci√≥n.

Los constructores secundarios son √∫tiles en escenarios como:

- Interoperabilidad con Java.
- Necesidad de m√∫ltiples formas de inicializaci√≥n.
- Aplicaci√≥n de herencia con l√≥gica de construcci√≥n espec√≠fica.

:::tip Par√°metros por defecto

En Kotlin, los **par√°metros con valores por defecto** suelen eliminar la necesidad de constructores secundarios:

```kotlin showLineNumbers
class Person(val name: String, var age: Int = 0)
```

Esta forma es m√°s **idiom√°tica**, **concisa** y **mantenible**, y suele preferirse cuando no se requiere l√≥gica adicional.

:::

## üéØ Conclusiones

En esta lecci√≥n exploramos c√≥mo las **clases comunes** en Kotlin pueden representar **tipos producto**, es decir, estructuras que agrupan m√∫ltiples valores en una √∫nica unidad coherente. A diferencia de tipos gen√©ricos como `Pair` o `Triple`, las clases permiten **nombrar cada campo**, **encapsular l√≥gica relevante**, y **estructurar el dominio del problema de forma clara y extensible**.

Tambi√©n aprendimos a construir estas clases mediante **constructores primarios**, **bloques `init`**, y ‚Äîcuando es necesario‚Äî **constructores secundarios**. Adem√°s, vimos c√≥mo los **par√°metros con valores por defecto** pueden simplificar muchos casos de uso comunes.

### üîë Puntos clave

- Una clase con varias propiedades representa un **tipo producto**: un valor que contiene simult√°neamente un valor por cada campo.
- Kotlin permite instanciar objetos sin `new`, lo que mejora la **concisi√≥n y legibilidad**.
- El **constructor primario** es la forma idiom√°tica de inicializar clases; los **bloques `init`** permiten validar o ejecutar l√≥gica adicional.
- Los **constructores secundarios** permiten distintos caminos de inicializaci√≥n, pero muchas veces se pueden evitar con par√°metros por defecto.
- Las clases permiten encapsular datos y comportamiento, a diferencia de estructuras gen√©ricas como `Pair`.

### üß∞ ¬øQu√© nos llevamos?

Dominar el uso de clases como tipos producto es esencial para construir **tipos seguros, expresivos y reutilizables** en Kotlin. En el contexto del dise√±o de bibliotecas, cada tipo que definimos se convierte en parte del **contrato que ofrecemos** a quienes consumen nuestro c√≥digo.

Este enfoque no solo mejora la expresividad interna, sino que tambi√©n **define estructuras claras e intencionales**, facilitando el mantenimiento y evitando malentendidos sobre c√≥mo deben usarse los datos.

A medida que una biblioteca crece, las clases con nombres sem√°nticos y campos bien definidos **evitan ambig√ºedades**, **mejoran la legibilidad** y **facilitan la evoluci√≥n del c√≥digo**, a diferencia de tuplas gen√©ricas que tienden a volverse opacas.

Al dominar estas herramientas, no solo est√°s aprendiendo c√≥mo funciona Kotlin: est√°s aprendiendo a **modelar tu dominio de forma robusta y comprensible**, eligiendo representaciones que hacen expl√≠cito el prop√≥sito del c√≥digo. Este principio ‚Äî**que el c√≥digo comunique su intenci√≥n**‚Äî es clave en el dise√±o de bibliotecas limpias, mantenibles y √∫tiles para otrxs.

Has aprendido a construir tus propios tipos producto desde cero. En la pr√≥xima lecci√≥n, descubrir√°s c√≥mo Kotlin puede **automatizar gran parte de esta tarea** mediante `data class`, acerc√°ndote a√∫n m√°s a escribir c√≥digo **claro, conciso y expresivo**.

<div class="exclude-from-reading-time">

## üìñ Referencias

### üî• Recomendadas

- [üåê *"Classes"*](https://kotlinlang.org/docs/classes.html) de la **documentaci√≥n oficial de Kotlin**: La referencia m√°s completa y actualizada sobre c√≥mo declarar y trabajar con clases en Kotlin. Explica de forma detallada los **constructores primarios y secundarios**, los **bloques `init`**, la inicializaci√≥n de propiedades, la creaci√≥n de instancias, los modificadores de visibilidad y otros elementos clave del sistema de clases. **Relevante porque** profundiza en las reglas del lenguaje con m√∫ltiples ejemplos pr√°cticos, lo que complementa y respalda los conceptos explicados en esta lecci√≥n sobre tipos producto y construcci√≥n segura de objetos en Kotlin.

### üîπ Adicionales

- [üåê *"Pairs and triples in Kotlin (and why you shouldn't use them)"*](https://www.nutrient.io/blog/pairs-and-triples-in-kotlin-and-why-you-shouldnt-use-them/) en *Nutrient.io* por **Menil Vukovic**: Este art√≠culo argumenta que `Pair` y `Triple` son una soluci√≥n tentadora pero inadecuada para modelar datos en Kotlin. Presenta ejemplos donde su uso puede dificultar la comprensi√≥n, mantenimiento y extensibilidad del c√≥digo, especialmente cuando se usan como estructuras de retorno en funciones o para representar entidades del dominio. **Relevante porque** refuerza el valor de las clases con propiedades nombradas frente a las tuplas gen√©ricas, destacando c√≥mo estas √∫ltimas comprometen la claridad del c√≥digo, una preocupaci√≥n central al dise√±ar bibliotecas limpias y expresivas.
- [üé• *"Kotlin Classes and Constructors ‚Äì Primary vs Secondary"*](https://www.youtube.com/watch?v=Ly_onmXpDiw) (13m50s) en *YouTube* por **Will Tollefson**: Un video introductorio claro y bien estructurado que explica c√≥mo declarar clases en Kotlin, diferenciando entre constructores primarios y secundarios, y mostrando en qu√© orden se ejecutan los bloques `init` y los inicializadores de propiedades. Tambi√©n aborda buenas pr√°cticas sobre visibilidad, uso de valores por defecto y cu√°ndo (y por qu√©) **evitar constructores secundarios**. **Relevante porque** refuerza visualmente los conceptos de esta lecci√≥n, mostrando ejemplos en orden de ejecuci√≥n, y ayuda a comprender c√≥mo Kotlin promueve un estilo conciso, expresivo y seguro al modelar tipos producto.

</div>
