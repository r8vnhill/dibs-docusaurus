---
title: Uso idiom√°tico de data class
---

import ReadingTime from "@site/src/components/ReadingTime"
import Explanation from "@site/src/components/admonitions/Explanation"
import BoxedTabs from '@site/src/components/cajitas/BoxedTabs'
import TabItem from '@theme/TabItem'
import Exercise from '@site/src/components/exercise/Exercise'
import Solution from '@site/src/components/exercise/Solution'
import Hint from '@site/src/components/exercise/Hint'
import GitHubRepoLink from '@site/src/components/git/GitHubRepoLink'
import * as LanguageCards from '@site/src/components/cards/LanguageCard'

<ReadingTime multiplier={2.0} />
<GitHubRepoLink user="r8vnhill" repo="algebraic-data-types-kt" />

En Kotlin, las `data class` son una de las herramientas m√°s expresivas y √∫tiles para modelar datos. Su dise√±o favorece la inmutabilidad, la comparaci√≥n estructural y la simplicidad declarativa, lo que las convierte en una excelente opci√≥n para representar **tipos producto**: estructuras que agrupan m√∫ltiples valores con significado sem√°ntico.

En esta lecci√≥n exploraremos su uso idiom√°tico, enfoc√°ndonos en sus ventajas frente a clases tradicionales o tuplas, su comportamiento por defecto y su rol en el dise√±o de **bibliotecas reutilizables**. Veremos c√≥mo desestructurar instancias, crear copias inmutables con `copy`, utilizar constructores alternativos y mantener un dise√±o claro incluso cuando se requiere cierta mutabilidad.

M√°s que ense√±arte a usar `data class`, esta lecci√≥n te dar√° criterios para tomar decisiones de dise√±o informadas al modelar estructuras de datos claras, robustas y f√°ciles de mantener.

## üéÅ Desestructuraci√≥n

Una de las ventajas de las `data class` es que generan autom√°ticamente funciones `componentN()`, lo que permite **extraer sus campos de forma clara y concisa**, sin necesidad de acceder a cada propiedad manualmente.

Por ejemplo, al representar una canci√≥n de *Aerosmith*:

```kotlin showLineNumbers title="Desestructuraci√≥n de una data class"
data class Song(val title: String, val year: Int)

val (title, year) = Song("Dream On", 1973)
println("'$title' se lanz√≥ en $year")
```

Este tipo de desestructuraci√≥n resulta especialmente √∫til cuando:

- Iteras sobre listas de objetos
- Trabajas con funciones puras que devuelven m√∫ltiples valores
- Usas combinadores como `map`, `filter`, `fold`, etc.

```kotlin showLineNumbers title="Uso en una lista"
val playlist = listOf(
    Song("Dream On", 1973),
    Song("I Don't Want to Miss a Thing", 1998)
)

for ((title, year) in playlist) {
    println("$title ($year)")
}
```

### üß™ Ejemplo con combinadores

Los combinadores como `filter` y `map` permiten transformar y seleccionar datos de forma declarativa. Gracias a la desestructuraci√≥n, esto es muy legible:

```kotlin showLineNumbers title="Filtrar y transformar con combinadores"
val classics = playlist
    .filter { (_, year) -> year < 1980 }
    .map { (title, _) -> title.uppercase() }

println(classics) // [DREAM ON]
```

Aqu√≠ usamos:

- `(_, year)` para ignorar el t√≠tulo y filtrar por a√±o.
- `(title, _)` para ignorar el a√±o y transformar el t√≠tulo.

Esto muestra c√≥mo la desestructuraci√≥n simplifica operaciones t√≠picas sobre colecciones.

## ‚ôªÔ∏è Mutabilidad controlada con `copy`

Las `data class` en Kotlin son **inmutables por convenci√≥n**. Aunque es posible declarar propiedades mutables (`var`), en bibliotecas bien dise√±adas se recomienda utilizar **solo propiedades inmutables** (`val`). Esto favorece un estilo funcional, m√°s seguro y predecible.

Cuando necesitas "modificar" una instancia, en lugar de cambiarla directamente, puedes usar el m√©todo `copy()` para **crear una nueva instancia** con los valores actualizados, sin alterar el original:

```kotlin showLineNumbers title="Uso de copy para modificar datos sin mutar el original"
data class Mecha(val name: String, val power: Int)

val gurren = Mecha("Gurren", 3000)
val gurrenLagann = gurren.copy(name = "Gurren Lagann", power = 9000)

println(gurren)        // Mecha(name=Gurren, power=3000)
println(gurrenLagann)  // Mecha(name=Gurren Lagann, power=9000)
```

Este patr√≥n favorece objetos **seguros, predecibles y f√°ciles de testear** ‚Äîcualidades esenciales para construir bibliotecas reutilizables, componentes funcionales y sistemas concurrentes.

### üîÑ ¬øCu√°ndo es razonable usar mutabilidad?

Aunque las `data class` promueven la **inmutabilidad por convenci√≥n**, existen escenarios donde **la mutabilidad est√° justificada**:

- Est√°s modelando **estado que cambia naturalmente con el tiempo** (una sesi√≥n, una conexi√≥n, etc.).
- Necesitas **actualizar datos frecuentemente**, donde `copy()` ser√≠a costoso o complejo (como en videojuegos o simulaciones).
- Trabajas con **estructuras internas o ef√≠meras** que no forman parte del contrato p√∫blico de tu biblioteca.

:::tip Recomendaci√≥n

Cuando requieras mutabilidad, separa el **modelo inmutable** del **estado mutable**. Por ejemplo:

```kotlin showLineNumbers title="Separaci√≥n entre modelo y estado mutable"
data class FighterStats(val maxHp: Int, val maxStamina: Int)

class CombatSession(stats: FighterStats) {
    var currentHp = stats.maxHp
        private set

    var currentStamina = stats.maxStamina
        private set

    fun receiveDamage(amount: Int) {
        currentHp = (currentHp - amount).coerceAtLeast(0)
    }

    fun consumeStamina(amount: Int) {
        currentStamina = (currentStamina - amount).coerceAtLeast(0)
    }
}
```

Aqu√≠, `FighterStats` define un modelo de referencia inmutable, mientras que `CombatSession` gestiona un estado mutable que puede cambiar en tiempo de ejecuci√≥n.

:::

:::danger Rendimiento

En contextos de **altas tasas de actualizaci√≥n** (como motores f√≠sicos o renderizado), crear m√∫ltiples copias puede ser un **cuello de botella**. En esos casos, una clase mutable puede ser una alternativa v√°lida si **mejora el rendimiento** sin sacrificar claridad ni seguridad.

:::

## üß© ¬øCu√°ndo usar `data class`, `class` o tuplas (`Pair` / `Triple`)?

| **Escenario**                               | **`data class`** üü¢                          | **`class`** ‚öôÔ∏è                              | **Tupla (`Pair` / `Triple`)** üîπ                    |
|--------------------------------------------|---------------------------------------------|---------------------------------------------|-----------------------------------------------------|
| Modelar datos estructurados con nombre     | ‚úÖ Ideal                                     | ‚ö†Ô∏è Posible, pero m√°s verboso                | ‚ùå Nombres impl√≠citos dificultan la claridad         |
| Comparaci√≥n por contenido (`==`)           | ‚úÖ Generada autom√°ticamente                 | ‚ùå Solo por referencia                       | ‚ö†Ô∏è Disponible, pero sin sem√°ntica expl√≠cita          |
| M√©todos como `copy`, `toString`            | ‚úÖ Generados autom√°ticamente                 | ‚ùå Manuales                                  | ‚úÖ Limitados a aridad 2 o 3                          |
| L√≥gica adicional o comportamiento          | ‚ö†Ô∏è Posible, pero no idiom√°tico              | ‚úÖ Ideal para encapsular comportamiento      | ‚ö†Ô∏è V√≠a extensiones, pero **no se recomienda**        |
| Datos temporales o resultados intermedios  | ‚ö†Ô∏è Posible, pero puede ser innecesario       | ‚ùå Verboso para estructuras ef√≠meras         | ‚úÖ Excelente para datos r√°pidos y sin contexto       |
| Uso interno o en contextos de rendimiento  | ‚ö†Ô∏è Evaluar seg√∫n el caso                    | ‚úÖ Control total                             | ‚úÖ Muy livianas, ideales para estructuras internas   |

:::tip En resumen

- Usa **`data class`** para representar **datos estructurados con sem√°ntica clara**, donde la comparaci√≥n por contenido, los m√©todos generados y la legibilidad son importantes.
- Usa **`class`** cuando necesites **l√≥gica adicional**, comportamiento mutable, herencia, o un control m√°s fino sobre el ciclo de vida del objeto.
- Usa **tuplas (`Pair` / `Triple`)** solo para **datos temporales o intermedios**, donde los nombres de los campos no son relevantes y la concisi√≥n es prioritaria.

:::

:::info Consejo adicional

Si necesitas representar **m√°s de tres elementos**, considera siempre una `data class` con nombres expl√≠citos. Las tuplas de aridad alta son dif√≠ciles de mantener y comprender.

:::

## üîß Funciones y propiedades en `data class`

Aunque las `data class` est√°n dise√±adas para modelar **datos estructurados**, eso no impide que incluyan **propiedades calculadas** o **funciones auxiliares**.

Esto puede ser √∫til para agregar **l√≥gica derivada**, validaciones simples o representaciones alternativas sin romper la sem√°ntica del tipo.

```kotlin title="Propiedad calculada y funci√≥n auxiliar"
data class Wizard(val name: String, val magic: String, val power: Int) {
    val isArchmage: Boolean
        get() = power > 9000

    fun shout() = println("$name casts $magic at power $power!")
}
```

<Explanation>
    En este ejemplo, `isArchmage` es una propiedad calculada que no forma parte del constructor, pero que **proporciona informaci√≥n derivada** a partir de los campos. La funci√≥n `shout()` encapsula un comportamiento asociado al tipo, mejorando su expresividad sin afectar su estructura.
</Explanation>

::::warning No abuses de esto

Aunque es v√°lido incluir funciones y propiedades adicionales en una `data class`, **no deber√≠as cargarla con l√≥gica compleja, efectos secundarios o estado mutable**. Su prop√≥sito principal es representar **datos inmutables, estructurados y comparables por contenido**.

Adem√°s, las `data class` forman parte del contrato p√∫blico de tu biblioteca o API: cualquier campo fuera del constructor primario **no participar√° en `equals`, `hashCode`, `copy` ni `toString`**, lo que puede generar inconsistencias sutiles o errores dif√≠ciles de detectar.

:::tip Recomendaci√≥n

Si una propiedad es esencial para la identidad del objeto, **debe declararse en el constructor**. Si la clase empieza a mezclar demasiada l√≥gica con datos, considera extraer esa l√≥gica a otra clase o usar composici√≥n.

:::

::::

## üèóÔ∏è Constructores

En Kotlin, las `data class` pueden tener **constructores primarios** y **secundarios**, los cuales permiten definir **formas alternativas de crear una instancia** sin repetir la l√≥gica de inicializaci√≥n. Esto es √∫til cuando algunos datos pueden asumir valores por defecto o si quieres ofrecer una API m√°s flexible.

En el siguiente ejemplo, modelamos libros publicados en el siglo XX. El constructor principal exige t√≠tulo, autor y a√±o, pero tambi√©n ofrecemos una alternativa que **asume que el autor es desconocido** si no se especifica:

<BoxedTabs>
  <TabItem label="C√≥digo esencial" value="essential">

  ```kotlin showLineNumbers title="Constructores en data class"
  data class TwentiethCenturyBook(val title: String, val author: String, val year: Int) {
      init {
          require(year in 1900..1999) {
              "Only books published between 1900 and 1999 are allowed. Received: $year"
          }
      }

      constructor(title: String, year: Int) : this(title, "Unknown", year) {
          println("No author provided ‚Äî using 'Unknown'.")
      }
  }
  ```

  </TabItem>
  <TabItem label="C√≥digo completo" value="complete">

  ```kotlin showLineNumbers title="Main.kt"
  data class TwentiethCenturyBook(val title: String, val author: String, val year: Int) {
      init {
          require(year in 1900..1999) {
              "Only books published between 1900 and 1999 are allowed. Received: $year"
          }
      }

      constructor(title: String, year: Int) : this(title, "Unknown", year) {
          println("No author provided ‚Äî using 'Unknown'.")
      }
  }

  fun main() {
      val book1 = TwentiethCenturyBook("The Hobbit", "J. R. R. Tolkien", 1937)
      println("Book 1: $book1")

      val book2 = TwentiethCenturyBook("The Shadow Over Innsmouth", "H. P. Lovecraft", 1936)
      println("Book 2: $book2")

      val book3 = TwentiethCenturyBook("Primary Colors", 1996)
      println("Book 3: $book3")

      val book4 = TwentiethCenturyBook("Fire & Blood", "George R. R. Martin", 2018)
      println("Book 4: $book4")
  }
  ```

  </TabItem>
</BoxedTabs>

<Explanation>
    En este ejemplo aprendimos a usar un **constructor secundario** para cubrir un caso especial: cuando el autor de un libro no es conocido. Adem√°s, usamos el bloque `init` del constructor primario para validar las reglas del dominio (solo libros publicados entre 1900 y 1999), manteniendo el modelo robusto y consistente. Si se entrega un a√±o fuera del rango, el programa lanza una excepci√≥n.
</Explanation>

:::tip ¬øPodr√≠amos haber usado par√°metros por defecto?

S√≠, y de hecho, en Kotlin se prefiere usar par√°metros con valores por defecto en el constructor primario cuando sea posible. Es m√°s conciso, m√°s idiom√°tico y evita tener que declarar un constructor secundario si la l√≥gica es trivial:

```kotlin showLineNumbers title="Par√°metros por defecto en el constructor primario"
data class TwentiethCenturyBook(
    val title: String,
    val author: String = "Unknown",
    val year: Int
) {
    init {
        require(year in 1900..1999)
    }
}
```

:::

## üìù Ejercicio pr√°ctico ‚Äî Gestiona tu cat√°logo de dependencias

<Exercise>

Imagina que mantienes un repositorio interno con artefactos Maven/Gradle. Cada artefacto se identifica por:

| Campo        | Tipo    | Reglas de dominio |
|--------------|---------|-------------------|
| `group`      | `String`| No vac√≠o, min√∫sculas y puntos (`com.example`) |
| `name`       | `String`| No vac√≠o, sin espacios |
| `version`    | `String`| Formato *semver* `MAJOR.MINOR.PATCH`, p.¬†ej. `1.2.3` |

1. Declara `DependencyMetadata` y valida en `init` que:
    - Ning√∫n campo est√© en blanco.
    - `version` cumpla el patr√≥n semver.

    <Hint hints={[
        <>
            Puedes verificar que un string no est√© vac√≠o con <code>String.isNotBlank(): Boolean</code>.
        </>,
        <>
            Para validar el formato de <code>version</code>, usa <code>Regex.matches(String): Boolean</code>. Por ejemplo, <code>"""\d+\.\d+\.\d+""".toRegex().matches("19.3.7")</code>.
        </>,
        <>
            Puedes ver que un string est√© en min√∫sculas con <code>String.lowercase(): String</code>.
        </>
    ]}/>

2. Algunos m√≥dulos internos a√∫n no se versionan; permite crearlos sin `version`. Si no se indica, usa `"0.1.0‚ÄëSNAPSHOT"`.
3. A√±ade una propiedad calculada `isSnapshot` que sea `true` si `version` termina en `"SNAPSHOT"`.
    <Hint hints={[
        <>Para verificar si una cadena termina en un sufijo, usa <code>String.endsWith(String): Boolean</code>.</>,
    ]}/>

<Solution>
    <BoxedTabs>
        <TabItem label={"C√≥digo esencial"} value={"C√≥digo esencial"}>
            1.
            ```kotlin showLineNumbers title="Declaraci√≥n y validaci√≥n de artefacto (DependencyMetadata.kt)"
            data class DependencyMetadata(
                val group: String,
                val name: String,
                val version: String
            ) {

                private val semver = Regex("""\d+\.\d+\.\d+""")

                init {
                    require(group.isNotBlank()) { "Group must not be blank" }
                    require(name.isNotBlank()) { "Name must not be blank" }
                    require(group == group.lowercase() && '.' in group) {
                        "Group must be lowercase and dot-separated"
                    }
                    require(semver.matches(version)) {
                        "Version must follow semver format. Got: $version"
                    }
                }
            }
            ```

            2.
            ```kotlin showLineNumbers title="Constructor secundario por defecto (DependencyMetadata.kt)"
            constructor(group: String, name: String) : this(group, name, "0.1.0-SNAPSHOT") {
                println("No version provided ‚Äî using default snapshot.")
            }
            ```

            3.
            ```kotlin showLineNumbers title="Propiedad calculada isSnapshot (DependencyMetadata.kt)"
            val isSnapshot: Boolean
                get() = version.endsWith("SNAPSHOT")
            ```
        </TabItem>
        <TabItem label={"C√≥digo completo"} value={"C√≥digo completo"}>
            ```kotlin showLineNumbers title="Ejemplo completo con validaciones y ejecuci√≥n (DependencyMetadata.kt)"
            data class DependencyMetadata(
                val group: String,
                val name: String,
                val version: String
            ) {

                private val semver = Regex("""\d+\.\d+\.\d+""")

                init {
                    require(group.isNotBlank()) { "Group must not be blank" }
                    require(name.isNotBlank()) { "Name must not be blank" }
                    require(group == group.lowercase() && '.' in group) {
                        "Group must be lowercase and dot-separated"
                    }
                    require(semver.matches(version)) {
                        "Version must follow semver format. Got: $version"
                    }
                }

                constructor(group: String, name: String) : this(group, name, "0.1.0-SNAPSHOT") {
                    println("No version provided ‚Äî using default snapshot.")
                }

                val isSnapshot: Boolean
                    get() = version.endsWith("SNAPSHOT")
            }

            fun main() {
                val dep1 = DependencyMetadata("com.example", "analytics", "1.2.3")
                println("Dependency: $dep1")
                println("Is snapshot: ${dep1.isSnapshot}") // false

                val dep2 = DependencyMetadata("com.example", "logging")
                println("Dependency: $dep2")
                println("Is snapshot: ${dep2.isSnapshot}") // true
            }
            ```
        </TabItem>
    </BoxedTabs>
</Solution>

</Exercise>

## üéØ Conclusiones

En esta lecci√≥n profundizamos en el uso idiom√°tico de las `data class` en Kotlin como mecanismo fundamental para representar tipos producto.

Exploramos sus ventajas frente a clases tradicionales y tuplas, incluyendo comparaci√≥n por contenido, generaci√≥n autom√°tica de m√©todos comunes y su integraci√≥n natural con herramientas como la desestructuraci√≥n, combinadores funcionales y validaci√≥n de reglas de dominio.

Tambi√©n discutimos buenas pr√°cticas sobre mutabilidad: cu√°ndo est√° justificada y c√≥mo estructurar el c√≥digo para mantener un dise√±o claro, seguro y mantenible ‚Äîespecialmente en bibliotecas reutilizables.

### üîë Puntos clave

- Las `data class` son la forma idiom√°tica en Kotlin de definir **registros**: estructuras de datos con nombre, contenido significativo y comportamiento predecible.
- Permiten comparar objetos por contenido, generar copias de manera segura y desestructurar valores con una sintaxis clara.
- Aunque pueden incluir l√≥gica adicional, su prop√≥sito principal es **modelar datos**, no encapsular comportamiento complejo ni estados mutables.
- Su uso adecuado contribuye a dise√±os m√°s expresivos, seguros y f√°ciles de mantener.

### üß∞ ¬øQu√© nos llevamos?

Dise√±ar estructuras de datos con intenci√≥n sem√°ntica clara no es solo una cuesti√≥n de estilo: es una herramienta clave para **mejorar la expresividad, mantenibilidad y seguridad** de nuestras bibliotecas.

Al preferir `data class` para representar tipos producto:

- Evitamos c√≥digo repetido
- Reducimos errores en comparaciones o copias
- Promovemos un estilo m√°s funcional y predecible

Comprender sus l√≠mites y posibilidades es esencial para dise√±ar **APIs claras, robustas y sostenibles**, que otras personas puedan usar con confianza y sin sorpresas.

<div className="language-card-container">

<LanguageCards.PythonCard link="/docs/type-fundamentals/algebraic-data-types/records-2/py"/>

</div>

<div class="exclude-from-reading-time">

## üìñ Referencias

### üî• Recomendadas

- [üåê "Data classes"](https://kotlinlang.org/docs/data-classes.html) en la **documentaci√≥n oficial de Kotlin**: Explica en detalle c√≥mo funcionan las `data class` en Kotlin y qu√© genera autom√°ticamente el compilador (como `equals`, `hashCode`, `toString`, `copy`, y `componentN`). Es relevante para esta lecci√≥n porque **respalda y ampl√≠a los conceptos presentados**, mostrando requisitos t√©cnicos, restricciones y casos de uso idiom√°ticos fundamentales para modelar tipos producto de forma segura y expresiva.

### üîπ Adicionales

- üìï "Data Classes" en *Beginner‚Äôs Guide to Kotlin Programming* de **John Hunt**: Este cap√≠tulo introduce las *data classes*, una caracter√≠stica del lenguaje Kotlin dise√±ada para representar estructuras de datos inmutables con propiedades, pero con poca o ninguna l√≥gica asociada. Se explican las ventajas de usar estas clases, como la generaci√≥n autom√°tica de m√©todos como `toString()`, `equals()`, `hashCode()` y `copy()`, basados exclusivamente en las propiedades del constructor. Tambi√©n se detalla c√≥mo funcionan con propiedades no incluidas en el constructor, c√≥mo pueden implementar interfaces, extender clases abiertas y utilizarse con desestructuraci√≥n. Finalmente, se incluye un ejercicio pr√°ctico para crear una clase de datos `Customer` en un contexto de aplicaci√≥n financiera.

</div>
