---
title: Introducci√≥n a la Programaci√≥n Orientada a Objetos
---
import { LanguageCard, CSharpCard, PythonCard, SwiftCard } from '@site/src/components/cards/LanguageCard';
import ReadingTime from '@site/src/components/ReadingTime';
import References from "@site/src/components/ReferencesComponent";
import TabItem from "@theme/TabItem";
import Tabs from "@theme/Tabs";
import BoxedTabs from '@site/src/components/cajitas/BoxedTabs'
import Explanation from '@site/src/components/admonitions/Explanation'

<ReadingTime/>

La **Programaci√≥n Orientada a Objetos (OOP)** es un paradigma de desarrollo que modela el software en torno a **entidades que combinan datos y comportamiento**, com√∫nmente llamadas *objetos*. Estas entidades encapsulan su estado interno y exponen operaciones que permiten interactuar con ese estado.

En este enfoque, estructuramos nuestro c√≥digo mediante conceptos como:

- **Clases**, que act√∫an como planos o plantillas que definen qu√© datos y comportamientos tendr√° una entidad.
- **Instancias**, que son representaciones concretas de una clase, cada una con su propio estado.
- **Interfaces**, que definen contratos de comportamiento sin proporcionar una implementaci√≥n completa.
- **Herencia**, que permite reutilizar o extender comportamientos definidos en otras clases o interfaces.
- **Encapsulaci√≥n**, que protege los detalles internos de una entidad, exponiendo solo lo necesario.
- **Polimorfismo**, que permite tratar distintas implementaciones de manera uniforme.

En Kotlin, la OOP se expresa de manera moderna y concisa. El lenguaje introduce mecanismos como `data class`, `object` y `interface` con implementaci√≥n, que permiten dise√±ar sistemas modulares y expresivos, equilibrando claridad y flexibilidad.

---

Esta lecci√≥n introduce los pilares fundamentales de OOP en Kotlin, mediante ejemplos pr√°cticos y contextualizados. Aprender√°s a definir clases, instanciar estructuras, extender comportamientos, encapsular l√≥gica y construir jerarqu√≠as de tipos reutilizables. Estos conceptos ser√°n esenciales tanto para crear aplicaciones como para dise√±ar bibliotecas bien estructuradas.

## Singleton

En Kotlin, los **singleton** se definen con la palabra clave `object`, lo que garantiza que solo exista una √∫nica instancia, sin necesidad de crearla expl√≠citamente.

<BoxedTabs>
    <TabItem label={"C√≥digo esencial"} value={"C√≥digo esencial"}>
        ```kotlin showLineNumbers
        object InfernoCop {
            var mood = "calm"

            fun speak() = when (mood) {
                "calm" -> "Justice will be served."
                "angry" -> "BURNING JUSTICE!!!"
                else -> "..."
            }
        }
        ```
    </TabItem>
    <TabItem label={"C√≥digo completo"} value={"C√≥digo completo"}>
        ```kotlin showLineNumbers
        object InfernoCop {
            var mood = "calm"

            fun speak() = when (mood) {
                "calm" -> "Justice will be served."
                "angry" -> "BURNING JUSTICE!!!"
                else -> "..."
            }
        }

        fun main() {
            println(InfernoCop.speak())    // Justice will be served.
            InfernoCop.mood = "angry"
            println(InfernoCop.speak())    // BURNING JUSTICE!!!
        }
        ```
    </TabItem>
</BoxedTabs>

<Explanation>
    En este ejemplo, `InfernoCop` es un **singleton** que representa al legendario justiciero de *Inferno Cop*. Usando `object`, definimos una √∫nica instancia compartida en todo el programa.

    Al cambiar el valor de `mood`, su comportamiento tambi√©n cambia, lo que refleja su estado global y persistente. No es necesario instanciarlo ni invocar un constructor: simplemente usamos `InfernoCop.speak()`.

    Esto ilustra c√≥mo los singleton pueden encapsular comportamiento **y estado mutable global**, aunque este tipo de dise√±o debe usarse con precauci√≥n en contextos reales. üî•
</Explanation>

:::warning Uso de estado mutable

Aunque es posible declarar propiedades mutables en un `object`, es recomendable evitarlo cuando el singleton se usa en entornos concurrentes o compartidos, ya que puede generar [condiciones de carrera](https://es.wikipedia.org/wiki/Condici%C3%B3n_de_carrera). En esos casos, se sugiere mantener el estado inmutable o sincronizado adecuadamente.

:::

## Clases

Una **clase** es un plano que define las propiedades y comportamientos de los objetos. Se puede instanciar m√∫ltiples veces.

<BoxedTabs>
    <TabItem label={"C√≥digo esencial"} value={"C√≥digo esencial"}>
        ```kotlin showLineNumbers
        class Person(val name: String) {
            fun greet() = "It's a strange world, $name."
        }
        ```
    </TabItem>
    <TabItem label={"C√≥digo completo"} value={"C√≥digo completo"}>
        ```kotlin showLineNumbers
        class Person(val name: String) {
            fun greet() = "It's a strange world, $name."
        }

        fun main() {
            val jeffrey = Person("Jeffrey")
            println(jeffrey.greet())    // It's a strange world, Jeffrey.
            val frank = Person("Frank")
            println(frank.greet())      // It's a strange world, Frank.
        }
        ```
    </TabItem>
</BoxedTabs>

<Explanation>
    En este ejemplo, `Person` es una **clase** que modela personajes inspirados en *Blue Velvet*. Cada instancia de `Person` tiene un nombre distinto, y la funci√≥n `greet()` genera un saludo que evoca una de las frases m√°s memorables de la pel√≠cula: *"It's a strange world."*

    A diferencia de un `object`, aqu√≠ se crean m√∫ltiples instancias de `Person`, cada una con su propio estado. Esto demuestra c√≥mo las clases permiten representar diferentes objetos con la misma estructura pero con datos particulares, una idea central en la **Programaci√≥n Orientada a Objetos**.

    :::tip Instanciaci√≥n sin `new`

    A diferencia de lenguajes como Java o C#, Kotlin **no utiliza la palabra clave `new`** para crear objetos. Simplemente se llama al constructor como si fuera una funci√≥n, lo que contribuye a una sintaxis m√°s limpia y concisa.

    :::
</Explanation>

## üê∫ Interfaces

Las **interfaces** definen contratos de comportamiento. Por lo general, declaran funciones o propiedades sin implementaci√≥n, aunque en Kotlin pueden incluir implementaciones predeterminadas. Las clases que implementan una interfaz deben proveer las implementaciones necesarias.

<BoxedTabs>
  <TabItem label={"C√≥digo esencial"} value={"C√≥digo esencial"}>
  
  ```kotlin showLineNumbers
  interface Fighter {
      fun fight(): String
  }

  interface Alchemist {
      fun brewPotion(): String
  }
  
  class Witcher(val name: String) : Fighter, Alchemist {
      override fun fight() = "$name swings a silver sword!"
      override fun brewPotion() = "$name brews a Cat potion..."
  }
  ```

  </TabItem>
  <TabItem label={"C√≥digo completo"} value={"C√≥digo completo"}>
  
  ```kotlin showLineNumbers
  interface Fighter {
      fun fight(): String
  }

  interface Alchemist {
      fun brewPotion(): String
  }

  class Witcher(val name: String) : Fighter, Alchemist {
      override fun fight() = "$name swings a silver sword!"
      override fun brewPotion() = "$name brews a Cat potion..."
  }

  fun main() {
      val geralt = Witcher("Geralt")
      val lambert = Witcher("Lambert")
      
      println(geralt.fight())      // Geralt swings a silver sword!
      println(geralt.brewPotion()) // Geralt brews a Cat potion...

      println(lambert.fight())     // Lambert swings a silver sword!
      println(lambert.brewPotion())// Lambert brews a Cat potion...
  }
  ```

  </TabItem>
</BoxedTabs>

<Explanation>
    En este ejemplo, la clase `Witcher` implementa dos interfaces: `Fighter` y `Alchemist`, que representan comportamientos comunes de un brujo. Cada instancia de `Witcher` tiene su propio `name` y puede **pelear** y **preparar pociones**.

    Las interfaces permiten que distintos tipos de personajes ‚Äî**no solo brujos**‚Äî compartan comportamientos como combate o alquimia **sin estar acoplados jer√°rquicamente**. Por ejemplo, **Ciri** no es una `Witcher`, pero puede implementar `Fighter` y `Alchemist` porque es una guerrera y alquimista:

    ```kotlin
    object Ciri : Fighter, Alchemist {
        override fun fight() = "Ciri uses her sword!"
        override fun brewPotion() = "Ciri brews a potion..."
    }
    ```

    De este modo, Ciri puede participar en las mismas interacciones que un Witcher en cuanto a combate, sin necesidad de heredar de la clase `Witcher`.

    :::tip Implementaci√≥n m√∫ltiple

    Kotlin usa el operador `:` seguido de una lista separada por comas para indicar que una clase implementa m√∫ltiples interfaces:

    ```kotlin
    class X : Interface1, Interface2
    ```

    :::
</Explanation>

<details>
    <summary>Interfaces con implementaciones predeterminadas</summary>

    En Kotlin, las interfaces pueden incluir **implementaciones predeterminadas** para algunos de sus m√©todos. Esto permite que las clases que las implementan **no est√©n obligadas a sobrescribir todos los m√©todos**, lo que resulta √∫til para definir comportamientos comunes sin duplicar l√≥gica.

    Sin embargo, este poder adicional tambi√©n introduce cierta complejidad en la jerarqu√≠a de clases. Un ejemplo cl√°sico es el **problema del diamante**, que ocurre cuando una clase implementa dos interfaces que definen un m√©todo con la misma firma pero con implementaciones distintas. Kotlin resuelve este conflicto exigiendo a la persona que desarrolla que sobrescriba expl√≠citamente el m√©todo conflictivo y defina cu√°l de las implementaciones debe usarse, o bien proporcione una nueva.

    A lo largo del curso, profundizaremos en estos aspectos m√°s avanzados. Por ahora, nos enfocaremos en **interfaces con m√©todos abstractos**, lo que facilita la comprensi√≥n de los conceptos fundamentales sin distracciones innecesarias.
</details>

## Clases Abstractas

Las clases abstractas pueden contener funciones con o sin implementaci√≥n. No pueden ser instanciadas directamente y est√°n pensadas para ser extendidas por otras clases. Sirven como base para otras clases que deben implementar sus miembros abstractos.

<BoxedTabs>
  <TabItem label={"C√≥digo esencial"} value={"C√≥digo esencial"}>
    ```kotlin showLineNumbers
    abstract class AbstractDragon {
        abstract fun breathesFire(): String
        fun fly() = "Soaring over Westeros..."
    }
    ```
  </TabItem>
  <TabItem label={"C√≥digo completo"} value={"C√≥digo completo"}>
    ```kotlin showLineNumbers
    abstract class AbstractDragon {
        abstract fun breathesFire(): String
        fun fly() = "Soaring over Westeros..."
    }

    class TargaryenDragon(val name: String) : AbstractDragon() {
        override fun breathesFire() = "$name breathes fire with fury!"
    }

    fun main() {
        val viserion = TargaryenDragon("Viserion")
        println(viserion.breathesFire())  // Viserion breathes fire with fury!
        println(viserion.fly())           // Soaring over Westeros...
    }
    ```
  </TabItem>
</BoxedTabs>

<Explanation>
    En este ejemplo, `AbstractDragon` define el comportamiento com√∫n de todos los dragones, como volar (`fly()`), pero deja la acci√≥n de lanzar fuego como una funci√≥n abstracta (`breathesFire()`).

    La clase `TargaryenDragon` extiende de `AbstractDragon` y puede representar m√∫ltiples instancias como *Viserion*, *Rhaegal* o *Drogon*, cada una con su propio nombre. Esto permite reutilizar el comportamiento com√∫n y especializar el comportamiento de cada instancia.

    :::tip Diferencias de sintaxis entre Kotlin y Scala

    En Kotlin, toda funci√≥n abstracta debe marcarse expl√≠citamente con la palabra clave `abstract`. Esto contrasta con lenguajes como Scala, donde una funci√≥n sin cuerpo dentro de una clase abstracta se considera abstracta **impl√≠citamente**, sin necesidad del modificador.

    ```scala title="Scala"
    abstract class AbstractDragon {
        def breathesFire: String  // abstracta aunque no est√© marcada
        def fly(): String = "Soaring..."
    }
    ```

    En Kotlin, esto mismo debe escribirse as√≠:

    ```kotlin title="Kotlin"
    abstract class AbstractDragon {
        abstract fun breathesFire(): String  // obligatorio marcarla
        fun fly() = "Soaring..."
    }
    ```

    :::
</Explanation>

:::note Convenci√≥n

En Kotlin, no es obligatorio usar el prefijo `Abstract`, pero es una **buena pr√°ctica** cuando se quiere dejar claro que la clase no puede ser instanciada directamente.

:::

## Encapsulaci√≥n

La **encapsulaci√≥n** es el principio que protege los datos internos de una clase, evitando que puedan ser modificados o accedidos de forma indebida desde el exterior. Esto permite mantener la coherencia del estado interno, reducir el acoplamiento y facilitar el mantenimiento del software. En Kotlin, la encapsulaci√≥n se implementa usando **modificadores de acceso**.

### Modificadores de Acceso en Kotlin

1. **`public`** (por defecto): Accesible desde cualquier parte del c√≥digo. Si no se especifica un modificador, se considera `public`. En bibliotecas de software, esto implica que un miembro `public` es accesible tanto desde el propio c√≥digo de la biblioteca como desde cualquier c√≥digo externo que la utilice.
2. **`private`**: Solo accesible dentro del cuerpo de la clase o archivo donde se define. **No es accesible desde subclases ni desde otras clases del mismo archivo.**
3. **`protected`**: Accesible desde la clase donde se define y desde cualquier subclase, incluso si est√°n en otros archivos.
4. **`internal`**: Accesible desde cualquier archivo del mismo m√≥dulo. Esto es √∫til para compartir c√≥digo entre clases sin exponerlo fuera del m√≥dulo. M√°s adelante veremos qu√© es un m√≥dulo en Kotlin.

### Ejemplo

```kotlin showLineNumbers
abstract class AbstractJoestar(private val stand: String) {
    protected fun revealStandName(): String = "My Stand is $stand!"
}

object Jotaro : AbstractJoestar("Star Platinum") {
    fun introduceStand(): String = revealStandName()
}

fun main() {
    println(Jotaro.introduceStand())  // My Stand is Star Platinum!

    // Error: cannot access 'stand': it is private in 'Joestar'
    // println(Jotaro.stand)

    // Error: cannot call 'revealStandName()': it is protected in 'Joestar'
    // println(Jotaro.revealStandName())
}
```

<Explanation>
    En este ejemplo, la clase `AbstractJoestar` tiene un campo `stand` marcado como `private`, lo que significa que **no puede ser accedido directamente desde fuera de la clase**. Adem√°s, tiene una funci√≥n `revealStandName()` marcada como `protected`, lo que permite que **solo las subclases** como `Jotaro` puedan usarla.

    De este modo, protegemos los detalles internos del personaje y damos acceso solo a lo que es relevante para quien extiende la clase.
</Explanation>

:::warning Package-Private

En Kotlin no existe el concepto de **package-private** como en Java o Scala. Esta decisi√≥n se tom√≥ para evitar ambig√ºedades: en estos lenguajes, es posible que una clase externa acceda a miembros *supuestamente privados* si est√° en el mismo paquete, lo cual puede romper la encapsulaci√≥n. Kotlin opta por no incluir esta opci√≥n para fomentar una separaci√≥n m√°s segura.

:::

## Constructores Primarios y Secundarios en Kotlin

Kotlin permite definir **constructores primarios** y **constructores secundarios** para las clases.

### Constructor Primario
El **constructor primario** se define en la cabecera de la clase y puede inicializar propiedades directamente.

```kotlin showLineNumbers
class Person(val name: String, var age: Int)
```

- Se define dentro de la cabecera de la clase.
- No contiene l√≥gica adicional, pero puede usar bloques de inicializaci√≥n (`init`) si se necesita.

```kotlin showLineNumbers
class Person(val name: String, var age: Int) {
    init {
        require(age >= 0) { "Age must be non-negative" }
    }
}
```

:::info ``require``

La funci√≥n `require` verifica una condici√≥n y lanza una excepci√≥n de tipo `IllegalArgumentException` si no se cumple. Es √∫til para validar argumentos de funciones y constructores. Notemos que la sintaxis es ``require(condition) { "message" }``.

:::

### Constructor Secundario

Un **constructor secundario** se define dentro del cuerpo de la clase, permitiendo l√≥gica adicional. Se llama al constructor primario usando `this`.

```kotlin showLineNumbers
class Person(val name: String) {
    var age: Int = 0

    constructor(name: String, age: Int) : this(name) {
        this.age = age
    }
}
```

Los constructores secundarios son √∫tiles cuando necesitas diferentes formas de inicializar una clase.

:::tip Par√°metros por defecto

En gran parte de los casos, los constructores secundarios no son necesarios gracias a los **par√°metros por defecto** en Kotlin. Los par√°metros por defecto permiten definir valores predeterminados para los par√°metros de un constructor, evitando la necesidad de m√∫ltiples constructores.

De esta forma, el ejemplo anterior se puede simplificar a:

```kotlin showLineNumbers
class Person(val name: String, var age: Int = 0)
```

:::

## ¬øQu√© aprendimos?

En esta lecci√≥n, exploramos los conceptos fundamentales de la **Programaci√≥n Orientada a Objetos (OOP)** en **Kotlin**.

### Puntos clave

1. **Singletons**: Definidos con la palabra clave `object`, los singleton son instancias √∫nicas de una clase que no necesitan ser instanciadas m√∫ltiples veces.
2. **Clases**: Las clases permiten definir propiedades y comportamientos de objetos. Se pueden instanciar tantas veces como sea necesario.
3. **Interfaces**: Definen contratos de comportamiento que las clases deben implementar. Kotlin permite interfaces con implementaciones predeterminadas, lo que resuelve problemas como el **problema del diamante**.
4. **Clases Abstractas**: Act√∫an como plantillas para otras clases, pueden tener miembros implementados o no, pero no pueden ser instanciadas directamente.
5. **Encapsulaci√≥n**: Es el principio de proteger los datos internos de una clase. Se implementa usando modificadores de acceso como `private`, `protected`, `internal`, y `public`.
6. **Constructores**: Kotlin permite constructores primarios y secundarios. Los constructores primarios permiten inicializar las propiedades de la clase de manera concisa, mientras que los secundarios ofrecen m√°s flexibilidad en la inicializaci√≥n.

Adem√°s, vimos c√≥mo los **par√°metros por defecto** permiten evitar constructores secundarios en muchos casos, simplificando el dise√±o de las clases.

---

Con estas bases, puedes comenzar a estructurar tu c√≥digo de manera eficiente utilizando los principios de la OOP, mejorando la modularidad, legibilidad y mantenimiento de tus proyectos en Kotlin.

<div className="language-card-container">
    <CSharpCard link='/docs/intro/oop/csharp'/>
    <PythonCard link='/docs/intro/oop/python'/>
    <SwiftCard link='/docs/intro/oop/swift'/>
</div>

<References references={[
    {
        title: "Classes, objects, and interfaces",
        bookTitle: "Kotlin in action",
        pages: "67‚Äì102",
        location: "Shelter Island, NY",
        publisher: "Manning Publications Co",
        year: "2017",
        type: "book",
        author: 'Dmitry Jemerov, Svetlana Isakova',
    },
]} additionalReferences={[
    {
        accessedDate: '23 de septiembre de 2024',
        siteOrAuthor: 'Kotlin Help',
        title: 'Object Declarations and Expressions | Kotlin',
        type: 'web',
        url: 'https://kotlinlang.org/docs/object-declarations.html'
    },
    {
        accessedDate: '23 de septiembre de 2024',
        siteOrAuthor: 'Kotlin Help',
        title: 'Classes | Kotlin',
        type: 'web',
        url: 'https://kotlinlang.org/docs/classes.html'
    },
    {
        accessedDate: '23 de septiembre de 2024',
        siteOrAuthor: 'Kotlin Help',
        title: 'Interfaces | Kotlin',
        type: 'web',
        url: 'https://kotlinlang.org/docs/interfaces.html'
    },
    {
        accessedDate: '23 de septiembre de 2024',
        siteOrAuthor: 'Kotlin Help',
        title: 'Visibility Modifiers | Kotlin',
        type: 'web',
        url: 'https://kotlinlang.org/docs/visibility-modifiers.html'
    },
]} />
