---
title: IntroducciÃ³n al desarrollo de bibliotecas de software
---
import ReadingTime from '@site/src/components/ReadingTime'
import { ProCons, Pros, Cons } from '@site/src/components/cajitas/ProCons'
import References from '@site/src/components/ReferencesComponent'
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'
import Exercise from '@site/src/components/exercise/Exercise'
import Solution from '@site/src/components/exercise/Solution'
import Hint from '@site/src/components/exercise/Hint'
import Definition from '@site/src/components/Definition'
import Corollary from '@site/src/components/Corollary'
import GithubRepoLink from '@site/src/components/GithubRepoLink'
import { LanguageCard } from '@site/src/components/cards/LanguageCard'
import Explanation from '@site/src/components/admonitions/Explanation'
import RepoClone from '@site/src/components/admonitions/RepoClone'
import ModuleSetup from '@site/src/components/cajitas/ModuleSetup'
import BoxedTabs from '@site/src/components/cajitas/BoxedTabs'

<ReadingTime />

El desarrollo de bibliotecas de software es una parte esencial en la creaciÃ³n de herramientas reutilizables que permiten a otras aplicaciones y desarrolladorxs resolver problemas comunes de manera eficiente. En lugar de reescribir cÃ³digo repetitivo en cada proyecto, las bibliotecas proporcionan **funcionalidades encapsuladas y optimizadas** que pueden ser integradas fÃ¡cilmente en distintos entornos de desarrollo.

Desde cÃ¡lculos cientÃ­ficos hasta manipulaciÃ³n de datos, las bibliotecas estÃ¡n en el nÃºcleo del software moderno. **Algunos ejemplos ampliamente utilizados incluyen:**  

- ğŸ§® **NumPy** *(Python)*: proporciona estructuras y operaciones optimizadas para cÃ¡lculos numÃ©ricos de alto rendimiento.  
- ğŸ“¦ **Lodash** *(JavaScript)*: ofrece herramientas para manipular arreglos, objetos y funciones de manera eficiente.  
- âš¡ **Arrow** *(Kotlin)*: facilita la programaciÃ³n funcional y la gestiÃ³n segura de errores mediante estructuras como `Either` y `Validated`.  
- ğŸ”— **Boost** *(C++)*: extiende las capacidades estÃ¡ndar del lenguaje con estructuras de datos avanzadas y herramientas de concurrencia.  

Cada una de estas bibliotecas demuestra cÃ³mo un buen diseÃ±o de API y una implementaciÃ³n eficiente pueden **reducir la complejidad del cÃ³digo**, mejorar la productividad y fomentar la reutilizaciÃ³n.

En este artÃ­culo, exploraremos los principios clave del diseÃ±o de bibliotecas de software, destacando **las mejores prÃ¡cticas para crear APIs efectivas y fÃ¡ciles de usar**. TambiÃ©n analizaremos ejemplos de bibliotecas populares que aplican estos conceptos en la prÃ¡ctica, desde **JavaScript hasta Kotlin**.

## ğŸ”— APIs: La Base del Desarrollo de Software Moderno

Una **API** (*Application Programming Interface*) es un conjunto de reglas y herramientas que define cÃ³mo interactuar con una biblioteca o sistema. ActÃºa como un **bloque de construcciÃ³n reutilizable**, permitiendo que aplicaciones y desarrolladorxs agreguen funcionalidades de manera eficiente y estandarizada.  

Las APIs son esenciales en el desarrollo moderno de software y suelen proporcionarse mediante **bibliotecas**, como **NumPy** para cÃ¡lculos numÃ©ricos en Python o **Lodash** para manipulaciÃ³n de datos en JavaScript.

### âœ… CaracterÃ­sticas de una Buena API

#### ğŸ¯ 1. Modelar el Problema Correctamente  

Una API bien diseÃ±ada debe proporcionar una **abstracciÃ³n clara y efectiva** del problema que resuelve.  

âœ”ï¸ **PropÃ³sito claro** â†’ Cada funciÃ³n, clase y variable debe estar bien definida.  
âœ”ï¸ **Consistencia** â†’ Los nombres y estructuras deben ser uniformes para facilitar su uso.  

ğŸ”¹ **Ejemplo (kotlinx-datetime)**:

```kotlin
val now: Instant = Clock.System.now()
val localDateTime = now.toLocalDateTime(TimeZone.UTC)
```

<Explanation>
    - `Clock.System.now()` modela de forma explÃ­cita el concepto de "tiempo actual" desde un reloj del sistema.
    - `toLocalDateTime` deja claro que estamos convirtiendo un `Instant` a una fecha local, y exige que se indique la `TimeZone`, lo que evita ambigÃ¼edad.
    - La API evita nombres genÃ©ricos como `convert` o `getTime`, y utiliza nombres que **describen con precisiÃ³n la transformaciÃ³n o propÃ³sito**.
</Explanation>

:::tip Resultado

Esta API modela el dominio del tiempo y las zonas horarias de forma clara y predecible, lo que facilita su uso correcto y evita errores comunes como la omisiÃ³n de zonas horarias.

:::

#### ğŸ”’ 2. Ocultar Detalles de ImplementaciÃ³n  

Una API debe **esconder los detalles internos**, permitiendo modificaciones sin afectar a quienes la utilizan.  

âœ”ï¸ **EncapsulaciÃ³n** â†’ Expone solo lo necesario mediante mÃ©todos pÃºblicos.  
âœ”ï¸ **Interfaz clara** â†’ Permite interactuar con la API sin conocer su implementaciÃ³n interna.  
âœ”ï¸ **SeparaciÃ³n de preocupaciones** â†’ Divide la API en mÃ³dulos bien definidos.  

ğŸ”¹ **Ejemplo real: [Ktor (Kotlin)](https://github.com/ktorio/ktor)**

```kotlin
val client = HttpClient()
val response: HttpResponse = client.get("https://lufia-api.example.com/ancient-cave/floor/20")

println(response.status)
println(response.bodyAsText())
```

<Explanation>
    Este ejemplo demuestra cÃ³mo Ktor aplica el principio de ocultar detalles de implementaciÃ³n:

    - **EncapsulaciÃ³n**: Clases como `HttpClient`, `HttpResponse` o `HttpRequestBuilder` exponen una interfaz limpia. Internamente, Ktor utiliza mÃºltiples mÃ³dulos y clases con `internal` o `private` para proteger su lÃ³gica de serializaciÃ³n, construcciÃ³n de solicitudes, manejo de errores, etc.
    - **Interfaz clara**: El usuario interactÃºa con funciones como `get()` o `bodyAsText()` sin necesidad de conocer cÃ³mo se gestiona la conexiÃ³n, el parseo del cuerpo o los encabezados HTTP.
    - **SeparaciÃ³n de preocupaciones**: Ktor divide su funcionalidad en mÃ³dulos (`client-core`, `client-json`, `client-logging`, etc.). Cada uno cumple una funciÃ³n especÃ­fica y puede ser intercambiado o desactivado sin modificar el resto de la API pÃºblica.
</Explanation>

:::tip Resultado

Ktor permite construir clientes HTTP modulares con una interfaz sencilla, mientras oculta detalles como la serializaciÃ³n, el manejo de errores o la infraestructura de conexiÃ³n. Puedes pedir los datos del *Ancient Cave* sin saber si fueron obtenidos por sockets, corutinas o magia de Artea.

:::

#### âš–ï¸ 3. DiseÃ±o Basado en la Simplicidad

> *"Cada elemento pÃºblico en tu API es una promesa: una promesa de que soportarÃ¡s esa funcionalidad por toda la vida de la API."*  
> â€” *Reddy, 2011*  

Una API debe ser **lo mÃ¡s pequeÃ±a posible** para facilitar su mantenimiento y comprensiÃ³n.

âœ”ï¸ **Simplicidad** â†’ Reduce el nÃºmero de elementos pÃºblicos.  
âœ”ï¸ **Evita duplicaciÃ³n (DRY)** â†’ No repitas funcionalidades.  
âœ”ï¸ **Principio de responsabilidad Ãºnica** â†’ Cada componente debe tener **una Ãºnica responsabilidad**.

ğŸ”¹ **Ejemplo real: [Lodash (JavaScript)](https://github.com/lodash/lodash)**

Â¡Claro! AquÃ­ tienes el ejemplo adaptado con datos del universo de **Durarara!!**, manteniendo la claridad del ejemplo original y alineado con los principios de simplicidad, no duplicaciÃ³n y responsabilidad Ãºnica:

```javascript
import _ from 'lodash';

const characters = [
  { name: "Celty", alias: "The Headless Rider" },
  { name: "Shizuo", alias: "The Strongest Man in Ikebukuro" },
  { name: "Izaya", alias: "Information Broker" }
];

const names = _.map(characters, "name");

console.log(names); // ["Celty", "Shizuo", "Izaya"]
```

<Explanation>

Este ejemplo refleja cÃ³mo Lodash promueve un diseÃ±o basado en la simplicidad:

- **Simplicidad**: `_.map()` permite extraer un campo con solo pasar el nombre de la propiedad, sin necesidad de definir una funciÃ³n personalizada para cada caso.
- **No duplicaciÃ³n (DRY)**: Evita que cada extracciÃ³n de nombres se haga con lÃ³gica repetida como `characters.map(c => c.name)`, promoviendo reutilizaciÃ³n.
- **Responsabilidad Ãºnica**: `_.map()` solo transforma cada elemento de la colecciÃ³n, delegando cualquier otra transformaciÃ³n o filtrado a funciones distintas como `_.filter`, `_.pick` o `_.sortBy`.

</Explanation>

:::tip Resultado

Lodash mantiene una API minimalista, coherente y reutilizable. Sus funciones hacen exactamente una cosa y la hacen bien â€” siguiendo el espÃ­ritu de *menos es mÃ¡s*.

:::

#### ğŸ› ï¸ 4. FÃ¡cil de Usar y DifÃ­cil de Usar Incorrectamente  

âœ”ï¸ **Intuitiva** â†’ El uso de la API debe ser evidente con solo ver los nombres de los mÃ©todos.  
âœ”ï¸ **DifÃ­cil de usar mal** â†’ DiseÃ±ada para prevenir errores comunes.  
âœ”ï¸ **Evita abreviaciones y siglas confusas** â†’ Usa nombres descriptivos y estÃ¡ndar.  

ğŸ”¹ **Ejemplo (Kotlin)**:  
```kotlin
fun sendEmail(to: String, subject: String, body: String) { /* ... */ }
```
ğŸ“Œ **Mala prÃ¡ctica**:  
```kotlin
fun sndMl(addr: String, subj: String, txt: String) { /* ??? */ }
```
ğŸ“Œ **Buena prÃ¡ctica**: Usa nombres claros como `sendEmail()` en lugar de `sndMl()`.  

#### ğŸ”— 5. CohesiÃ³n Alta y Bajo Acoplamiento  

âœ”ï¸ **Alta cohesiÃ³n** â†’ Un mÃ³dulo debe centrarse en **una sola tarea**.  
âœ”ï¸ **Bajo acoplamiento** â†’ Los componentes deben poder cambiar sin afectar a otros.  

ğŸ”¹ **Ejemplo (Kotlin - SeparaciÃ³n de MÃ³dulos)**:  
```kotlin
class AuthService {
    fun login(user: String, pass: String): Boolean { /* ... */ }
}

class UserProfile {
    fun loadProfile(user: String): User { /* ... */ }
}
```
ğŸ“Œ **Buena prÃ¡ctica**: `AuthService` gestiona autenticaciÃ³n, mientras `UserProfile` maneja perfiles.  

#### ğŸ” 6. Estabilidad, DocumentaciÃ³n y Pruebas  

âœ”ï¸ **Estabilidad** â†’ Usa versionado y evita cambios incompatibles.  
âœ”ï¸ **DocumentaciÃ³n** â†’ Explica la API con ejemplos claros.  
âœ”ï¸ **Pruebas** â†’ La API debe contar con **tests automatizados**.  

ğŸ”¹ **Ejemplo (Kotlin - DeprecaciÃ³n de MÃ©todos Viejos)**:  
```kotlin
@Deprecated("Use sendSecureEmail instead", ReplaceWith("sendSecureEmail(to, subject, body)"))
fun sendEmail(to: String, subject: String, body: String) { /* ... */ }
```
ğŸ“Œ **Buena prÃ¡ctica**: Indica claramente quÃ© mÃ©todo reemplaza al obsoleto.  

ğŸ”¹ **Ejemplo (Kotlin - Prueba Unitaria con Kotest)**:  
```kotlin
import io.kotest.core.spec.style.StringSpec
import io.kotest.matchers.shouldBe

class AuthServiceTest : StringSpec({
    "should return true when credentials are valid" {
        val auth = AuthService()
        auth.login("user", "password") shouldBe true
    }
})
```
ğŸ“Œ **Buena prÃ¡ctica**: Las pruebas aseguran la estabilidad de la API a largo plazo.  

---

Una API bien diseÃ±ada no solo facilita su uso, sino que tambiÃ©n mejora la **modularidad, mantenibilidad y seguridad** del software. Al aplicar estos principios:  

âœ… **Modela el problema** de forma clara.  
âœ… **Oculta detalles innecesarios** y favorece la encapsulaciÃ³n.  
âœ… **Prioriza la simplicidad** y evita agregar funciones innecesarias.  
âœ… **Es intuitiva** y **difÃ­cil de usar mal**.  
âœ… **Promueve cohesiÃ³n alta y bajo acoplamiento**.  
âœ… **Garantiza estabilidad** con documentaciÃ³n y pruebas.  

Si sigues estas prÃ¡cticas, tu API serÃ¡ mÃ¡s eficiente, fÃ¡cil de mantener y adoptada con mayor rapidez por otrxs desarrolladorxs. ğŸš€

## ğŸ“š Â¿QuÃ© es una biblioteca de software?

Una **biblioteca** es un conjunto de funciones, clases y herramientas reutilizables que facilitan tareas comunes en el desarrollo de software. Permiten a quienes desarrollan escribir menos cÃ³digo, mejorar la modularidad y evitar la repeticiÃ³n de lÃ³gica.

Ejemplos:
- **NumPy** (Python) â†’ ComputaciÃ³n cientÃ­fica.
- **Lodash** (JavaScript) â†’ ManipulaciÃ³n de arrays y objetos.
- **Guava** (Java) â†’ Colecciones avanzadas y utilidades.

### ğŸ” Diferencias entre una biblioteca y una aplicaciÃ³n

| ğŸ“Œ CaracterÃ­stica   | ğŸ“š Bibliotecas | ğŸ–¥ï¸ Aplicaciones |
|--------------------|--------------|---------------|
| **Finalidad**      | Proveer funcionalidades reutilizables | Resolver un problema especÃ­fico |
| **Ejecutables**    | âŒ No pueden ejecutarse por sÃ­ solas | âœ… Pueden ejecutarse de forma independiente |
| **InteracciÃ³n**    | API para desarrolladorxs | Interfaz para usuarixs (UI/CLI) |
| **Ejemplos**       | NumPy, Guava, Boost | Chrome, Photoshop, IntelliJ |

### ğŸ—ï¸ Principios de DiseÃ±o de Bibliotecas

Para que una biblioteca sea efectiva, debe cumplir con ciertos principios de diseÃ±o.

#### ğŸ›ï¸ 1. Interfaces Simples y Coherentes

âœ”ï¸ **API fÃ¡cil de usar** â†’ Debe ser intuitiva sin necesidad de leer documentaciÃ³n extensa.  
âœ”ï¸ **Consistencia** â†’ Uso uniforme de nombres y estructuras.

```kotlin
// âŒ Inconsistente (nombres y orden de parÃ¡metros diferentes)
parseJSON(validate = true, "data.json")
readXml("data.xml", validate = true)

// âœ… Consistente (sigue un mismo patrÃ³n)
Parser.json("data.json", validate = true)
Parser.xml("data.xml", validate = true)
```

#### ğŸ”’ 2. EncapsulaciÃ³n y Ocultamiento de ImplementaciÃ³n

âœ”ï¸ **Solo exponer lo necesario** â†’ Los detalles internos deben estar ocultos.  
âœ”ï¸ **Modularidad** â†’ Cada parte de la biblioteca debe ser independiente.

```kotlin
class Database private constructor() {
    private val connection = connectToDatabase() // ğŸ”’ Oculto

    fun query(sql: String): ResultSet = connection.executeQuery(sql)

    companion object {
        fun create(): Database = Database()
    }
}
```
ğŸ“Œ **El usuario solo interactÃºa con `query()` sin preocuparse por la conexiÃ³n interna.**

#### âš–ï¸ 3. CohesiÃ³n y Bajo Acoplamiento

âœ”ï¸ **Alta cohesiÃ³n** â†’ Cada mÃ³dulo debe hacer una sola cosa bien.  
âœ”ï¸ **Bajo acoplamiento** â†’ Los cambios en una parte no deben afectar otras.

```kotlin
// âŒ Mal diseÃ±o: la clase maneja tanto autenticaciÃ³n como validaciÃ³n de datos.
class AuthService {
    fun login(user: String, pass: String) { /*...*/ }
    fun isValidEmail(email: String): Boolean { /*...*/ }
}

// âœ… Buen diseÃ±o: separaciÃ³n de responsabilidades.
class AuthService { fun login(user: String, pass: String) { /*...*/ } }
class Validator { fun isValidEmail(email: String): Boolean { /*...*/ } }
```


### ğŸ”¥ Ejemplos de Bibliotecas Populares

#### 1ï¸âƒ£ Lodash (JavaScript) â€“ Utilidades para Arrays y Objetos

ğŸ“Œ **Facilita la manipulaciÃ³n de datos en JavaScript.**
```typescript
import _ from 'lodash';
const numbers = [1, 2, 3, 4, 5];
console.log(_.chunk(numbers, 2)); // [[1, 2], [3, 4], [5]]
```

#### 2ï¸âƒ£ NumPy (Python) â€“ ComputaciÃ³n NumÃ©rica

ğŸ“Œ **Optimiza operaciones matemÃ¡ticas con arrays y matrices.**
```python
import numpy as np
a = np.array([1, 2, 3])
b = np.array([4, 5, 6])
print(np.dot(a, b))  # Output: 32
```

#### 3ï¸âƒ£ Guava (Java) â€“ Colecciones y Utilidades

ğŸ“Œ **Extiende las capacidades estÃ¡ndar de Java con estructuras de datos avanzadas.**
```java
Multimap<String, String> multimap = ArrayListMultimap.create();
multimap.put("fruit", "apple");
multimap.put("fruit", "banana");
System.out.println(multimap); // {fruit=[apple, banana]}
```

#### 4ï¸âƒ£ Boost (C++) â€“ Extensiones para C++

ğŸ“Œ **Proporciona herramientas avanzadas para manipulaciÃ³n de datos.**

```cpp
#include <boost/algorithm/string.hpp>
std::string str = "Hello Boost";
boost::to_upper(str);
std::cout << str;  // Output: HELLO BOOST
```

#### 5ï¸âƒ£ Arrow (Kotlin) â€“ ProgramaciÃ³n Funcional

ğŸ“Œ **Simplifica el manejo de errores y estructuras de datos inmutables.**

```kotlin
import arrow.core.*

fun divide(a: Int, b: Int): Either<String, Int> =
    if (b == 0) "Cannot divide by zero".left() else (a / b).right()

println(divide(4, 2))  // Output: Right(2)
```

## ğŸ“Œ Conclusiones

El desarrollo de bibliotecas de software es un componente esencial en la creaciÃ³n de herramientas reutilizables y eficientes. A lo largo de este artÃ­culo, exploramos los principios clave para diseÃ±ar **APIs efectivas**, asegurando que sean intuitivas, flexibles y fÃ¡ciles de mantener.  

### ğŸš€ Puntos Clave

1. **Las bibliotecas facilitan la reutilizaciÃ³n de cÃ³digo y la modularidad**, evitando la duplicaciÃ³n innecesaria y mejorando la productividad.  
2. **Una API bien diseÃ±ada debe ser clara, coherente y difÃ­cil de usar incorrectamente**, siguiendo principios como encapsulaciÃ³n, cohesiÃ³n y bajo acoplamiento.  
3. **La simplicidad es clave**: una API debe ser lo mÃ¡s pequeÃ±a posible, exponiendo solo las funcionalidades esenciales sin introducir complejidad innecesaria.  
4. **Ocultar detalles internos mejora la mantenibilidad**: una API debe proporcionar una interfaz estable y separar las preocupaciones para evitar dependencias rÃ­gidas.  
5. **Las pruebas y la documentaciÃ³n son esenciales**: una API debe estar respaldada por **pruebas automatizadas** y contar con documentaciÃ³n clara que incluya ejemplos de uso.  
6. **Las bibliotecas populares como NumPy, Lodash, Guava y Arrow demuestran estos principios en la prÃ¡ctica**, mostrando cÃ³mo se pueden aplicar en diferentes lenguajes de programaciÃ³n.  

### ğŸ† **ReflexiÃ³n Final**  

El diseÃ±o de bibliotecas de software va mÃ¡s allÃ¡ de simplemente escribir cÃ³digo reutilizable. Implica tomar decisiones cuidadosas sobre la **estructura, la API expuesta y la experiencia de quienes la usan**. Aplicando estos principios, podemos desarrollar bibliotecas **eficientes, confiables y escalables**, que no solo resuelvan problemas tÃ©cnicos, sino que tambiÃ©n sean adoptadas y valoradas por la comunidad.  

Siguiendo estas buenas prÃ¡cticas, puedes construir **bibliotecas robustas y mantenibles**, asegurando que sean herramientas Ãºtiles a largo plazo.

<References references={[
    {
        "title": "Introduction",
        "bookTitle": "API Design for C++",
        "pages": "1â€“24",
        "location": "Amsterdam Heidelberg",
        "year": "2011",
        "type": "book"
    },
    {
        "title": "Qualities",
        "bookTitle": "API Design for C++",
        "pages": "25â€“80",
        "location": "Amsterdam Heidelberg",
        "year": "2011",
        "type": "book"
    },
]}/>
