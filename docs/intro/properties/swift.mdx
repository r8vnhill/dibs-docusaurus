---
title: Propiedades en Swift
---
import {Cons, ProCons, Pros} from "../../../src/components/cajitas/ProCons";
import References from "/src/components/ReferencesComponent";
import ReadingTime from '/src/components/ReadingTime';
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'
import BoxedTabs from '@site/src/components/cajitas/BoxedTabs'

<ReadingTime/>

En Swift, las propiedades combinan el comportamiento de variables con m√©todos **getter** y **setter**, al igual que en Kotlin. Sin embargo, Swift introduce algunas caracter√≠sticas √∫nicas como **observadores de propiedades** y una mayor flexibilidad en **propiedades `lazy`**, lo que lo diferencia del enfoque de Kotlin.

## üì¶ Propiedades Almacenadas y Computadas

Swift distingue entre **propiedades almacenadas** y **propiedades computadas**. Las propiedades almacenadas funcionan como las propiedades est√°ndar de Kotlin, donde se guarda un valor espec√≠fico. Las propiedades computadas, por otro lado, no almacenan un valor, sino que proporcionan un c√°lculo cada vez que se accede a ellas, muy parecido a lo que Kotlin hace con las **propiedades calculadas**. Sin embargo, en Swift no es necesario declarar un `getter` expl√≠cito si la propiedad es de solo lectura, lo que simplifica la sintaxis en comparaci√≥n con Kotlin.

<BoxedTabs>
    <TabItem label={"C√≥digo esencial"} value={"C√≥digo esencial"}>
        ```swift showLineNumbers
        struct Rectangle {
            var width: Double
            var height: Double

            var area: Double {
                return width * height
            }
        }
        ```
    </TabItem>
    <TabItem label={"C√≥digo completo"} value={"C√≥digo completo"}>
        ```swift showLineNumbers
        struct Rectangle {
            var width: Double
            var height: Double

            var area: Double {
                return width * height
            }
        }

        let rect = Rectangle(width: 5.0, height: 10.0)
        print("√Årea: \(rect.area)")       // Output: √Årea: 50.0
        ```
    </TabItem>
</BoxedTabs>

:::info Explicaci√≥n del C√≥digo

- **[2-3]**: Propiedades Almacenadas (`width` y `height`)**: Estas propiedades guardan un valor espec√≠fico que se puede leer o modificar directamente.
- **[5-7]**: Propiedad Computada (`area`): Calcula el valor bas√°ndose en las otras propiedades (`width` y `height`) cada vez que se accede a ella. No guarda un valor en s√≠ misma.

:::

## üëÄ Observadores de Propiedades

Otro aspecto distintivo de Swift es el uso de **observadores de propiedades**, conocidos como **`willSet`** y **`didSet`**, que permiten ejecutar c√≥digo autom√°ticamente antes o despu√©s de que se actualice el valor de una propiedad. En Kotlin, no existe un equivalente directo, pero se pueden personalizar los `getter` y `setter` para modificar el comportamiento del acceso a la propiedad. Sin embargo, estos no permiten reaccionar autom√°ticamente a los cambios como en Swift.

<BoxedTabs>
<TabItem label={"C√≥digo esencial"} value={"C√≥digo esencial"}>
```swift showLineNumbers
class Temperature {
    var celsius: Double {
        willSet(newTemperature) {
            print("La temperatura va a cambiar de \(celsius)¬∞C a \(newTemperature)¬∞C")
        }
        didSet {
            print("La temperatura cambi√≥ de \(oldValue)¬∞C a \(celsius)¬∞C")
        }
    }
}
```
</TabItem>
<TabItem label={"C√≥digo completo"} value={"C√≥digo completo"}>
```swift showLineNumbers
class Temperature {
    var celsius: Double {
        willSet(newTemperature) {
            print("La temperatura va a cambiar de \(celsius)¬∞C a \(newTemperature)¬∞C")
        }
        didSet {
            print("La temperatura cambi√≥ de \(oldValue)¬∞C a \(celsius)¬∞C")
        }
    }

    init(celsius: Double) {
        self.celsius = celsius
    }
}

let temp = Temperature(celsius: 25.0)
temp.celsius = 30.0
```
</TabItem>
</BoxedTabs>

:::info Explicaci√≥n del C√≥digo

- **[3-5]** `willSet`: Se ejecuta justo antes de que el valor de la propiedad cambie. Recibe como par√°metro el nuevo valor (`newTemperature`).
- **[6-8]** `didSet`: Se ejecuta inmediatamente despu√©s de que el valor haya cambiado. El valor anterior se puede acceder a trav√©s de `oldValue`.
- Este comportamiento autom√°tico de observaci√≥n es una ventaja de Swift en comparaci√≥n con Kotlin.

:::

### üîÑ Diferencia con Kotlin

En Kotlin, los `getter` y `setter` permiten personalizar el acceso y la modificaci√≥n de las propiedades, pero no reaccionan autom√°ticamente a los cambios como los observadores de Swift. Para lograr un comportamiento similar, Kotlin ofrece `Delegates.observable`.

<details>
    <summary>Propiedades Observables en Kotlin</summary>

    En Kotlin, aunque no hay un equivalente directo a `willSet` y `didSet`, se pueden lograr comportamientos similares utilizando **`Delegates.observable`**, que permite ejecutar c√≥digo cada vez que cambia el valor de una propiedad.

    ```kotlin showLineNumbers
    import kotlin.properties.Delegates

    class Temperature {
        var celsius: Double by Delegates.observable(25.0) { property, oldValue, newValue ->
            println("La temperatura cambi√≥ de $oldValue¬∞C a $newValue¬∞C")
        }
    }
    ```

    üìå **Diferencias clave con Swift:**
    - En Kotlin, `Delegates.observable` solo reacciona **despu√©s** de que el valor cambie, por lo que no hay un equivalente exacto a `willSet`.
    - Mientras `willSet` y `didSet` funcionan en **clases y estructuras** en Swift, `Delegates.observable` solo se puede usar en **clases** en Kotlin.
    - No es compatible con `data class` con `copy()`, ya que los delegados no se copian autom√°ticamente.

</details>

## üí§ Propiedades `lazy`

Swift permite definir **propiedades `lazy`**, que se inicializan solo la primera vez que se acceden. Esto es √∫til para optimizar recursos, especialmente cuando el c√°lculo inicial es costoso. Kotlin tambi√©n ofrece propiedades `lazy`, pero con una diferencia importante: en Kotlin, `lazy` **solo puede aplicarse a propiedades `val` inmutables**, mientras que en Swift se puede usar con `var`, permitiendo modificar su valor despu√©s de la inicializaci√≥n.

### Lazy en Swift

<BoxedTabs>
    <TabItem label={"C√≥digo esencial"} value={"C√≥digo esencial"}>
        ```swift showLineNumbers
        class Person {
            lazy var greeting: String = {
                print("Generando saludo...")
                return "Hello, \(self.name)"
            }()
        }
        ```
    </TabItem>
    <TabItem label={"C√≥digo completo"} value={"C√≥digo completo"}>
        ```swift showLineNumbers
        class Person {
            var name: String
            lazy var greeting: String = {
                print("Generando saludo...")
                return "Hello, \(self.name)"
            }()

            init(name: String) {
                self.name = name
            }
        }

        let person = Person(name: "John")
        print(person.greeting)  // "Generando saludo..." seguido de "Hello, John"
        print(person.greeting)  // Solo "Hello, John"
        ```
    </TabItem>
</BoxedTabs>

:::info Explicaci√≥n del C√≥digo

- **[2]**: Se declara una propiedad `lazy` llamada `greeting`, que solo se inicializa la primera vez que se accede.
- **[2-5]**: La propiedad `greeting` usa una *closure* para construir el valor inicial, lo que permite usar la propiedad `name` de la instancia.
- Cuando se accede a `greeting` por primera vez, la *closure* se ejecuta, generando y devolviendo el saludo.
- En accesos posteriores, se reutiliza el valor calculado previamente.
- Como `greeting` es un **`var`**, se podr√≠a reasignar un nuevo valor m√°s adelante si fuera necesario.

:::

### Lazy en Kotlin

<BoxedTabs>
<TabItem label={"C√≥digo esencial"} value={"C√≥digo esencial"}>
```kotlin showLineNumbers
class Person(val name: String) {
    val greeting: String by lazy {
        println("Generando saludo...")
        "Hello, $name"
    }
}
```
</TabItem>
<TabItem label={"C√≥digo completo"} value={"C√≥digo completo"}>
```kotlin showLineNumbers
class Person(val name: String) {
    val greeting: String by lazy {
        println("Generando saludo...")
        "Hello, $name"
    }
}

fun main() {
    val person = Person("John")
    println(person.greeting)  // "Generando saludo..." seguido de "Hello, John"
    println(person.greeting)  // Solo "Hello, John"
}
```
</TabItem>
</BoxedTabs>

:::info Explicaci√≥n del C√≥digo

- **[2]**: En Kotlin, `lazy` se usa con `val`, lo que significa que la propiedad es inmutable despu√©s de la inicializaci√≥n.
- **[2-5]**: La inicializaci√≥n diferida ocurre solo cuando `greeting` se accede por primera vez.
- En accesos posteriores, el valor calculado previamente se reutiliza.
- A diferencia de Swift, no se puede reasignar `greeting`, ya que `lazy` solo funciona con `val`.

:::

## üìä Comparaci√≥n Final

| **Caracter√≠stica**                          | **Swift**                                                                                                         | **Kotlin**                                                                                                        |
|---------------------------------------------|-------------------------------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------------------------|
| **Propiedades Almacenadas y Computadas**    | Soporta **propiedades almacenadas** (valores directos) y **propiedades computadas** (c√°lculos sin almacenamiento). | Permite **propiedades calculadas**, pero requieren un `getter` expl√≠cito, incluso si son de solo lectura.        |
| **Observadores de Propiedades**             | Usa `willSet` y `didSet` para reaccionar antes y despu√©s de modificar una propiedad.                              | No tiene un equivalente directo, pero se pueden usar `Delegates.observable` o personalizar `getter` y `setter`.  |
| **Delegados de Propiedades**                | No hay un sistema nativo de delegados como en Kotlin.                                                             | Soporta delegados como `Delegates.observable` y `Delegates.vetoable`.                                             |
| **Propiedades `lazy`**                      | Se pueden definir con `lazy var` y se inicializan solo en la primera llamada. **Pueden ser mutables (`var`)**.    | `lazy` solo puede aplicarse a `val` inmutables. La inicializaci√≥n se ejecuta solo una vez en el primer acceso.   |
| **Inmutabilidad**                           | Se usa `let` para propiedades inmutables y `var` para mutables.                                                   | Se usa `val` para propiedades inmutables y `var` para mutables.                                                   |
| **Compatibilidad con Estructuras (`struct`)** | `struct` en Swift admite propiedades computadas y observadores (`willSet` / `didSet`).                            | `data class` en Kotlin permite propiedades calculadas con `getter`, pero los observables no funcionan con `copy()`. |
| **Personalizaci√≥n del Acceso**              | Se pueden definir `getter` y `setter` personalizados.                                                              | Se pueden definir `getter` y `setter` personalizados, pero no reaccionan autom√°ticamente como en Swift.          |

### ‚úÖ Beneficios y ‚ùå Limitaciones

<ProCons>
    <Pros>
        - **Mayor flexibilidad en Swift con propiedades `lazy`**: En Swift, las propiedades `lazy` pueden ser `var`, lo que permite modificar su valor despu√©s de la inicializaci√≥n, mientras que en Kotlin solo pueden ser `val`.
        - **Observadores de propiedades (`willSet` / `didSet`) en Swift**: Permiten ejecutar c√≥digo autom√°ticamente antes y despu√©s de modificar una propiedad sin necesidad de crear un setter personalizado.
        - **C√≥digo m√°s conciso en propiedades computadas en Swift**: No requieren `getter` expl√≠cito si son de solo lectura, lo que simplifica la sintaxis.
        - **Soporte de observadores en `struct` en Swift**: A diferencia de Kotlin, donde las `data class` tienen limitaciones en la copia de delegados, Swift permite observadores en estructuras (`struct`).
    </Pros>
    <Cons>
        - **No hay delegados de propiedades en Swift**: A diferencia de Kotlin, Swift no tiene un mecanismo nativo de delegados de propiedades reutilizables, lo que obliga a definir `getter` y `setter` personalizados si se necesita l√≥gica avanzada.
        - **Mayor complejidad con observadores en Swift**: Aunque `willSet` y `didSet` son √∫tiles, pueden agregar l√≥gica innecesaria dentro de una propiedad, lo que puede dificultar el mantenimiento del c√≥digo.
    </Cons>
</ProCons>

## üéØ Conclusiones

En esta comparaci√≥n entre las propiedades en **Swift** y **Kotlin**, hemos explorado las diferencias clave en su manejo y funcionalidades. Ambas tecnolog√≠as ofrecen herramientas poderosas para la gesti√≥n de propiedades, pero con enfoques distintos en t√©rminos de flexibilidad, sintaxis y personalizaci√≥n.

### üîë Puntos clave

- **Propiedades computadas en Swift son m√°s concisas**: No requieren un `getter` expl√≠cito si son de solo lectura, mientras que en Kotlin siempre es necesario definirlo.  
- **Swift permite observadores (`willSet` y `didSet`) para reaccionar autom√°ticamente a cambios en una propiedad**, mientras que en Kotlin no existe un equivalente directo, aunque `Delegates.observable` ofrece una alternativa similar con algunas limitaciones.  
- **Los delegados en Kotlin aportan m√°s reutilizaci√≥n**: Swift no tiene un sistema de delegados nativo para propiedades, lo que puede hacer que la reutilizaci√≥n de l√≥gica sea menos conveniente.  
- **Mayor flexibilidad en `lazy` en Swift**: Se pueden definir como `var`, lo que permite modificarlas despu√©s de la inicializaci√≥n, a diferencia de Kotlin, donde `lazy` solo puede usarse con `val`.  
- **Diferencias en compatibilidad con estructuras**: Swift permite observadores de propiedades en `struct`, mientras que en Kotlin, `data class` tiene ciertas limitaciones con `copy()` y los delegados de propiedades.  

### üí° Reflexi√≥n final
 
Swift y Kotlin ofrecen formas eficientes de manejar propiedades, pero con diferencias significativas en la flexibilidad y el nivel de abstracci√≥n.  

- **Swift** prioriza la simplicidad con **propiedades computadas sin `getter` expl√≠cito** y **observadores nativos (`willSet` y `didSet`)**, lo que hace que el c√≥digo sea m√°s conciso y f√°cil de leer.  
- **Kotlin**, por otro lado, apuesta por la **reutilizaci√≥n y extensibilidad** con su sistema de **delegados de propiedades**, que permite implementar l√≥gica compartida de manera eficiente.  

Si buscas un enfoque m√°s estructurado con delegados reutilizables, **Kotlin es una mejor opci√≥n**. Sin embargo, si prefieres una sintaxis m√°s concisa y una **mayor integraci√≥n de observadores en el lenguaje**, **Swift ofrece herramientas m√°s directas para la manipulaci√≥n de propiedades**.

<References references={[
    {
        title: "¬øQu√© son las propiedades computadas en Swift y c√≥mo usarlas?",
        url: "https://keepcoding.io/blog/que-son-propiedades-computadas-en-swift/",
        type: "article",
        author: "Bustos, J. L.",
        publishedDate: "31 de octubre de 2024",
    },
    // √öltimo acceso: ???
]} additionalReferences={[
    
]}/>
