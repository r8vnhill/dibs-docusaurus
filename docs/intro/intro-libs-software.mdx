---
title: Fundamentos del diseÃ±o de bibliotecas de software
sidebar_label: DiseÃ±o de Bibliotecas
---
import ReadingTime from '@site/src/components/ReadingTime'
import { ProCons, Pros, Cons } from '@site/src/components/cajitas/ProCons'
import References from '@site/src/components/ReferencesComponent'
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'
import Exercise from '@site/src/components/exercise/Exercise'
import Solution from '@site/src/components/exercise/Solution'
import Hint from '@site/src/components/exercise/Hint'
import Definition from '@site/src/components/Definition'
import Corollary from '@site/src/components/Corollary'
import GithubRepoLink from '@site/src/components/GithubRepoLink'
import { LanguageCard } from '@site/src/components/cards/LanguageCard'
import Explanation from '@site/src/components/admonitions/Explanation'
import RepoClone from '@site/src/components/admonitions/RepoClone'
import ModuleSetup from '@site/src/components/cajitas/ModuleSetup'
import BoxedTabs from '@site/src/components/cajitas/BoxedTabs'

<ReadingTime />

El desarrollo de bibliotecas de software es fundamental para crear herramientas reutilizables que ayudan a otras aplicaciones y desarrolladorxs a resolver problemas comunes de forma eficiente. En lugar de reescribir lÃ³gica repetitiva en cada proyecto, las bibliotecas ofrecen **funcionalidades encapsuladas y optimizadas**, listas para integrarse en distintos entornos de desarrollo.

Desde cÃ¡lculos cientÃ­ficos hasta manipulaciÃ³n de datos, las bibliotecas estÃ¡n en el corazÃ³n del software moderno. **Algunos ejemplos ampliamente utilizados incluyen:**  

- ğŸ§® **NumPy** *(Python)*: estructuras y operaciones optimizadas para cÃ¡lculos numÃ©ricos de alto rendimiento.  
- ğŸ“¦ **Lodash** *(JavaScript)*: utilidades para manipular arreglos, objetos y funciones.  
- âš¡ **Arrow** *(Kotlin)*: soporte para programaciÃ³n funcional y gestiÃ³n segura de errores con estructuras como `Either` y `Validated`.  
- ğŸ”— **Boost** *(C++)*: extensiones al lenguaje con estructuras avanzadas y herramientas de concurrencia.

Cada una de estas bibliotecas muestra cÃ³mo un buen diseÃ±o de API, combinado con una implementaciÃ³n eficiente, puede **reducir la complejidad**, **mejorar la productividad** y **fomentar la reutilizaciÃ³n**.

En esta lecciÃ³n, exploraremos los principios esenciales del diseÃ±o de bibliotecas de software, junto con **buenas prÃ¡cticas para construir APIs efectivas, claras y fÃ¡ciles de adoptar**. Veremos cÃ³mo se aplican estos conceptos en bibliotecas reales, desde **JavaScript hasta Kotlin**.

## ğŸ”— APIs: La Base del Desarrollo de Software Moderno

Una **API** (*Application Programming Interface*) es un conjunto de reglas y herramientas que define cÃ³mo interactuar con una biblioteca o sistema. ActÃºa como un **bloque de construcciÃ³n reutilizable**, permitiendo que aplicaciones y desarrolladorxs agreguen funcionalidades de manera eficiente y estandarizada.  

Las APIs son esenciales en el desarrollo moderno de software y suelen proporcionarse mediante **bibliotecas**, como **NumPy** para cÃ¡lculos numÃ©ricos en Python o **Lodash** para manipulaciÃ³n de datos en JavaScript.

### âœ… CaracterÃ­sticas de una Buena API

#### ğŸ¯ 1. Modelar el Problema Correctamente  

Una API bien diseÃ±ada debe proporcionar una **abstracciÃ³n clara y efectiva** del problema que resuelve.  

âœ”ï¸ **PropÃ³sito claro** â†’ Cada funciÃ³n, clase y variable debe estar bien definida.  
âœ”ï¸ **Consistencia** â†’ Los nombres y estructuras deben ser uniformes para facilitar su uso.  

ğŸ”¹ **Ejemplo real: [kotlinx-datetime (Kotlin)](https://github.com/Kotlin/kotlinx-datetime)**

```kotlin
val now: Instant = Clock.System.now()
val localDateTime = now.toLocalDateTime(TimeZone.UTC)
```

<Explanation>
    - `Clock.System.now()` modela de forma explÃ­cita el concepto de "tiempo actual" desde un reloj del sistema.
    - `toLocalDateTime` deja claro que estamos convirtiendo un `Instant` a una fecha local, y exige que se indique la `TimeZone`, lo que evita ambigÃ¼edad.
    - La API evita nombres genÃ©ricos como `convert` o `getTime`, y utiliza nombres que **describen con precisiÃ³n la transformaciÃ³n o propÃ³sito**.
</Explanation>

:::tip Resultado

Esta API modela el dominio del tiempo y las zonas horarias de forma clara y predecible, lo que facilita su uso correcto y evita errores comunes como la omisiÃ³n de zonas horarias.

:::

#### ğŸ”’ 2. Ocultar Detalles de ImplementaciÃ³n  

Una API debe **esconder los detalles internos**, permitiendo modificaciones sin afectar a quienes la utilizan.  

âœ”ï¸ **EncapsulaciÃ³n** â†’ Expone solo lo necesario mediante mÃ©todos pÃºblicos.  
âœ”ï¸ **Interfaz clara** â†’ Permite interactuar con la API sin conocer su implementaciÃ³n interna.  
âœ”ï¸ **SeparaciÃ³n de preocupaciones** â†’ Divide la API en mÃ³dulos bien definidos.  

ğŸ”¹ **Ejemplo real: [Ktor (Kotlin)](https://github.com/ktorio/ktor)**

```kotlin
val client = HttpClient()
val response: HttpResponse = client.get("https://lufia-api.example.com/ancient-cave/floor/20")

println(response.status)
println(response.bodyAsText())
```

<Explanation>
    Este ejemplo demuestra cÃ³mo Ktor aplica el principio de ocultar detalles de implementaciÃ³n:

    - **EncapsulaciÃ³n**: Clases como `HttpClient`, `HttpResponse` o `HttpRequestBuilder` exponen una interfaz limpia. Internamente, Ktor utiliza mÃºltiples mÃ³dulos y clases con `internal` o `private` para proteger su lÃ³gica de serializaciÃ³n, construcciÃ³n de solicitudes, manejo de errores, etc.
    - **Interfaz clara**: El usuario interactÃºa con funciones como `get()` o `bodyAsText()` sin necesidad de conocer cÃ³mo se gestiona la conexiÃ³n, el parseo del cuerpo o los encabezados HTTP.
    - **SeparaciÃ³n de preocupaciones**: Ktor divide su funcionalidad en mÃ³dulos (`client-core`, `client-json`, `client-logging`, etc.). Cada uno cumple una funciÃ³n especÃ­fica y puede ser intercambiado o desactivado sin modificar el resto de la API pÃºblica.
</Explanation>

:::tip Resultado

Ktor permite construir clientes HTTP modulares con una interfaz sencilla, mientras oculta detalles como la serializaciÃ³n, el manejo de errores o la infraestructura de conexiÃ³n. Puedes pedir los datos del *Ancient Cave* sin saber si fueron obtenidos por sockets, corutinas o magia de Artea.

:::

#### âš–ï¸ 3. DiseÃ±o Basado en la Simplicidad

> *"Cada elemento pÃºblico en tu API es una promesa: una promesa de que soportarÃ¡s esa funcionalidad por toda la vida de la API."*  
> â€” *Reddy, 2011*  

Una API debe ser **lo mÃ¡s pequeÃ±a posible** para facilitar su mantenimiento y comprensiÃ³n.

âœ”ï¸ **Simplicidad** â†’ Reduce el nÃºmero de elementos pÃºblicos.  
âœ”ï¸ **Evita duplicaciÃ³n (DRY)** â†’ No repitas funcionalidades.  
âœ”ï¸ **Principio de responsabilidad Ãºnica** â†’ Cada componente debe tener **una Ãºnica responsabilidad**.

ğŸ”¹ **Ejemplo real: [Lodash (JavaScript)](https://github.com/lodash/lodash)**

```javascript
import _ from 'lodash';

const characters = [
  { name: "Celty", alias: "The Headless Rider" },
  { name: "Shizuo", alias: "The Strongest Man in Ikebukuro" },
  { name: "Izaya", alias: "Information Broker" }
];

const names = _.map(characters, "name");

console.log(names); // ["Celty", "Shizuo", "Izaya"]
```

<Explanation>

Este ejemplo refleja cÃ³mo Lodash promueve un diseÃ±o basado en la simplicidad:

- **Simplicidad**: `_.map()` permite extraer un campo con solo pasar el nombre de la propiedad, sin necesidad de definir una funciÃ³n personalizada para cada caso.
- **No duplicaciÃ³n (DRY)**: Evita que cada extracciÃ³n de nombres se haga con lÃ³gica repetida como `characters.map(c => c.name)`, promoviendo reutilizaciÃ³n.
- **Responsabilidad Ãºnica**: `_.map()` solo transforma cada elemento de la colecciÃ³n, delegando cualquier otra transformaciÃ³n o filtrado a funciones distintas como `_.filter`, `_.pick` o `_.sortBy`.

</Explanation>

:::tip Resultado

Lodash mantiene una API minimalista, coherente y reutilizable. Sus funciones hacen exactamente una cosa y la hacen bien â€” siguiendo el espÃ­ritu de *menos es mÃ¡s*.

:::

#### ğŸ› ï¸ 4. FÃ¡cil de Usar y DifÃ­cil de Usar Incorrectamente  

âœ”ï¸ **Intuitiva** â†’ El uso de la API debe ser evidente con solo ver los nombres de los mÃ©todos.  
âœ”ï¸ **DifÃ­cil de usar mal** â†’ DiseÃ±ada para prevenir errores comunes.  
âœ”ï¸ **Evita abreviaciones y siglas confusas** â†’ Usa nombres descriptivos y estÃ¡ndar.  

ğŸ”¹ **Ejemplo real: [Datetime (Python)](https://docs.python.org/3/library/datetime.html)**

```python
from datetime import datetime, timedelta

now = datetime.now()
tomorrow = now + timedelta(days=1)

print(f"Hoy es {now.date()} y maÃ±ana serÃ¡ {tomorrow.date()}")
```

<Explanation>

La biblioteca estÃ¡ndar `datetime` de Python es un gran ejemplo de API bien diseÃ±ada:

- âœ… **Intuitiva**: Los nombres como `datetime.now()`, `timedelta`, y `date()` son autodescriptivos.  
- ğŸ”’ **DifÃ­cil de usar mal**: No puedes sumar dos fechas arbitrariamente. Solo puedes operar con tipos compatibles (`datetime + timedelta`), lo cual previene errores lÃ³gicos comunes.  
- ğŸ“š **Consistencia semÃ¡ntica**: Todos los nombres estÃ¡n bien definidos y siguen una lÃ³gica uniforme; no hay siglas innecesarias ni convenciones poco claras.

</Explanation>

:::tip Resultado

El diseÃ±o de `datetime` hace que trabajar con fechas y tiempos en Python sea directo y seguro. Gracias a su claridad y restricciones de tipos, es difÃ­cil cometer errores comunes como sumar dos fechas directamente o usar unidades inconsistentes.

:::

#### ğŸ”— 5. CohesiÃ³n Alta y Bajo Acoplamiento  

âœ”ï¸ **Alta cohesiÃ³n** â†’ Un mÃ³dulo debe centrarse en **una sola tarea**.  
âœ”ï¸ **Bajo acoplamiento** â†’ Los componentes deben poder cambiar sin afectar a otros.

ğŸ”¹ **Ejemplo real: [`serde`](https://serde.rs/), la biblioteca de serializaciÃ³n en Rust**

```rust
use serde::{Serialize, Deserialize};
use serde_json;

#[derive(Serialize, Deserialize, Debug)]
struct Character {
    name: String,
    level: u32,
}

fn main() {
    let json = r#"{"name":"Maxim","level":99}"#;
    let c: Character = serde_json::from_str(json).unwrap();
    println!("{:?}", c);
}
```

<Explanation>

La arquitectura de `serde` ejemplifica bien los principios de diseÃ±o:

- âœ… **Alta cohesiÃ³n**:  
  El nÃºcleo (`serde`) se enfoca exclusivamente en definir las abstracciones de serializaciÃ³n/deserializaciÃ³n. Otros crates (como `serde_json`, `serde_yaml`, `serde_cbor`) implementan esos conceptos para distintos formatos, sin mezclar responsabilidades.
- ğŸ”Œ **Bajo acoplamiento**:  
  Puedes cambiar de `serde_json` a `serde_yaml` sin modificar tu modelo de datos. Incluso puedes definir tus propios serializadores si necesitas un formato personalizado. La lÃ³gica de negocio y los datos estÃ¡n desacoplados de la lÃ³gica de formato.

</Explanation>

:::tip Resultado

El diseÃ±o modular de `serde` permite que sea adoptada ampliamente sin arrastrar dependencias innecesarias. Esta separaciÃ³n clara de responsabilidades ha convertido a `serde` en una de las bibliotecas mÃ¡s usadas y respetadas del ecosistema Rust.

:::

#### ğŸ” 6. Estabilidad, DocumentaciÃ³n y Pruebas  

âœ”ï¸ **Estabilidad** â†’ Usa versionado y evita cambios incompatibles.  
âœ”ï¸ **DocumentaciÃ³n** â†’ Explica la API con ejemplos claros.  
âœ”ï¸ **Pruebas** â†’ La API debe contar con **tests automatizados**.  

ğŸ”¹ **Ejemplo (Kotlin - DeprecaciÃ³n de MÃ©todos Viejos)**:  
```kotlin
@Deprecated("Use sendSecureEmail instead", ReplaceWith("sendSecureEmail(to, subject, body)"))
fun sendEmail(to: String, subject: String, body: String) { /* ... */ }
```
ğŸ“Œ **Buena prÃ¡ctica**: Indica claramente quÃ© mÃ©todo reemplaza al obsoleto.  

ğŸ”¹ **Ejemplo (Kotlin - Prueba Unitaria con Kotest)**:  
```kotlin
import io.kotest.core.spec.style.StringSpec
import io.kotest.matchers.shouldBe

class AuthServiceTest : StringSpec({
    "should return true when credentials are valid" {
        val auth = AuthService()
        auth.login("user", "password") shouldBe true
    }
})
```
ğŸ“Œ **Buena prÃ¡ctica**: Las pruebas aseguran la estabilidad de la API a largo plazo.  

---

Una API bien diseÃ±ada no solo facilita su uso, sino que tambiÃ©n mejora la **modularidad, mantenibilidad y seguridad** del software. Al aplicar estos principios:  

âœ… **Modela el problema** de forma clara.  
âœ… **Oculta detalles innecesarios** y favorece la encapsulaciÃ³n.  
âœ… **Prioriza la simplicidad** y evita agregar funciones innecesarias.  
âœ… **Es intuitiva** y **difÃ­cil de usar mal**.  
âœ… **Promueve cohesiÃ³n alta y bajo acoplamiento**.  
âœ… **Garantiza estabilidad** con documentaciÃ³n y pruebas.  

Si sigues estas prÃ¡cticas, tu API serÃ¡ mÃ¡s eficiente, fÃ¡cil de mantener y adoptada con mayor rapidez por otrxs desarrolladorxs. ğŸš€

## ğŸ“š Â¿QuÃ© es una biblioteca de software?

Una **biblioteca** es un conjunto de funciones, clases y herramientas reutilizables que facilitan tareas comunes en el desarrollo de software. Permiten a quienes desarrollan escribir menos cÃ³digo, mejorar la modularidad y evitar la repeticiÃ³n de lÃ³gica.

Ejemplos:
- **NumPy** (Python) â†’ ComputaciÃ³n cientÃ­fica.
- **Lodash** (JavaScript) â†’ ManipulaciÃ³n de arrays y objetos.
- **Guava** (Java) â†’ Colecciones avanzadas y utilidades.

### ğŸ” Diferencias entre una biblioteca y una aplicaciÃ³n

| ğŸ“Œ CaracterÃ­stica   | ğŸ“š Bibliotecas | ğŸ–¥ï¸ Aplicaciones |
|--------------------|--------------|---------------|
| **Finalidad**      | Proveer funcionalidades reutilizables | Resolver un problema especÃ­fico |
| **Ejecutables**    | âŒ No pueden ejecutarse por sÃ­ solas | âœ… Pueden ejecutarse de forma independiente |
| **InteracciÃ³n**    | API para desarrolladorxs | Interfaz para usuarixs (UI/CLI) |
| **Ejemplos**       | NumPy, Guava, Boost | Chrome, Photoshop, IntelliJ |

### ğŸ—ï¸ Principios de DiseÃ±o de Bibliotecas

Para que una biblioteca sea efectiva, debe cumplir con ciertos principios de diseÃ±o.

#### ğŸ›ï¸ 1. Interfaces Simples y Coherentes

âœ”ï¸ **API fÃ¡cil de usar** â†’ Debe ser intuitiva sin necesidad de leer documentaciÃ³n extensa.  
âœ”ï¸ **Consistencia** â†’ Uso uniforme de nombres y estructuras.

```kotlin
// âŒ Inconsistente (nombres y orden de parÃ¡metros diferentes)
parseJSON(validate = true, "data.json")
readXml("data.xml", validate = true)

// âœ… Consistente (sigue un mismo patrÃ³n)
Parser.json("data.json", validate = true)
Parser.xml("data.xml", validate = true)
```

#### ğŸ”’ 2. EncapsulaciÃ³n y Ocultamiento de ImplementaciÃ³n

âœ”ï¸ **Solo exponer lo necesario** â†’ Los detalles internos deben estar ocultos.  
âœ”ï¸ **Modularidad** â†’ Cada parte de la biblioteca debe ser independiente.

```kotlin
class Database private constructor() {
    private val connection = connectToDatabase() // ğŸ”’ Oculto

    fun query(sql: String): ResultSet = connection.executeQuery(sql)

    companion object {
        fun create(): Database = Database()
    }
}
```
ğŸ“Œ **El usuario solo interactÃºa con `query()` sin preocuparse por la conexiÃ³n interna.**

#### âš–ï¸ 3. CohesiÃ³n y Bajo Acoplamiento

âœ”ï¸ **Alta cohesiÃ³n** â†’ Cada mÃ³dulo debe hacer una sola cosa bien.  
âœ”ï¸ **Bajo acoplamiento** â†’ Los cambios en una parte no deben afectar otras.

```kotlin
// âŒ Mal diseÃ±o: la clase maneja tanto autenticaciÃ³n como validaciÃ³n de datos.
class AuthService {
    fun login(user: String, pass: String) { /*...*/ }
    fun isValidEmail(email: String): Boolean { /*...*/ }
}

// âœ… Buen diseÃ±o: separaciÃ³n de responsabilidades.
class AuthService { fun login(user: String, pass: String) { /*...*/ } }
class Validator { fun isValidEmail(email: String): Boolean { /*...*/ } }
```


### ğŸ”¥ Ejemplos de Bibliotecas Populares

#### 1ï¸âƒ£ Lodash (JavaScript) â€“ Utilidades para Arrays y Objetos

ğŸ“Œ **Facilita la manipulaciÃ³n de datos en JavaScript.**
```typescript
import _ from 'lodash';
const numbers = [1, 2, 3, 4, 5];
console.log(_.chunk(numbers, 2)); // [[1, 2], [3, 4], [5]]
```

#### 2ï¸âƒ£ NumPy (Python) â€“ ComputaciÃ³n NumÃ©rica

ğŸ“Œ **Optimiza operaciones matemÃ¡ticas con arrays y matrices.**
```python
import numpy as np
a = np.array([1, 2, 3])
b = np.array([4, 5, 6])
print(np.dot(a, b))  # Output: 32
```

#### 3ï¸âƒ£ Guava (Java) â€“ Colecciones y Utilidades

ğŸ“Œ **Extiende las capacidades estÃ¡ndar de Java con estructuras de datos avanzadas.**
```java
Multimap<String, String> multimap = ArrayListMultimap.create();
multimap.put("fruit", "apple");
multimap.put("fruit", "banana");
System.out.println(multimap); // {fruit=[apple, banana]}
```

#### 4ï¸âƒ£ Boost (C++) â€“ Extensiones para C++

ğŸ“Œ **Proporciona herramientas avanzadas para manipulaciÃ³n de datos.**

```cpp
#include <boost/algorithm/string.hpp>
std::string str = "Hello Boost";
boost::to_upper(str);
std::cout << str;  // Output: HELLO BOOST
```

#### 5ï¸âƒ£ Arrow (Kotlin) â€“ ProgramaciÃ³n Funcional

ğŸ“Œ **Simplifica el manejo de errores y estructuras de datos inmutables.**

```kotlin
import arrow.core.*

fun divide(a: Int, b: Int): Either<String, Int> =
    if (b == 0) "Cannot divide by zero".left() else (a / b).right()

println(divide(4, 2))  // Output: Right(2)
```

## ğŸ¯ Conclusiones

DiseÃ±ar bibliotecas de software va mucho mÃ¡s allÃ¡ de simplemente escribir funciones reutilizables: implica construir herramientas que otras personas usarÃ¡n y en las que confiarÃ¡n. Una buena biblioteca ofrece una API clara, coherente y segura que **reduce la complejidad** del desarrollo, **promueve la reutilizaciÃ³n** y **facilita el mantenimiento** del cÃ³digo.

Hemos visto cÃ³mo una buena API:

- abstrae correctamente el problema que resuelve,  
- oculta detalles innecesarios,  
- mantiene su interfaz simple y coherente,  
- estÃ¡ diseÃ±ada para evitar mal uso,  
- estÃ¡ bien estructurada internamente (alta cohesiÃ³n, bajo acoplamiento),  
- y cuenta con estabilidad, documentaciÃ³n y pruebas adecuadas.

### ğŸ”‘ Puntos clave

- Una biblioteca es tanto una herramienta tÃ©cnica como una interfaz para otras personas. Su diseÃ±o debe enfocarse en la **experiencia de quien la usa**.  
- Las decisiones de diseÃ±o impactan directamente en la **seguridad, mantenibilidad y adopciÃ³n** de la biblioteca.  
- Aplicar principios como **encapsulaciÃ³n, simplicidad, cohesiÃ³n** y **versionado cuidadoso** mejora significativamente la calidad del software.

### ğŸ§° Â¿QuÃ© nos llevamos?

DiseÃ±ar bibliotecas no es solo un ejercicio tÃ©cnico: es una forma de comunicaciÃ³n. Cada funciÃ³n pÃºblica, cada nombre de parÃ¡metro, cada estructura expuesta es una invitaciÃ³n a que otra persona confÃ­e en tu cÃ³digo. Al aplicar principios como claridad, simplicidad, encapsulaciÃ³n y pruebas, no solo estÃ¡s resolviendo un problema, estÃ¡s construyendo herramientas que perdurarÃ¡n y crecerÃ¡n junto con quienes las usan.

Lo mÃ¡s valioso que puedes llevarte de esta unidad es que una buena biblioteca no se mide solo por lo que hace, sino por **cÃ³mo hace sentir a quien la utiliza**: segura, guiada y capaz.

Crear bibliotecas es crear comunidad. Y eso, en sÃ­ mismo, es un acto de generosidad.

## ğŸ“– Referencias

### ğŸ”¥ Recomendadas

- ğŸ“š Introduction. (2024). En M. Reddy, API design for C++ (Second edition, pp. 1â€“24). Morgan Kaufmann.
- ğŸ“š Qualities. (2024). En M. Reddy, API design for C++ (Second edition, pp. 25â€“80). Morgan Kaufmann.
