---
title: Expresiones condicionales
---
import Exercise from '@site/src/components/exercise/Exercise'
import Explanation from '@site/src/components/admonitions/Explanation'
import Solution from '@site/src/components/exercise/Solution'
import ReadingTime from '@site/src/components/ReadingTime'
import GithubRepoLink from '@site/src/components/GithubRepoLink'

<ReadingTime />
<GithubRepoLink user="r8vnhill" repo="intro-kt"/>

Las estructuras condicionales son uno de los pilares del control de flujo en cualquier lenguaje de programaciÃ³n. Sin embargo, **Kotlin ofrece una mirada distinta y mÃ¡s expresiva**, al permitir que las condiciones â€”como `if` y `when`â€” sean no solo declaraciones, sino **expresiones** que devuelven valores.

Este enfoque abre la puerta a un estilo mÃ¡s conciso, mÃ¡s declarativo y mÃ¡s alineado con la escritura de funciones puras y reutilizables. En esta lecciÃ³n, aprenderemos a **distinguir entre declaraciones y expresiones condicionales**, y a sacar provecho de la expresividad que ofrece Kotlin para construir funciones mÃ¡s limpias y mantenibles.

AdemÃ¡s, exploraremos el uso idiomÃ¡tico de `when`, una alternativa poderosa a mÃºltiples `if` anidados, y discutiremos sus diferencias frente al *pattern matching* presente en otros lenguajes como Scala o Rust.

## ğŸ”€ ExpresiÃ³n `if`

En Kotlin, `if` puede usarse como una **expresiÃ³n** que retorna un valor, no solo como una declaraciÃ³n de control como en otros lenguajes imperativos.

```kotlin showLineNumbers title="if como expresiÃ³n (app/src/main/kotlin/cl/ravenhill/math/maxOf.kt)"
fun maxOf(a: Int, b: Int) = if (a > b) a else b
```

Esta capacidad permite escribir funciones de forma mÃ¡s concisa y expresiva.

TambiÃ©n puedes usarlo como declaraciÃ³n cuando no necesitas que devuelva un valor:

```kotlin showLineNumbers title="if como declaraciÃ³n (app/src/main/kotlin/cl/ravenhill/user/login.kt)"
if (isLoggedIn) {
    println("Welcome back!")
} else {
    println("Please sign in.")
}
```

:::danger Sin `else`, no hay valor

Cuando usas `if` como expresiÃ³n, **debes incluir un bloque `else`**. Si no lo haces, el compilador no podrÃ¡ inferir quÃ© valor devolver.

```kotlin
val result = if (x > 0) "Positive" // âŒ Error: falta `else`
```

:::

:::info Llaves en `if`: Â¿cuÃ¡ndo son necesarias?

- Si el bloque `if` o `else` contiene **mÃ¡s de una lÃ­nea**, **las llaves `{}` son obligatorias**.
- Si contiene **una sola expresiÃ³n**, puedes omitirlas, aunque **es recomendable incluirlas** para mejorar la legibilidad y evitar errores sutiles al extender el cÃ³digo mÃ¡s adelante.
- Cuando `if` se usa como **expresiÃ³n** (es decir, devuelve un valor), **el bloque se reduce al valor de la Ãºltima lÃ­nea dentro de las llaves `{}`**.

```kotlin
val result = if (x > 0)
    "positivo"
else
    "negativo"
```

Este bloque es una **expresiÃ³n**: su valor serÃ¡ `"positivo"` o `"negativo"`, dependiendo de la condiciÃ³n. Si se usan llaves, **la Ãºltima lÃ­nea ejecutada dentro de cada rama serÃ¡ el valor de la expresiÃ³n**:

```kotlin
val result = if (x > 0) {
    println("Evaluando...")
    "positivo"
} else {
    println("Evaluando...")
    "negativo"
}
```

:::

## ğŸ›ï¸ ExpresiÃ³n `when`

La expresiÃ³n `when` en Kotlin es una alternativa mÃ¡s concisa y legible a mÃºltiples estructuras `if-else if`. AdemÃ¡s, **devuelve un valor**, lo que la convierte en una herramienta versÃ¡til para el control de flujo.

```kotlin showLineNumbers title="when con argumento (app/src/main/kotlin/cl/ravenhill/network/status.kt)"
when (status) {
    200, 201, 204 -> "Success"
    400 -> "Bad Request"
    404 -> "Not Found"
    500 -> "Internal Server Error"
    "timeout" -> "The request timed out"
    is Int -> "Unhandled status code: $status"
    !is String -> "Unknown type"
    else -> "Unhandled string: $status"
}
```

<Explanation>
    - **`when (status)`** evalÃºa el valor de `status` y compara contra distintos casos.
    - **`200, 201, 204 -> "Success"`** muestra cÃ³mo agrupar mÃºltiples valores en una sola rama usando comas.
    - **`is Int`** y **`!is String`** usan comprobaciÃ³n de tipo (*type checking*) para manejar casos mÃ¡s generales.
    - **`else`** actÃºa como un caso por defecto, obligatorio si no se cubren todos los posibles valores.
    - Al ser una expresiÃ³n, `when` **devuelve directamente un valor**, por lo que se puede usar en asignaciones o como resultado de una funciÃ³n.
</Explanation>

:::tip TambiÃ©n se puede usar sin argumento

Puedes omitir el valor entre parÃ©ntesis para evaluar condiciones arbitrarias, similar a un bloque `if-else if`:

```kotlin showLineNumbers title="when sin argumento (app/src/main/kotlin/cl/ravenhill/weather/temperature.kt)"
when {
    temperature < 0 -> "Below freezing"
    temperature <= 15 -> "Cold"
    temperature <= 25 -> "Mild"
    temperature <= 35 -> "Warm"
    else -> "Hot"
}
```

:::

:::info Uso de llaves `{}` en `when`

En Kotlin, **las llaves `{}` dentro de una rama de `when` son necesarias** cuando se quiere ejecutar **mÃ¡s de una instrucciÃ³n** en esa rama:

```kotlin
val message = when (code) {
    404 -> {
        println("Not Found")
        logError(code)
        "Not Found" // ğŸ‘ˆ Esta es la expresiÃ³n final, se devuelve como resultado
    }
    else -> "Unhandled"
}
```

Si la rama contiene **solo una expresiÃ³n**, puedes omitir las llaves:

```kotlin
val message = when (code) {
    404 -> "Not Found" // âœ… sin llaves
    else -> "Other"
}
```

âœ… **Cuando usas `when` como expresiÃ³n**, la rama debe terminar en un valor:  
- Si usas llaves, **la Ãºltima lÃ­nea** del bloque es la que se utiliza como resultado.  
- Si no usas llaves, la expresiÃ³n directamente se usa como resultado.

Esto se aplica tanto si usas `when` como expresiÃ³n (que retorna un valor), como si lo usas como bloque de control (sin valor de retorno).

:::

:::warning Diferencias con pattern matching real
    
Aunque `when` se parece al **pattern matching** de Scala o Rust, tiene algunas limitaciones:

- No soporta destructuring directo (como `case (a, b)`).
- No permite patrones anidados ni coincidencias estructurales complejas.
- **Las condiciones tipo `case x if cond` existen**, pero son **experimentales** (requieren habilitar `-Xwhen-guards`) y no estÃ¡n activadas por defecto.
    ```kotlin
    // Requiere: -Xwhen-guards
    when (animal) {
        is Dog -> feedDog()
        is Cat if !animal.mouseHunter -> feedCat()
        else if animal.eatsPlants -> giveLettuce()
        else -> println("Unknown animal")
    }
    ```

:::

### ğŸ” Ejercicio: Reescribir usando `when`

<Exercise>
    Reescribe la funciÃ³n `login` utilizando una expresiÃ³n `when`.

    ```kotlin showLineNumbers
    fun login(username: String, password: String): Boolean {
        if (loginAttempts >= maxLoginAttempts) {
            return false
        }
        if (isValidPassword(password)) {
            loginAttempts = 0
            return true
        }
        loginAttempts++
        return false
    }
    ```

    <Solution>
        ```kotlin showLineNumbers
        fun login(username: String, password: String): Boolean = when {
            loginAttempts >= maxLoginAttempts -> false
            isValidPassword(password) -> {
                loginAttempts = 0
                true
            }
            else -> {
                loginAttempts++
                false
            }
        }
        ```
    </Solution>
</Exercise>

## ğŸ¯ Conclusiones

Kotlin transforma estructuras condicionales clÃ¡sicas como `if` y `switch` en expresiones versÃ¡tiles que devuelven valores. Esto permite escribir cÃ³digo mÃ¡s expresivo, conciso y seguro, especialmente en funciones puras y construcciones declarativas.

Tanto `if` como `when` pueden usarse como **expresiones** o **declaraciones**, pero cuando se usan como expresiones, **devuelven un valor** y se comportan de forma mÃ¡s predecible. Esta distinciÃ³n es clave para comprender el estilo idiomÃ¡tico de Kotlin.

### ğŸ”‘ Puntos clave

- Kotlin permite usar `if` y `when` como **expresiones que devuelven un valor**, no solo como declaraciones de control.
- Cuando `if` se usa como expresiÃ³n, el bloque `else` es obligatorio.
- En expresiones con llaves `{}`, el valor devuelto serÃ¡ el de **la Ãºltima lÃ­nea evaluada** del bloque.
- La expresiÃ³n `when` es una alternativa poderosa a mÃºltiples `if-else if`, y admite comprobaciÃ³n de tipo, valores mÃºltiples y evaluaciÃ³n sin argumento.
- Las llaves son necesarias en `when` si se ejecutan **varias instrucciones** en una rama.
- Aunque `when` se asemeja al **pattern matching**, no soporta patrones estructurales ni destructuring directo como en Scala o Rust.

### ğŸ§° Â¿QuÃ© nos llevamos?

Las expresiones condicionales en Kotlin nos invitan a repensar estructuras que en otros lenguajes suelen ser puramente imperativas. AquÃ­, `if` y `when` no solo controlan el flujo: tambiÃ©n **producen valores**, lo que nos permite escribir funciones mÃ¡s limpias, mÃ¡s breves y mÃ¡s expresivas.

Este cambio de perspectiva â€”ver las condiciones no solo como instrucciones, sino como **expresiones evaluables**â€” es una puerta de entrada a un estilo de programaciÃ³n mÃ¡s declarativo, mÃ¡s funcional, y mÃ¡s alineado con el diseÃ±o de bibliotecas reutilizables.

Entender estas diferencias nos prepara para abordar con mayor claridad temas como lambdas, funciones puras y expresiones de control mÃ¡s complejas. A partir de ahora, podremos decidir con mÃ¡s intenciÃ³n cuÃ¡ndo usar una expresiÃ³n, cuÃ¡ndo usar una declaraciÃ³n, y cÃ³mo escribir cÃ³digo que comunique mejor nuestras ideas.

## ğŸ“– Referencias

### ğŸ”¥ Recomendadas

- ğŸ“š Kotlin basics. (2017). En Dmitry Jemerov & Svetlana Isakova, Kotlin in action (pp. 17â€“43). Manning Publications Co.

{/* ### ğŸ“šğŸ”¹ Adicionales */}
