---
title: Recursi√≥n
---
import ReadingTime from '@site/src/components/ReadingTime'
import { ProCons, Pros, Cons } from '@site/src/components/cajitas/ProCons'
import References from '@site/src/components/ReferencesComponent'
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'
import Exercise from '@site/src/components/exercise/Exercise'
import Solution from '@site/src/components/exercise/Solution'
import Hint from '@site/src/components/exercise/Hint'
import Definition from '@site/src/components/Definition'
import Corollary from '@site/src/components/Corollary'
import GitHubRepoLink from '@site/src/components/git/GitHubRepoLink'
import Explanation from '@site/src/components/admonitions/Explanation'
import RepoClone from '@site/src/components/admonitions/RepoClone'
import ModuleSetup from '@site/src/components/cajitas/ModuleSetup'
import BoxedTabs from '@site/src/components/cajitas/BoxedTabs'

<ReadingTime />

La **recursi√≥n** ocurre cuando una funci√≥n se llama a s√≠ misma durante su ejecuci√≥n. Es una poderosa herramienta que permite **dividir** un problema en subproblemas m√°s peque√±os, resolviendo cada caso de forma recursiva hasta alcanzar un caso base que detenga la recursi√≥n. El uso de un caso base es esencial para evitar un bucle infinito, que agotar√≠a los recursos del sistema.

La recursi√≥n es especialmente √∫til para abordar problemas que pueden ser naturalmente expresados de esta manera, como la suma de los elementos de una lista, la generaci√≥n de secuencias, o el c√°lculo del factorial de un n√∫mero.

## üåÄ Ejemplo de Recursi√≥n

El **factorial** de un n√∫mero positivo $n$ (denotado como $n!$) se define como el producto de todos los enteros positivos menores o iguales a $n$. Se puede definir recursivamente de la siguiente manera:

```kotlin
// highlight-next-line
fun factorial(n: Int) = if (n == 0) {
    1L
} else {
    n.toLong() * factorial(n - 1)
}
```

:::danger[Error]

Type checking has run into a recursive problem. Easiest workaround: specify types of your declarations explicitly.

:::

Para evitar esto, es necesario **especificar expl√≠citamente el tipo de retorno** de las funciones recursivas. Por ejemplo, en el caso de `factorial`, el tipo de retorno puede ser `Long` (para manejar n√∫meros grandes).

```kotlin
fun factorial(n: Int): Long = if (n == 0) {
    1L
} else {
    n.toLong() * factorial(n - 1)
}
```

<details>
    <summary>Recursi√≥n por la cola</summary>

    La **recursi√≥n por la cola** (*tail recursion*) es un tipo especial de recursi√≥n donde la llamada recursiva es la **√∫ltima operaci√≥n** que realiza la funci√≥n. Esto permite al compilador optimizar la llamada y **reutilizar el stack frame**, evitando desbordamientos de pila incluso en recursiones profundas.

    Kotlin puede optimizar estas funciones si se usa la palabra clave `tailrec`:

    ```kotlin
    tailrec fun factorial(n: Int, acc: Long = 1): Long = if (n == 0) {
        acc
    } else {
        factorial(n - 1, acc * n)
    }
    ```

    <Explanation>
        En este ejemplo, la funci√≥n `factorial` utiliza un par√°metro acumulador (`acc`) para mantener el resultado parcial. A diferencia de la versi√≥n recursiva tradicional, **no hay operaciones pendientes despu√©s de la llamada recursiva**: el valor de retorno es directamente el resultado de `factorial(...)`.

        Gracias a esto, Kotlin puede aplicar una **optimizaci√≥n de recursi√≥n por la cola**, reemplazando la llamada recursiva por una iteraci√≥n bajo el cap√≥. Esto significa que puedes calcular factoriales muy grandes sin preocuparte por un desbordamiento de pila, algo que s√≠ podr√≠a ocurrir con la versi√≥n recursiva tradicional.

        La palabra clave `tailrec` le dice expl√≠citamente al compilador que intente aplicar esta optimizaci√≥n. Si la llamada recursiva no est√° en posici√≥n de cola, el compilador emitir√° un error.
    </Explanation>

    <ProCons>
        <Pros>
            - **Prevenci√≥n de desbordamiento de pila**: Gracias a la optimizaci√≥n, se puede usar recursi√≥n sin agotar la pila incluso en casos de recursi√≥n profunda.
            - **C√≥digo expresivo y declarativo**: Permite escribir l√≥gica de forma recursiva (y por lo tanto natural en algunos problemas) sin sacrificar eficiencia.
            - **Equivalencia a bucles**: En funciones optimizadas con `tailrec`, el rendimiento es comparable al de una estructura iterativa, pero con mayor claridad en algunos algoritmos.
            - **Apoyo del compilador**: El uso de `tailrec` es validado en tiempo de compilaci√≥n, lo que evita errores sutiles si no se cumple la posici√≥n de cola.
        </Pros>
        <Cons>
            - **Requiere reescritura con acumuladores**: Muchas funciones deben redise√±arse para mover la recursi√≥n al final, lo que puede dificultar la legibilidad o alejarse de la definici√≥n matem√°tica original.
            - **Limitado a una √∫nica llamada recursiva en posici√≥n de cola**: Si hay m√∫ltiples llamadas o l√≥gica adicional tras la recursi√≥n, no se puede optimizar con `tailrec`.
            - **Solo funciona en funciones directas**: `tailrec` no se puede aplicar si la llamada recursiva ocurre dentro de una lambda o expresi√≥n anidada.
            - **No es aplicable en todos los algoritmos**: Algunos problemas no pueden modelarse naturalmente con recursi√≥n por la cola (por ejemplo, recorridos de √°rboles que requieren backtracking).
        </Cons>
    </ProCons>
</details>

<details>
    <summary>
        Recursi√≥n profunda con `DeepRecursiveFunction`
    </summary>

    En Kotlin, incluso con optimizaciones como `tailrec`, las llamadas recursivas que **no son en posici√≥n de cola** pueden provocar errores de desbordamiento de pila (*StackOverflowError*) si la profundidad de recursi√≥n es muy alta.

    Para manejar estos casos, Kotlin ofrece `DeepRecursiveFunction`, una herramienta de la librer√≠a est√°ndar que **simula la recursi√≥n mediante trampolines**, evitando el crecimiento de la pila.

    Aqu√≠ tienes un ejemplo de c√≥mo reescribir la funci√≥n factorial para soportar recursi√≥n profunda:

    ```kotlin
    import kotlin.coroutines.*

    val deepFactorial = DeepRecursiveFunction<Int, Long> { n ->
        if (n == 0) 1L
        else n * callRecursive(n - 1)
    }

    fun factorial(n: Int): Long = deepFactorial(n)
    ```

    <Explanation>
        `DeepRecursiveFunction` permite definir funciones recursivas que no dependen de la pila de llamadas del sistema. Internamente, utiliza trampolines (una t√©cnica basada en continuations) para ejecutar las llamadas de forma segura, incluso con decenas de miles de niveles de profundidad.

        En el ejemplo, `callRecursive(n - 1)` reemplaza la llamada directa a la funci√≥n, delegando el control a un manejador interno que mantiene la recursi√≥n en una estructura controlada. Esto evita errores por desbordamiento de pila, lo que lo hace especialmente √∫til en algoritmos complejos como recorridos de √°rboles, parsers, o funciones num√©ricas intensivas.
    </Explanation>

    <ProCons>
        <Pros>
            - **Evita el desbordamiento de pila**: Permite ejecutar funciones con recursi√≥n no en posici√≥n de cola a profundidades que normalmente provocar√≠an errores.
            - **Compatible con cualquier estructura recursiva**: A diferencia de `tailrec`, puede usarse con algoritmos que requieren m√∫ltiples llamadas recursivas o l√≥gica despu√©s de la llamada.
            - **Ideal para problemas complejos**: Es √∫til en recorridos de √°rboles, evaluadores de expresiones, parsers, y otros algoritmos que exigen mucha profundidad o flexibilidad en la recursi√≥n.
            - **Integrado en la librer√≠a est√°ndar**: No requiere dependencias externas, y su uso est√° bien documentado en Kotlin.
        </Pros>
        <Cons>
            - **Sintaxis m√°s verbosa**: Requiere definir funciones como valores (`val`) usando lambdas con receptores, lo cual puede dificultar la legibilidad para personas nuevas en Kotlin.
            - **Requiere `callRecursive` en lugar de llamadas normales**: El c√≥digo se aleja de la notaci√≥n recursiva tradicional, lo que puede dificultar la traducci√≥n directa desde definiciones matem√°ticas.
            - **Menor rendimiento que `tailrec` o bucles**: Aunque evita el desbordamiento, su mecanismo basado en trampolines y continuations puede ser menos eficiente en comparaci√≥n con optimizaciones en tiempo de compilaci√≥n.
            - **Menor adopci√≥n**: Es una caracter√≠stica m√°s avanzada y menos conocida, por lo que puede generar dudas en equipos sin experiencia previa con recursi√≥n profunda o programaci√≥n funcional.
        </Cons>
    </ProCons>
</details>

## üéØ Conclusiones

La recursi√≥n es una herramienta expresiva y elegante para resolver problemas que se descomponen naturalmente en subproblemas. Ya sea en su forma cl√°sica, en versiones optimizadas con `tailrec`, o en enfoques m√°s avanzados como `DeepRecursiveFunction`, Kotlin ofrece diversas formas de aplicarla con seguridad y eficiencia.

Dominar estos distintos enfoques permite no solo escribir c√≥digo m√°s claro, sino tambi√©n adaptarse a las restricciones del sistema, como el l√≠mite de profundidad de la pila. As√≠, la elecci√≥n de una u otra t√©cnica no depende solo de la est√©tica o de la tradici√≥n matem√°tica, sino tambi√©n de los requerimientos pr√°cticos del problema y del contexto de ejecuci√≥n.

### üîë Puntos clave

- La **recursi√≥n tradicional** es simple y directa, pero puede provocar errores de pila si no se maneja con cuidado.
- La **recursi√≥n por la cola** (`tailrec`) permite optimizaci√≥n autom√°tica del compilador, pero requiere que la llamada recursiva sea la √∫ltima operaci√≥n.
- La **recursi√≥n profunda** con `DeepRecursiveFunction` es ideal para algoritmos complejos que no pueden expresarse en forma de cola, evitando desbordamientos mediante trampolines.
- Elegir entre estas formas implica evaluar **legibilidad, eficiencia, profundidad esperada** y **compatibilidad con el compilador**.

### üß∞ ¬øQu√© nos llevamos?

Comprender los diferentes estilos de recursi√≥n en Kotlin nos permite tomar decisiones m√°s informadas al dise√±ar soluciones. En lugar de evitar la recursi√≥n por miedo al desbordamiento o por prejuicios sobre el rendimiento, podemos optar por el enfoque que mejor se adapte al problema.

Adem√°s, estas herramientas ampl√≠an nuestra capacidad para implementar algoritmos expresivos, correctos y seguros, manteniendo el equilibrio entre claridad, elegancia y eficiencia. En el desarrollo de bibliotecas ‚Äîdonde la robustez y la reutilizaci√≥n son clave‚Äî entender las alternativas recursivas nos da una base s√≥lida para construir soluciones escalables y bien documentadas.

## üìñ Referencias

### üî• Recomendadas

üìö Recursion, corecursion, and memoization. (2019). En P.-Y. Saumont, The Joy of Kotlin. Manning Publications Co. LLC.
