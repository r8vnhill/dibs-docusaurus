---
title: Funciones Puras y Efectos Secundarios
---
import References from "/src/components/ReferencesComponent";
import Hint from "/src/components/exercise/Hint";
import Solution from "/src/components/exercise/Solution";
import Corollary from "/src/components/Corollary";
import Definition from "/src/components/Definition";
import Exercise from "/src/components/exercise/Exercise";
import ReadingTime from '/src/components/ReadingTime';
import TabItem from "@theme/TabItem";
import Tabs from "@theme/Tabs";

<ReadingTime />

En esta lecci√≥n, abordaremos el concepto de **funciones puras** y su relaci√≥n con los **efectos secundarios** en la programaci√≥n. Las funciones puras, al no tener efectos secundarios, ofrecen numerosas ventajas, como una mayor facilidad para probarlas, una mejor previsibilidad de su comportamiento, y su uso en entornos como la programaci√≥n funcional. Por otro lado, los efectos secundarios, aunque a menudo necesarios en aplicaciones del mundo real, pueden hacer que el c√≥digo sea m√°s dif√≠cil de mantener y depurar.

A lo largo de este tema, aprender√°s a identificar funciones puras e impuras, a refactorizar c√≥digo para eliminar efectos secundarios y a comprender c√≥mo utilizar las herramientas de Kotlin para manejar valores de forma segura, evitando modificaciones indeseadas en el estado del programa.

## Funciones Puras

<Definition title="Transparencia Referencial">
    Una expresi√≥n $e$ es referencialmente transparente si, en cualquier programa $p$, todas las ocurrencias de $e$ en $p$ pueden ser reemplazadas por el resultado de evaluar $e$ sin cambiar el significado de $p$.
</Definition>

<Definition title="Funci√≥n Pura">
    Una funci√≥n $f$ es pura si, para todos los $x$ que son referencialmente transparentes, la expresi√≥n $f(x)$ tambi√©n lo es.
</Definition>

<Corollary>
    Una funci√≥n es pura si su √∫nico efecto observable dentro de la ejecuci√≥n del programa es procesar el input para producir un output, sin causar ning√∫n otro cambio en el estado del programa.
</Corollary>

## Efectos Secundarios

Tambi√©n conocidos como **side-effects**, los efectos secundarios son cualquier operaci√≥n que una funci√≥n realice adem√°s de retornar un valor. Un efecto secundario puede ser modificar una variable global, escribir en un archivo, o interactuar con la interfaz de usuario. Cuando una funci√≥n tiene efectos secundarios, se la considera **impura**.

<Corollary>
    Una funci√≥n es impura si tiene efectos secundarios, es decir, si modifica algo fuera de su propio √°mbito o entorno.
</Corollary>

### Ejemplos de Funciones Puras e Impuras

A continuaci√≥n, analizamos algunos ejemplos para identificar funciones puras e impuras.

<Exercise title={"Identificar Funciones Puras e Impuras"}>
    Identifica si las siguientes funciones son puras o impuras:

    1.
        ```kotlin showLineNumbers
        fun add(a: Int, b: Int): Int = a + b
        ```
    2.
        ```kotlin showLineNumbers
        fun addCurried(): (Int) -> (Int) -> Int = { a -> { b -> a + b } }
        ```
    3.
        ```kotlin showLineNumbers
        fun greet(name: String): Unit = println("Hello, $name!")
        ```
    4.
        ```kotlin showLineNumbers
        fun incrementArray(array: Array<Int>): Unit {
            for (i in array.indices) {
                array[i]++
            }
        }
        ```

    <Solution>
        1. **Pura**: No tiene efectos secundarios y solo realiza una operaci√≥n matem√°tica.
        2. **Pura**: Es una funci√≥n currificada que no tiene efectos secundarios.
        3. **Impura**: Tiene un efecto secundario al imprimir en la consola.
        4. **Impura**: Modifica el array original, lo que implica un efecto secundario.
    </Solution>
</Exercise>

<Corollary>
    En general, si una funci√≥n retorna `Unit`, es un indicio de que podr√≠a tener efectos secundarios.
</Corollary>

### Mitigando Efectos Secundarios

Cuando una funci√≥n es impura debido a que modifica el estado del programa, como en el siguiente ejemplo, se puede refactorizar para evitar esos efectos.

### Ejemplo de funci√≥n impura:

```kotlin showLineNumbers
fun incrementArray(array: Array<Int>): Unit {
    for (i in array.indices) {
        array[i]++
    }
}
```

El c√≥digo anterior es impuro porque **modifica directamente el arreglo** pasado como argumento. Esto genera efectos secundarios, lo que hace que el comportamiento de la funci√≥n dependa del estado externo.

Para hacer que la funci√≥n sea pura, debemos **evitar modificar el arreglo original**. En su lugar, vamos a devolver un **nuevo arreglo** con los valores incrementados. A continuaci√≥n, utilizamos recursi√≥n para lograr esto:

```kotlin showLineNumbers
fun incrementArray(array: Array<Int>, index: Int = 0): Array<Int> =
    if (index >= array.size) {
        arrayOf()
    } else {
        arrayOf(array[index] + 1) + incrementArray(array, index + 1)
    }
```

:::info Explicaci√≥n del C√≥digo

- **[2]** Caso Base: El caso base ocurre cuando el √≠ndice ha recorrido todos los elementos del arreglo (`index >= array.size`). En este caso, la funci√≥n retorna un **arreglo vac√≠o**, lo cual sirve como punto de finalizaci√≥n de la recursi√≥n.
2. **[5]** Caso Recursivo:
    - En cada paso de la recursi√≥n, se crea un **nuevo arreglo** que contiene el valor incrementado del elemento actual, y luego se concatena con el resultado de la llamada recursiva para los elementos restantes.
    - Esto genera un nuevo arreglo sin modificar el original.

:::

### Ejemplo de Funci√≥n Impura: C√°lculo de Intereses Compuestos

En el c√≥digo original, el uso de `println` para mostrar los balances en cada iteraci√≥n es un **efecto secundario** que lo hace impuro:

```kotlin showLineNumbers
fun calculateCompoundInterest(
    principal: Double,
    rate: Double,
    years: Int
): Double {
    var balance = principal
    for (year in 1..years) {
        balance += balance * rate
        // highlight-next-line
        println("A√±o $year: Balance = $balance")
    }
    return balance
}
```

Para hacer la funci√≥n **pura**, eliminamos los efectos secundarios (la impresi√≥n) y almacenamos el historial de balances en una lista que ser√° parte del resultado. Utilizaremos **recursi√≥n** con una funci√≥n auxiliar para no tener una üí£explosi√≥nüí• en el n√∫mero de par√°metros:

```kotlin showLineNumbers
fun calculateCompoundInterest(
    principal: Double,
    rate: Double,
    years: Int
): Pair<Double, List<String>> {
    fun calculateRecursive(
        currentYear: Int,
        currentBalance: Double,
        history: List<String>
    ): Pair<Double, List<String>> = if (currentYear > years) {
        currentBalance to history
    } else {
        val newBalance = currentBalance + currentBalance * rate
        val newHistory = history + "A√±o $currentYear: Balance = $newBalance"
        calculateRecursive(currentYear + 1, newBalance, newHistory)
    }
    return calculateRecursive(1, principal, emptyList())
}
```

:::note

Usamos una **funci√≥n auxiliar** en lugar de par√°metros por defecto para evitar sobrecargar la funci√≥n principal con demasiados par√°metros, lo que afectar√≠a su claridad. La funci√≥n auxiliar maneja el estado interno, manteniendo la **simplicidad** y **legibilidad**, mientras que la funci√≥n principal se enfoca solo en los par√°metros esenciales. Esto sigue el principio de mantener las funciones con la menor cantidad de par√°metros posible.

:::

<Exercise title={"Eliminar Efectos Secundarios"}>
    En el siguiente ejemplo, la funci√≥n `transferirFondos` tiene efectos secundarios, ya que modifica el estado de las cuentas y la base de datos:

    ```kotlin showLineNumbers
    object Database {
        fun update(cuenta: Cuenta): Unit = TODO()
    }

    fun transferirFondos(cuentaOrigen: Cuenta, cuentaDestino: Cuenta, monto: Int) =
        if (cuentaOrigen.saldo >= monto) {
            cuentaOrigen.saldo -= monto
            cuentaDestino.saldo += monto
            database.update(cuentaOrigen)
            database.update(cuentaDestino)
            true
        } else {
            false
        }
    ```

    Modifica la funci√≥n `transferirFondos` para eliminar los efectos secundarios. En lugar de modificar directamente las cuentas, devuelve un objeto que describa el resultado de la operaci√≥n.

    <Hint hints={[
        "Utiliza un registro para representar el resultado de la transferencia."
    ]} />

    <Solution>
        ```kotlin showLineNumbers
        data class TransferenciaResultado(
            val cuentaOrigenActualizada: Cuenta,
            val cuentaDestinoActualizada: Cuenta,
            val exito: Boolean
        )
        ```

        ```kotlin showLineNumbers
        fun transferirFondos(cuentaOrigen: Cuenta, cuentaDestino: Cuenta, monto: Int) =
            if (cuentaOrigen.saldo >= monto) {
                val nuevaCuentaOrigen = cuentaOrigen.copy(saldo = cuentaOrigen.saldo - monto)
                val nuevaCuentaDestino = cuentaDestino.copy(saldo = cuentaDestino.saldo + monto)
                TransferenciaResultado(nuevaCuentaOrigen, nuevaCuentaDestino, true)
            } else {
                TransferenciaResultado(cuentaOrigen, cuentaDestino, false)
            }
        ```
    </Solution>
</Exercise>

## ¬øQu√© Aprendimos?

En esta lecci√≥n, vimos:

1. **Funciones Puras**: Producen el mismo resultado dado el mismo input y no tienen efectos secundarios, lo que las hace f√°ciles de probar y predecibles.
2. **Efectos Secundarios**: Ocurren cuando una funci√≥n modifica el estado externo o interact√∫a con el entorno, volvi√©ndola impura y m√°s dif√≠cil de mantener.
3. **Mitigaci√≥n**: Refactorizar para evitar modificaciones directas en el estado y devolver nuevos valores ayuda a mantener la pureza de las funciones.

Las funciones puras mejoran la **predecibilidad**, **facilidad de prueba**, y **reutilizaci√≥n** en el c√≥digo.

<References references={[
    {
        title: "1. What is functional programming?",
        bookTitle: "Functional Programming in Kotlin",
        pages: "3‚Äì16",
        location: "Manning Publications Co. LLC",
        publisher: "Shelter Island, NY",
        year: "2021",
        type: "book",
        author: 'M. Vermeulen, R. Bjarnason, & P. Chiusano',
        edition: '1st',
    },
]} />
