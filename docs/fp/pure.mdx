---
title: Funciones puras y efectos secundarios
---
import ReadingTime from '@site/src/components/ReadingTime'
import { ProCons, Pros, Cons } from '@site/src/components/cajitas/ProCons'
import References from '@site/src/components/ReferencesComponent'
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'
import Exercise from '@site/src/components/exercise/Exercise'
import Solution from '@site/src/components/exercise/Solution'
import Hint from '@site/src/components/exercise/Hint'
import Definition from '@site/src/components/Definition'
import Corollary from '@site/src/components/Corollary'
import GitHubRepoLink from '@site/src/components/git/GitHubRepoLink'
import { LanguageCard } from '@site/src/components/cards/LanguageCard'
import Explanation from '@site/src/components/admonitions/Explanation'
import RepoClone from '@site/src/components/admonitions/RepoClone'

<ReadingTime />
<GitHubRepoLink user="r8vnhill" repo="" />

En esta lecci√≥n, abordaremos el concepto de **funciones puras** y su relaci√≥n con los **efectos secundarios** en la programaci√≥n. Las funciones puras, al no tener efectos secundarios, ofrecen numerosas ventajas, como una mayor facilidad para probarlas, una mejor previsibilidad de su comportamiento, y su uso en entornos como la programaci√≥n funcional. Por otro lado, los efectos secundarios, aunque a menudo necesarios en aplicaciones del mundo real, pueden hacer que el c√≥digo sea m√°s dif√≠cil de mantener y depurar.

A lo largo de este tema, aprender√°s a identificar funciones puras e impuras, a refactorizar c√≥digo para eliminar efectos secundarios y a comprender c√≥mo utilizar las herramientas de Kotlin para manejar valores de forma segura, evitando modificaciones indeseadas en el estado del programa.

## Funciones Puras

<Definition title="Transparencia Referencial">
    Una expresi√≥n $e$ es referencialmente transparente si, en cualquier programa $p$, todas las ocurrencias de $e$ en $p$ pueden ser reemplazadas por el resultado de evaluar $e$ sin cambiar el significado de $p$.
</Definition>

<Definition title="Funci√≥n Pura">
    Una funci√≥n $f$ es pura si, para todos los $x$ que son referencialmente transparentes, la expresi√≥n $f(x)$ tambi√©n lo es.
</Definition>

<Corollary>
    Una funci√≥n es pura si su √∫nico efecto observable dentro de la ejecuci√≥n del programa es procesar el input para producir un output, sin causar ning√∫n otro cambio en el estado del programa.
</Corollary>

## Efectos Secundarios

Tambi√©n conocidos como **side-effects**, los efectos secundarios son cualquier operaci√≥n que una funci√≥n realice adem√°s de retornar un valor. Un efecto secundario puede ser modificar una variable global, escribir en un archivo, o interactuar con la interfaz de usuario. Cuando una funci√≥n tiene efectos secundarios, se la considera **impura**.

<Exercise title={"Identificar Funciones Puras e Impuras"}>
    Identifica si las siguientes funciones son puras o impuras:

    1.
        ```kotlin showLineNumbers
        fun add(a: Int, b: Int): Int = a + b
        ```
    2.
        ```kotlin showLineNumbers
        fun addCurried(): (Int) -> (Int) -> Int = { a -> { b -> a + b } }
        ```
    3.
        ```kotlin showLineNumbers
        fun greet(name: String): Unit = println("Hello, $name!")
        ```
    4.
        ```kotlin showLineNumbers
        fun incrementArray(array: Array<Int>): Unit {
            for (i in array.indices) {
                array[i]++
            }
        }
        ```

    <Solution>
        1. **Pura**: No tiene efectos secundarios y solo realiza una operaci√≥n matem√°tica.
        2. **Pura**: Es una funci√≥n currificada que no tiene efectos secundarios.
        3. **Impura**: Tiene un efecto secundario al imprimir en la consola.
        4. **Impura**: Modifica el array original, lo que implica un efecto secundario.
    </Solution>
</Exercise>

<Corollary>
    En general, si una funci√≥n retorna `Unit`, es un indicio de que podr√≠a tener efectos secundarios.
</Corollary>

## Mitigando efectos secundarios

Cuando una funci√≥n es impura debido a que modifica el estado del programa, como en el siguiente ejemplo, se puede refactorizar para evitar esos efectos.

### Ejemplo de funci√≥n impura: Incrementar un arreglo

```kotlin showLineNumbers
fun incrementArray(array: Array<Int>): Unit {
    for (i in array.indices) {
        array[i]++
    }
}
```

El c√≥digo anterior es impuro porque **modifica directamente el arreglo** pasado como argumento. Esto genera efectos secundarios, lo que hace que el comportamiento de la funci√≥n dependa del estado externo.

Para hacer que la funci√≥n sea pura, debemos **evitar modificar el arreglo original**. En su lugar, vamos a devolver un **nuevo arreglo** con los valores incrementados. A continuaci√≥n, utilizamos recursi√≥n para lograr esto:

```kotlin showLineNumbers
fun incrementArray(array: Array<Int>, index: Int = 0): Array<Int> =
    if (index >= array.size) {
        arrayOf()
    } else {
        arrayOf(array[index] + 1) + incrementArray(array, index + 1)
    }
```

<Explanation>
    - **[2]** Caso Base: El caso base ocurre cuando el √≠ndice ha recorrido todos los elementos del arreglo (`index >= array.size`). En este caso, la funci√≥n retorna un **arreglo vac√≠o**, lo cual sirve como punto de finalizaci√≥n de la recursi√≥n.
    - **[5]** Caso Recursivo:
        - En cada paso de la recursi√≥n, se crea un **nuevo arreglo** que contiene el valor incrementado del elemento actual, y luego se concatena con el resultado de la llamada recursiva para los elementos restantes.
        - Esto genera un nuevo arreglo sin modificar el original.
</Explanation>

### Ejemplo de Funci√≥n Impura: C√°lculo de Intereses Compuestos

En el c√≥digo original, el uso de `println` para mostrar los balances en cada iteraci√≥n es un **efecto secundario** que lo hace impuro:

```kotlin showLineNumbers
fun calculateCompoundInterest(
    principal: Double,
    rate: Double,
    years: Int
): Double {
    var balance = principal
    for (year in 1..years) {
        balance += balance * rate
        // highlight-next-line
        println("A√±o $year: Balance = $balance")
    }
    return balance
}
```

Para hacer la funci√≥n **pura**, eliminamos los efectos secundarios (la impresi√≥n) y almacenamos el historial de balances en una lista que ser√° parte del resultado. Utilizaremos **recursi√≥n** con una funci√≥n auxiliar para no tener una üí£explosi√≥nüí• en el n√∫mero de par√°metros:

```kotlin showLineNumbers
fun calculateCompoundInterest(
    principal: Double,
    rate: Double,
    years: Int
): Pair<Double, List<String>> {
    fun calculateRecursive(
        currentYear: Int,
        currentBalance: Double,
        history: List<String>
    ): Pair<Double, List<String>> = if (currentYear > years) {
        currentBalance to history
    } else {
        val newBalance = currentBalance + currentBalance * rate
        val newHistory = history + "A√±o $currentYear: Balance = $newBalance"
        calculateRecursive(currentYear + 1, newBalance, newHistory)
    }
    return calculateRecursive(1, principal, emptyList())
}
```

<Exercise title={"Eliminar Efectos Secundarios"}>
    En el siguiente ejemplo, la funci√≥n `transferirFondos` tiene efectos secundarios, ya que modifica el estado de las cuentas y la base de datos:

    ```kotlin showLineNumbers
    object Database {
        fun update(cuenta: Cuenta): Unit = TODO()
    }

    fun transferirFondos(cuentaOrigen: Cuenta, cuentaDestino: Cuenta, monto: Int) =
        if (cuentaOrigen.saldo >= monto) {
            cuentaOrigen.saldo -= monto
            cuentaDestino.saldo += monto
            database.update(cuentaOrigen)
            database.update(cuentaDestino)
            true
        } else {
            false
        }
    ```

    Modifica la funci√≥n `transferirFondos` para eliminar los efectos secundarios. En lugar de modificar directamente las cuentas, devuelve un objeto que describa el resultado de la operaci√≥n.

    <Hint hints={[
        "Utiliza un registro para representar el resultado de la transferencia."
    ]} />

    <Solution>
        ```kotlin showLineNumbers
        data class TransferenciaResultado(
            val cuentaOrigenActualizada: Cuenta,
            val cuentaDestinoActualizada: Cuenta,
            val exito: Boolean
        )
        ```

        ```kotlin showLineNumbers
        fun transferirFondos(cuentaOrigen: Cuenta, cuentaDestino: Cuenta, monto: Int) =
            if (cuentaOrigen.saldo >= monto) {
                val nuevaCuentaOrigen = cuentaOrigen.copy(saldo = cuentaOrigen.saldo - monto)
                val nuevaCuentaDestino = cuentaDestino.copy(saldo = cuentaDestino.saldo + monto)
                TransferenciaResultado(nuevaCuentaOrigen, nuevaCuentaDestino, true)
            } else {
                TransferenciaResultado(cuentaOrigen, cuentaDestino, false)
            }
        ```
    </Solution>
</Exercise>

## Beneficios y limitaciones de las funciones puras

<ProCons>
    <Pros>
        - **Previsibilidad y simplicidad**: Las funciones puras son m√°s f√°ciles de razonar porque siempre producen los mismos resultados dados los mismos par√°metros de entrada, sin depender de factores externos o del estado global.
        - **Facilidad para probar**: Debido a que no tienen efectos secundarios, las funciones puras son mucho m√°s sencillas de probar de forma unitaria. No requieren mocks ni configuraci√≥n especial, ya que no interact√∫an con el estado externo.
        - **Reutilizaci√≥n y composici√≥n**: Las funciones puras se pueden combinar f√°cilmente para construir soluciones m√°s complejas. Son modulares y reutilizables sin preocuparse por su impacto en el estado externo.
        - **Facilidad de paralelizaci√≥n**: Al no depender de variables globales o del estado externo, las funciones puras pueden ejecutarse en paralelo sin riesgo de condiciones de carrera, mejorando el rendimiento en sistemas concurrentes o distribuidos.
        - **Transparencia referencial**: Dado que el resultado de una funci√≥n pura es predecible y no depende del contexto, se puede optimizar el c√≥digo mediante t√©cnicas como la memoizaci√≥n o el cacheado.
    </Pros>
    <Cons>
        - **Dificultad para interactuar con el mundo real**: Muchos programas del mundo real requieren efectos secundarios, como leer archivos, hacer consultas a bases de datos o interactuar con una API. En estos casos, las funciones puras por s√≠ solas no son suficientes.
        - **Overhead por evitar mutaciones**: En algunos casos, evitar efectos secundarios y crear nuevas estructuras de datos en lugar de modificar las existentes puede resultar en un sobrecosto de rendimiento o memoria, especialmente en algoritmos que requieren operaciones intensivas.
        - **Mayor complejidad para ciertas tareas**: Algunas operaciones que dependen de efectos secundarios, como la escritura de logs o la gesti√≥n de estados en aplicaciones interactivas, pueden volverse m√°s complicadas al tratar de forzarlas a ser puras.
        - **Curva de aprendizaje**: Para aquellos acostumbrados a programar de manera imperativa, trabajar con funciones puras y evitar efectos secundarios puede ser un desaf√≠o conceptual, requiriendo un cambio de mentalidad.
    </Cons>
</ProCons>

## ¬øQu√© aprendimos?

En esta lecci√≥n, hemos explorado el concepto de **funciones puras** y **efectos secundarios**. Aprendimos que las funciones puras son aquellas que no tienen efectos secundarios y siempre devuelven el mismo resultado con las mismas entradas. Adem√°s, comprendimos que las funciones con efectos secundarios, si bien son necesarias en muchos casos, pueden dificultar el mantenimiento y la depuraci√≥n del c√≥digo.

### Puntos clave

- **Funciones puras**: Son previsibles, f√°ciles de probar, reutilizables y adecuadas para la paralelizaci√≥n. No modifican el estado del programa ni interact√∫an con el mundo externo.
- **Efectos secundarios**: Involucran operaciones como modificar variables globales o escribir en un archivo, lo que hace que las funciones que los contienen sean impuras y dependan del estado externo.
- **Refactorizaci√≥n para evitar efectos secundarios**: Es posible transformar funciones impuras en funciones puras devolviendo nuevas estructuras de datos en lugar de modificar las existentes, o almacenando resultados en lugar de imprimirlos directamente.
- **Balance en la programaci√≥n**: Aunque las funciones puras tienen muchos beneficios, en la programaci√≥n real es necesario manejar efectos secundarios para interactuar con el mundo externo.

---

El uso de funciones puras y la minimizaci√≥n de los efectos secundarios conducen a un c√≥digo m√°s limpio, predecible y f√°cil de mantener. Sin embargo, es esencial encontrar un equilibrio entre pureza y funcionalidad pr√°ctica para lograr aplicaciones eficientes y robustas.

<References references={[
    {
        title: "What is functional programming?",
        bookTitle: "Functional Programming in Kotlin",
        pages: "3‚Äì16",
        location: "Manning Publications Co. LLC",
        publisher: "Shelter Island, NY",
        year: "2021",
        type: "book",
        author: 'M. Vermeulen, R. Bjarnason, & P. Chiusano',
        edition: '1st',
    },
]} />
