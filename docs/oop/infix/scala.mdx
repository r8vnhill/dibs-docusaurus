---
title: Expresiones infijas en Scala
---
import ReadingTime from '@site/src/components/ReadingTime'
import { ProCons, Pros, Cons } from '@site/src/components/cajitas/ProCons'
import References from '@site/src/components/ReferencesComponent'
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'
import Exercise from '@site/src/components/exercise/Exercise'
import Solution from '@site/src/components/exercise/Solution'
import Hint from '@site/src/components/exercise/Hint'
import Definition from '@site/src/components/Definition'
import Corollary from '@site/src/components/Corollary'
import GithubRepoLink from '@site/src/components/git/GithubRepoLink'
import { LanguageCard, ScalaCard } from '@site/src/components/cards/LanguageCard'
import Explanation from '@site/src/components/admonitions/Explanation'
import RepoClone from '@site/src/components/admonitions/RepoClone'
import ModuleSetup from '@site/src/components/cajitas/ModuleSetup'
import BoxedTabs from '@site/src/components/cajitas/BoxedTabs'

<ReadingTime />
<GithubRepoLink user="r8vnhill" repo="scala-dibs" />
Luego de haber explorado las **expresiones infijas en Kotlin**, su sintaxis y sus restricciones, es natural preguntarse cÃ³mo se comporta esta idea en otros lenguajes que tambiÃ©n promueven la expresividad y la composiciÃ³n fluida de cÃ³digo. En esta lecciÃ³n, veremos cÃ³mo Scala â€”un lenguaje fuertemente influenciado por la programaciÃ³n funcional y orientada a construir DSLsâ€” adopta y extiende el concepto de expresiones infijas con mucha mÃ¡s libertad que Kotlin.

En particular, compararemos las capacidades de ambos lenguajes y pondremos atenciÃ³n a una serie de diferencias clave:

- En Scala, **no es necesario marcar una funciÃ³n como infija**: cualquier mÃ©todo con un solo argumento puede usarse como tal.
- Se permite utilizar **sÃ­mbolos arbitrarios** como nombre de mÃ©todo, lo que posibilita la creaciÃ³n de operadores personalizados.
- No hay restricciones en cuanto al nÃºmero de parÃ¡metros o el uso de valores por defecto para que una funciÃ³n pueda invocarse en forma infija.
- Scala permite **encadenar mÃºltiples operaciones infijas sin parÃ©ntesis adicionales**, lo que facilita la escritura de cÃ³digo fluido en DSLs.

Estas diferencias hacen que Scala sea un lenguaje mÃ¡s permisivo â€”y tambiÃ©n mÃ¡s propenso a abusosâ€” en lo que respecta al uso de expresiones infijas. A lo largo de esta lecciÃ³n, veremos ejemplos comparativos que ilustran lo que **sÃ­ puedes hacer en Scala pero no en Kotlin**, y discutiremos cuÃ¡ndo esta expresividad adicional es Ãºtil y cuÃ¡ndo puede jugar en contra de la claridad del cÃ³digo.

### âœ… Â¿QuÃ© se puede hacer en Scala?

Scala permite que **cualquier mÃ©todo con un solo parÃ¡metro** sea invocado en forma infija, sin necesidad de declarar el mÃ©todo como `infix` (palabra clave que **no existe** en Scala). Esto incluye tanto mÃ©todos miembros como mÃ©todos de extensiÃ³n (usando `implicit class` o `extension` en Scala 3).

#### ğŸ§© Ejemplo 1: MÃ©todo miembro como infijo en una biblioteca de IA

Supongamos que estÃ¡s desarrollando una biblioteca de simulaciÃ³n para juegos o entornos de inteligencia artificial, y deseas ofrecer una API expresiva para modelar interacciones entre entidades. Una de esas entidades podrÃ­a ser un `Robot`, que puede realizar acciones sobre un objetivo.

```scala
class Robot(val name: String) {
  def attacks(target: String): String = s"$name attacks $target"
}

val robot = new Robot("HAL9000")

// Llamada tradicional
robot.attacks("Dave")

// Llamada infija
robot attacks "Dave"
```

Al exponer el mÃ©todo `attacks` en forma infija, permites que el usuario de tu biblioteca escriba cÃ³digo **mÃ¡s declarativo y legible**, como si se tratara de un lenguaje especÃ­fico del dominio (DSL). Esto resulta particularmente Ãºtil en bibliotecas diseÃ±adas para scripting de comportamientos o simulaciones, donde la claridad de la intenciÃ³n es clave.

> âœ… En Scala, **no necesitas usar una palabra clave especial** para habilitar la notaciÃ³n infija.  
> ğŸŸ£ Esto contrasta con Kotlin, donde solo funciones declaradas explÃ­citamente como `infix` pueden usarse de esta forma.

Este patrÃ³n tambiÃ©n se puede aplicar a bibliotecas de validaciÃ³n, motores de reglas o generadores de pruebas, donde los mÃ©todos infijos hacen que las reglas se lean como frases naturales:

```scala
"username" shouldBeValid
user mustHave "email"
order totalShouldBeGreaterThan 100
``` 

AsÃ­, Scala permite a quienes diseÃ±an bibliotecas ofrecer APIs que **no solo funcionan bien, sino que tambiÃ©n se leen bien**, un objetivo esencial en herramientas orientadas a usuarios tÃ©cnicos y no tÃ©cnicos por igual.

#### Ejemplo 2: MÃ©todos definidos en objetos o como extensiones

```scala
extension (username: String)
  def shouldHaveMinimumLength(length: Int): Boolean =
    username.length >= length

// Uso infijo
"leif" shouldHaveMinimumLength 4
```

> ğŸŸ¢ Esta capacidad de extender tipos existentes con mÃ©todos infijos es muy similar a Kotlin, pero en Scala no hay restricciones como â€œsolo un parÃ¡metro y sin valores por defectoâ€ para usarse en notaciÃ³n infija.

---

### ğŸš« Â¿QuÃ© NO se puede hacer en Kotlin pero SÃ en Scala?

Scala permite incluso usar **cualquier sÃ­mbolo como nombre de mÃ©todo**, lo que permite definir operadores personalizados con **nombres simbÃ³licos**:

#### Ejemplo 3: Operador personalizado con sÃ­mbolo

```scala
class Vector2(val x: Int, val y: Int) {
  def +(other: Vector2): Vector2 =
    new Vector2(x + other.x, y + other.y)
}

val a = new Vector2(1, 2)
val b = new Vector2(3, 4)

val c = a + b // Usando operador + como infijo
```

> â›” En Kotlin, solo se pueden sobrecargar un conjunto limitado de operadores predefinidos (`+`, `*`, `==`, etc.) mediante palabras clave (`operator fun`).  
> âœ… En Scala, **puedes definir cualquier operador simbÃ³lico** como infijo, lo cual no es posible en Kotlin.

---

### âš–ï¸ Precedencia de operadores en Scala

Al igual que en Kotlin, **la precedencia puede causar ambigÃ¼edad** en expresiones infijas. Pero en Scala, la precedencia estÃ¡ determinada por **el primer carÃ¡cter del nombre del mÃ©todo**. Por ejemplo:

```scala
val result = 1 + 2 * 3 // * tiene mayor precedencia que +
```

> âš ï¸ Si defines un mÃ©todo simbÃ³lico con un carÃ¡cter poco convencional (como `?:` o `!!`), podrÃ­a tener una precedencia confusa para quien lee el cÃ³digo. En Kotlin, no puedes crear nombres de funciÃ³n como sÃ­mbolos arbitrarios, por lo que este problema no se presenta.

---

### âœ¨ Expresiones mÃ¡s expresivas con mÃºltiples operadores

En Scala puedes combinar infijos en cadena, lo cual puede hacer el cÃ³digo mÃ¡s legible en algunos casos:

```scala
val result = "username" shouldHaveMinimumLength 5 shouldBe true
```

> Esto es posible gracias a que las funciones pueden devolver cualquier tipo (incluyendo el objeto original), permitiendo **encadenamiento fluido**. Este estilo es comÃºn en librerÃ­as como ScalaTest o Specs2, similares a Kotest.

---

## ğŸ“Œ ConclusiÃ³n Comparativa

| CaracterÃ­stica                              | Kotlin                        | Scala                            |
|--------------------------------------------|-------------------------------|----------------------------------|
| Â¿Requiere palabra clave para infijo?       | âœ… `infix`                    | âŒ No                            |
| Â¿Permite sÃ­mbolos como nombres de mÃ©todos? | âŒ No                         | âœ… SÃ­                            |
| Â¿Puede ser cualquier mÃ©todo?               | âŒ Solo miembro o extensiÃ³n   | âœ… Cualquier mÃ©todo              |
| Â¿Permite mÃ¡s de un parÃ¡metro?              | âŒ No                         | âœ… SÃ­                            |
| Â¿Permite mÃ©todos infijos definidos globalmente? | âŒ No                     | âœ… Con `extension` u `implicit` |
| Â¿Encadenamiento fluido natural?            | âœ… Con retorno de `this`      | âœ… Muy comÃºn                     |

<ProCons>
<Pros>
- Scala permite un uso **mÃ¡s libre y expresivo** de notaciÃ³n infija.
- Es posible definir **operadores personalizados simbÃ³licos**, como `<<<`, `:::` o `-->`.
- Las expresiones infijas no tienen restricciones en nÃºmero de parÃ¡metros.
</Pros>
<Cons>
- La **mayor flexibilidad puede generar ambigÃ¼edad o abuso**, haciendo el cÃ³digo mÃ¡s difÃ­cil de leer si no se sigue una convenciÃ³n clara.
- Las **reglas de precedencia simbÃ³lica** pueden ser confusas para personas nuevas en Scala.
</Cons>
</ProCons>
