---
title: Modularizando tu proyecto Scala con sbt
---

import ReadingTime from '@site/src/components/ReadingTime'
import Explanation from '@site/src/components/admonitions/Explanation'
import BoxedTabs from '@site/src/components/cajitas/BoxedTabs'
import TabItem from '@theme/TabItem'
import GitHubRepoLink from '@site/src/components/git/GitHubRepoLink'
import Ps from '@site/src/components/mdx/build-systems/modular-design/sbt/Initialize-ScalaModules.ps1.mdx'
import Bash from '@site/src/components/mdx/build-systems/modular-design/sbt/initialize_scala_modules.sh.mdx'
import RemoveSrcDirectorySh from '@site/src/components/mdx/build-systems/modular-design/sbt/remove_src_directory.sh.mdx'

<ReadingTime />
<GitHubRepoLink user="r8vnhill" repo="echo-app-sbt" />

Antes de que una biblioteca crezca ‚Äîantes de agregar pruebas o automatizar tareas‚Äî, es fundamental estructurar bien el proyecto.  
Si en la lecci√≥n anterior aprendiste a crear un proyecto b√°sico con sbt y a ejecutar tu primer programa en Scala 3, esta vez daremos un paso m√°s all√°: **modularizar tu aplicaci√≥n**.

En esta lecci√≥n aprender√°s a organizar un proyecto multi-m√≥dulo con sbt, una pr√°ctica esencial para desarrollar bibliotecas reutilizables y aplicaciones escalables.  
A trav√©s de un ejemplo simple pero completo, veremos c√≥mo:

- Definir m√∫ltiples subproyectos (`lib` y `app`) dentro de un mismo `build.sbt`.
- Compartir configuraciones comunes entre m√≥dulos.
- Reutilizar l√≥gica definida en un m√≥dulo desde otro.
- Ejecutar un subproyecto espec√≠fico desde la l√≠nea de comandos.

Este enfoque modular te permitir√° escribir c√≥digo m√°s limpio, reutilizable y f√°cil de mantener.  
Lo que comienza como un proyecto simple puede convertirse en una base s√≥lida para bibliotecas profesionales.

**Paso a paso, construimos una arquitectura que Scala (hehe).**

## üèóÔ∏è Estructura esperada del proyecto

Antes de configurar el `build.sbt`, es importante visualizar c√≥mo estar√° organizado el proyecto. Nuestro objetivo es dividirlo en dos subproyectos: una **biblioteca (`lib`)** que contendr√° la l√≥gica de negocio reutilizable, y una **aplicaci√≥n (`app`)** que funcionar√° como punto de entrada y consumir√° esa biblioteca.

La siguiente estructura refleja esta separaci√≥n, mostrando c√≥mo se distribuyen los archivos fuente dentro de cada m√≥dulo y c√≥mo se relacionan entre s√≠:

```mermaid
graph TD
    subgraph Root [üìÅ echo-app-sbt]
        direction TB

        Build[üìÑ build.sbt]

        subgraph Lib [üìÅ lib]
            subgraph LibMain [üìÅ src/main/scala]
                subgraph LibPkg [üìÅ com/github/username/echo]
                    LibCode[üìÑ EchoMessage.scala]
                end
            end
        end

        subgraph App [üìÅ app]
            subgraph AppMain [üìÅ src/main/scala]
                subgraph AppPkg [üìÅ com/github/username/echo]
                    AppCode[üìÑ App.scala]
                end
            end
        end
    end

    Build --> Lib
    Build --> App
    App -->|depende de| Lib
```

:::info Explicaci√≥n de la estructura

Este proyecto est√° dividido en dos m√≥dulos: una biblioteca (`lib`) y una aplicaci√≥n (`app`). Ambos se definen en el archivo ra√≠z `build.sbt`, lo que permite compartir configuraciones y compilarlos como parte del mismo proyecto.

- `lib/` contiene la l√≥gica de negocio reutilizable, organizada en el paquete `com.github.username.echo`.
- `app/` define la aplicaci√≥n que importa y utiliza la funcionalidad de `lib`, usando el mismo paquete para mantener consistencia.
- `EchoMessage.scala` representa una funci√≥n o clase de utilidad en la biblioteca.
- `App.scala` act√∫a como punto de entrada de la aplicaci√≥n.
- El subproyecto `app` declara una dependencia expl√≠cita sobre `lib`, lo que permite acceder a su c√≥digo directamente sin duplicaci√≥n.

:::

Esta estructura modular refleja buenas pr√°cticas en proyectos reales, donde separar la l√≥gica de negocio de la l√≥gica de ejecuci√≥n permite lograr mayor claridad, mantenibilidad y escalabilidad.

:::tip ¬øY la carpeta `src/` que hab√≠amos creado antes?

Puedes eliminar el directorio `src/` que creaste en la lecci√≥n anterior, o guardarlo como recuerdo.

<BoxedTabs groupId={"os"}>

{/* #region  Windows */}
<TabItem value="Windows" label="Windows">

```powershell showLineNumbers title="scripts/windows/Remove-SrcDirectory.ps1"
# Enable cmdlet binding to support -Verbose, -WhatIf, etc.
[CmdletBinding(SupportsShouldProcess)]
param ()

$Script:targetPath = 'src'

# Define a function to remove the 'src' directory recursively and forcefully
function Script:Remove-SrcDirectory {
    [CmdletBinding(SupportsShouldProcess, ConfirmImpact = 'High')]
    param ()

    # Check if the user wants to proceed
    if ($PSCmdlet.ShouldProcess('src', 'Remove src directory')) {
        # Deletes the 'src' directory and all its contents, forwarding any bound parameters
        Remove-Item -Path $Script:targetPath -Recurse -Force @PSBoundParameters
    }
}

# Call the function, forwarding any bound parameters like -Verbose or -WhatIf
Remove-SrcDirectory @PSBoundParameters
```

Luego puedes ejecutar el script con:

```powershell title="En la terminal de PowerShell"
.\scripts\windows\Remove-SrcDirectory.ps1 -Verbose
```

</TabItem>
{/* #endregion Windows */}

{/* #region macOS */}
<TabItem value="macOS" label="macOS">

<RemoveSrcDirectorySh />

</TabItem>
{/* #endregion macOS */}

{/* #region Ubuntu/Debian */}
<TabItem value="Ubuntu/Debian" label="Ubuntu/Debian">

<RemoveSrcDirectorySh />

</TabItem>
{/*  #endregion Ubuntu/Debian */}

</BoxedTabs>

:::


## üì¶ Paso 1: Crear la estructura de carpetas

<BoxedTabs groupId={"os"}>
    <TabItem value="Windows" label="Windows">
        <Ps />
    </TabItem>
    <TabItem value="macOS" label="macOS">
        <Bash />
    </TabItem>
    <TabItem value="Ubuntu/Debian" label="Ubuntu/Debian">
        <Bash />
    </TabItem>
</BoxedTabs>


## üß± Paso 2: Declarar los m√≥dulos del proyecto

Para transformar nuestro proyecto en una estructura multi-m√≥dulo, comenzamos por definir sus componentes principales dentro del archivo `build.sbt` ra√≠z:

```scala showLineNumbers title="build.sbt"
ThisBuild / scalaVersion := "3.7.1"

ThisBuild / organization := "com.github.username"
ThisBuild / name := "echo-app"

lazy val commonSettings = Seq(
    scalacOptions ++= Seq(
        "-deprecation",
        "-unchecked",
        "-feature"
    )
)

lazy val lib = project
  .in(file("lib"))
  .settings(commonSettings *)

lazy val app = project
  .in(file("app"))
  .dependsOn(lib)
  .settings(commonSettings *)

lazy val root = project
  .in(file("."))
  .aggregate(lib, app)
  .settings(commonSettings *)
```

<Explanation>
    En este paso transformamos nuestro proyecto en una **estructura multi-m√≥dulo**, lo que nos permite separar responsabilidades entre distintos componentes (por ejemplo, una biblioteca reutilizable y una aplicaci√≥n principal).

    - Primero definimos `scala3Version` como una variable para centralizar la versi√≥n del compilador.
    - Luego creamos una lista llamada `commonSettings` que contiene configuraciones compartidas, como `scalaVersion`.
    - A continuaci√≥n declaramos dos m√≥dulos (`lib` y `app`) usando `lazy val`:
        - `lib` se encuentra en el subdirectorio `lib/` y recibe las configuraciones comunes.
        - `app` se encuentra en `app/`, tambi√©n hereda las configuraciones comunes y depende expl√≠citamente de `lib` usando `.dependsOn(lib)`.

    Usamos **`lazy val`** porque `sbt` necesita construir la estructura del proyecto de forma perezosa (lazy): permite que las referencias entre proyectos (como `app.dependsOn(lib)`) se resuelvan sin problemas incluso si a√∫n no se han evaluado por completo.  
    Esto evita errores de orden de inicializaci√≥n y permite que `sbt` maneje correctamente las dependencias entre m√≥dulos.
</Explanation>

Esta estructura modular es especialmente √∫til en proyectos de bibliotecas, ya que permite mantener el c√≥digo reutilizable separado del c√≥digo espec√≠fico de una aplicaci√≥n o herramienta.

## üì¶ Paso 3: Crear el m√≥dulo de biblioteca

Una vez declarado el subproyecto `lib`, es momento de comenzar a escribir la l√≥gica de negocio que deseamos reutilizar. Empezaremos con una funci√≥n sencilla, pensada para ser consumida desde otros m√≥dulos:

```scala title="lib/src/main/scala/com/github/username/echo/EchoMessage.scala" showLineNumbers
package com.github.username
package echo

def echoMessage(message: String): String = message
```

<Explanation>
    Este archivo define un **componente reutilizable** dentro del subproyecto `lib`.

    - El paquete `com.github.username.echo` sigue la convenci√≥n de dominios invertidos, facilitando la organizaci√≥n del c√≥digo en proyectos m√°s grandes.
    - La funci√≥n `echoMessage` simplemente devuelve el mismo mensaje que recibe. Aunque su comportamiento es sencillo, nos servir√° para verificar que otros m√≥dulos pueden importar y utilizar funcionalidades definidas en esta biblioteca.

    Este m√≥dulo marca el punto de partida para construir una biblioteca bien estructurada, que podr√° crecer y evolucionar conforme avancemos en el curso.
</Explanation>

## üöÄ Paso 4: Crear el m√≥dulo de aplicaci√≥n

Ahora que tenemos una biblioteca reutilizable en `lib`, es momento de crear el subproyecto `app`, encargado de ejecutar la l√≥gica principal del programa. Esta aplicaci√≥n imprimir√° en consola los mensajes recibidos como argumentos, utilizando la funci√≥n `echoMessage` definida previamente.

```scala title="app/src/main/scala/com/github/username/echo/App.scala" showLineNumbers
package com.github.username
package echo

@main def app(args: String*): Unit =
  for arg <- args do
    println(echoMessage(arg))
```

<Explanation>
    Este archivo define la **aplicaci√≥n principal** del proyecto. Su objetivo es utilizar la funcionalidad proporcionada por la biblioteca `lib`.

    - La anotaci√≥n `@main` indica que esta es la funci√≥n de entrada del programa. Scala 3 permite definir puntos de entrada sin necesidad de declarar una clase o `object`.
    - La funci√≥n recibe los argumentos de l√≠nea de comandos como una secuencia variable (`String*`) y los recorre con un bucle `for`.
    - Cada argumento se imprime utilizando la funci√≥n `echoMessage`, definida en el subproyecto `lib`.

    Gracias a esta integraci√≥n, podemos verificar que `app` depende correctamente de `lib`, y que los m√≥dulos se comunican de forma efectiva dentro del mismo proyecto multi-m√≥dulo.
</Explanation>

Este paso demuestra c√≥mo separar la l√≥gica de ejecuci√≥n (aplicaci√≥n) de la l√≥gica reutilizable (biblioteca), una pr√°ctica esencial para construir proyectos bien organizados y escalables.

## üß™ Paso 5: Ejecutar la aplicaci√≥n

Con ambos m√≥dulos ya configurados y conectados, es momento de ejecutar `app` desde la ra√≠z del proyecto para comprobar que la integraci√≥n entre m√≥dulos funciona correctamente.

```bash
sbt "app/run Alex Dim Nah Dim"
```

Deber√≠as ver una salida como esta:

```plaintext
Alex
Dim
Nah
Dim
```

<Explanation>
    En este paso usamos el comando `sbt "app/run"` para compilar y ejecutar el subproyecto `app`.  
    Los argumentos que siguen (`Alex Dim Nah Dim`) se env√≠an directamente a la funci√≥n `@main` definida en `App.scala`.

    - Scala ejecuta la funci√≥n principal con los argumentos indicados.
    - Cada uno se procesa mediante `echoMessage`, definida en el subproyecto `lib`, y se imprime por separado.
    - Elegimos nombres de personajes de *A Clockwork Orange* como una forma divertida de verificar el comportamiento del programa.

    Este paso valida que la **estructura modular del proyecto est√° funcionando**: `app` puede usar sin problemas la l√≥gica definida en `lib`, y sbt maneja correctamente la compilaci√≥n y ejecuci√≥n de ambos m√≥dulos.
</Explanation>

Con esta ejecuci√≥n completamos la primera prueba de integraci√≥n de nuestro proyecto multi-m√≥dulo. A partir de aqu√≠, podemos escalar la aplicaci√≥n o la biblioteca de forma independiente, manteniendo una separaci√≥n clara de responsabilidades.

## üéØ Conclusiones

Dividir un proyecto en m√∫ltiples m√≥dulos no solo mejora la organizaci√≥n del c√≥digo, sino que sienta las bases para desarrollar software m√°s **escalable**, **reutilizable** y **mantenible**. En esta lecci√≥n aprendimos a estructurar un proyecto multi-m√≥dulo con sbt, separando la l√≥gica principal de la aplicaci√≥n (`app`) de una biblioteca reutilizable (`lib`), todo dentro de una configuraci√≥n com√∫n y coherente.

Tambi√©n exploramos c√≥mo ejecutar la aplicaci√≥n con argumentos personalizados, lo que nos permiti√≥ validar la integraci√≥n entre m√≥dulos y ver en acci√≥n una arquitectura modular.

### üîë Puntos clave

- sbt permite declarar m√∫ltiples subproyectos con `lazy val` dentro de un √∫nico `build.sbt`.
- Compartir `commonSettings` asegura coherencia entre m√≥dulos y simplifica la configuraci√≥n global.
- La directiva `.dependsOn(...)` conecta m√≥dulos para compartir funcionalidades de forma expl√≠cita.
- Scala 3 permite usar `@main` para definir puntos de entrada sin necesidad de `object` o `App`.
- Para ejecutar un subproyecto, usamos `sbt "nombreModulo/run"` desde la ra√≠z del proyecto.

### üß∞ ¬øQu√© nos llevamos?

Esta lecci√≥n no solo mostr√≥ c√≥mo configurar un proyecto multi-m√≥dulo, sino **por qu√© conviene hacerlo desde el inicio**.  
Aprendimos a separar responsabilidades, reducir el acoplamiento y preparar la base del proyecto para escalar con claridad.

Con esta estructura podemos:

- A√±adir nuevas funcionalidades en `lib` sin afectar directamente a `app`.
- Reutilizar la biblioteca en otros proyectos si es necesario.
- Incorporar m√°s m√≥dulos (como pruebas, documentaci√≥n o herramientas internas) sin perder orden ni coherencia.

Empezamos con un simple "echo" y terminamos con una **arquitectura preparada para crecer**. En el desarrollo de bibliotecas, **modularizar desde el principio** es una decisi√≥n clave para crear proyectos sostenibles y profesionales.

<div class="exclude-from-reading-time">
## üìñ Referencias

### üî• Recomendadas

- [üåê *"Multi-project builds"*](https://www.scala-sbt.org/1.x/docs/Multi-Project.html) en **la documentaci√≥n oficial de sbt**: Introduce c√≥mo estructurar m√∫ltiples subproyectos en un mismo `build.sbt`. Explica c√≥mo definir m√≥dulos (`lazy val`), compartir configuraciones y establecer dependencias con `.dependsOn(...)`. Es clave para entender la arquitectura modular en sbt.

### üîπ Adicionales

- [üé• *"SBT in Scala (part 2) - Setting up Modules, Organizing Builds, Using Plugins"*](https://www.youtube.com/watch?v=HBZDKt9ZqSg) (19m40s) en *YouTube* por **Rock the JVM**: Muestra paso a paso c√≥mo crear un proyecto multi-m√≥dulo en sbt y aplicar buenas pr√°cticas como centralizar configuraciones, usar plugins y definir constantes en archivos Scala. Ideal para complementar la teor√≠a con un caso pr√°ctico.
</div>