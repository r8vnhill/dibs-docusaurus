---
title: Estructurando Proyectos Multi-M贸dulo con sbt
---

import ReadingTime from '@site/src/components/ReadingTime'
import Explanation from '@site/src/components/admonitions/Explanation'
import BoxedTabs from '@site/src/components/cajitas/BoxedTabs'
import TabItem from '@theme/TabItem'
import GithubRepoLink from '@site/src/components/GithubRepoLink'

<ReadingTime />
<GithubRepoLink user="r8vnhill" repo="echo-app-sbt" />

Antes de que una biblioteca crezca, antes de agregar pruebas o automatizar tareas, es importante estructurar bien el proyecto. Si en la lecci贸n anterior aprendiste a crear un proyecto b谩sico con sbt y a ejecutar tu primer programa en Scala 3, esta vez daremos un paso m谩s all谩: **separar tu aplicaci贸n en m贸dulos**.

En esta lecci贸n aprender谩s a organizar un proyecto multi-m贸dulo utilizando sbt, una pr谩ctica esencial para el desarrollo de bibliotecas reutilizables y aplicaciones escalables. A trav茅s de un ejemplo simple pero completo, veremos c贸mo:

- Definir m煤ltiples subproyectos (`lib` y `app`) dentro de un mismo `build.sbt`.
- Compartir configuraciones comunes entre m贸dulos.
- Reutilizar l贸gica definida en un m贸dulo desde otro.
- Ejecutar un subproyecto espec铆fico desde la l铆nea de comandos.

Este enfoque modular te permitir谩 escribir c贸digo m谩s limpio, reutilizable y f谩cil de mantener. Lo que empieza como un proyecto simple, puede convertirse en una base s贸lida para bibliotecas profesionales.  
Vamos paso a paso hacia una arquitectura que escala.

## П Paso 1: Declarar los m贸dulos del proyecto

Para transformar nuestro proyecto en una estructura multi-m贸dulo, comenzamos por definir sus componentes principales dentro del archivo `build.sbt` ra铆z:

```scala title="build.sbt"
val scala3Version = "3.6.4"

lazy val commonSettings = Seq(
    scalaVersion := scala3Version
)

lazy val lib = project
  .in(file("lib"))
  .settings(commonSettings *)

lazy val app = project
  .in(file("app"))
  .dependsOn(lib)
  .settings(commonSettings *)
```

<Explanation>
    En este paso transformamos nuestro proyecto en una **estructura multi-m贸dulo**, lo que nos permite separar responsabilidades entre distintos componentes (por ejemplo, una biblioteca reutilizable y una aplicaci贸n principal).

    - Primero definimos `scala3Version` como una variable para centralizar la versi贸n del compilador.
    - Luego creamos una lista llamada `commonSettings` que contiene configuraciones compartidas, como `scalaVersion`.
    - A continuaci贸n declaramos dos m贸dulos (`lib` y `app`) usando `lazy val`:
        - `lib` se encuentra en el subdirectorio `lib/` y recibe las configuraciones comunes.
        - `app` se encuentra en `app/`, tambi茅n hereda las configuraciones comunes y depende expl铆citamente de `lib` usando `.dependsOn(lib)`.

    Usamos **`lazy val`** porque `sbt` necesita construir la estructura del proyecto de forma perezosa (lazy): permite que las referencias entre proyectos (como `app.dependsOn(lib)`) se resuelvan sin problemas incluso si a煤n no se han evaluado por completo.  
    Esto evita errores de orden de inicializaci贸n y permite que `sbt` maneje correctamente las dependencias entre m贸dulos.
</Explanation>

Esta estructura modular es especialmente 煤til en proyectos de bibliotecas, ya que permite mantener el c贸digo reutilizable separado del c贸digo espec铆fico de una aplicaci贸n o herramienta.

:::tip Limpieza de la estructura inicial

Puedes eliminar el directorio `src/` que se cre贸 autom谩ticamente en la ra铆z del proyecto.  
En una arquitectura multi-m贸dulo como la que estamos construyendo, la l贸gica del programa y las pruebas estar谩n organizadas en subdirectorios espec铆ficos, como `lib/` y `app/`.

Esto ayuda a evitar confusiones y asegura que todo el c贸digo est茅 correctamente encapsulado en sus respectivos m贸dulos.

:::


##  Paso 2: Crear un m贸dulo de biblioteca

Ahora que declaramos el subproyecto `lib`, podemos comenzar a escribir c贸digo reutilizable en su interior. A continuaci贸n, definimos una funci贸n simple que devolver谩 el mismo mensaje que recibe:

```scala title="lib/src/main/scala/com/github/username/echo/echoMessage.scala" showLineNumbers
package com.github.username
package echo

def echoMessage(message: String): String = message
```

<Explanation>
    En este archivo definimos un **m贸dulo reutilizable** que forma parte del subproyecto `lib`.

    - El paquete base `com.github.username.echo` sigue la convenci贸n de dominios invertidos y refleja la ubicaci贸n f铆sica del archivo.
    - La funci贸n `echoMessage` es una funci贸n pura que simplemente devuelve el mensaje recibido. Aunque es trivial, nos servir谩 como punto de partida para probar la integraci贸n entre m贸dulos m谩s adelante.

    Este m贸dulo no contiene l贸gica compleja, pero ilustra c贸mo empezar a construir una biblioteca **modular y reutilizable**.
</Explanation>

##  Paso 3: Crear el m贸dulo de aplicaci贸n

Ahora que tenemos una biblioteca reutilizable en `lib`, creamos el subproyecto `app`, encargado de ejecutar la l贸gica principal del programa. Esta aplicaci贸n imprimir谩 en consola los mensajes recibidos como argumentos, usando la funci贸n `echoMessage` definida previamente.

```scala title="app/src/main/scala/com/github/username/echo/app.scala" showLineNumbers
package com.github.username
package echo

@main def app(args: String*): Unit =
  for arg <- args do
    println(echoMessage(arg))
```

<Explanation>
    Esta es la **aplicaci贸n principal** del proyecto. Su objetivo es consumir la biblioteca definida en el m贸dulo `lib`.

    - El `@main` marca el punto de entrada de la aplicaci贸n. Scala 3 permite declarar funciones de entrada sin necesidad de una clase o `object`.
    - Recibimos argumentos de l铆nea de comandos como un `String*` (varargs), y los recorremos con un bucle `for`.
    - Cada argumento se imprime usando la funci贸n `echoMessage` que definimos en el m贸dulo de biblioteca.
</Explanation>

Este ejemplo demuestra c贸mo integrar distintos m贸dulos en un proyecto multi-m贸dulo con sbt, separando claramente la l贸gica reutilizable de la l贸gica de ejecuci贸n.

## И Paso 4: Ejecutar la aplicaci贸n

Con ambos m贸dulos ya configurados y conectados, podemos ejecutar nuestra aplicaci贸n `app` desde la ra铆z del proyecto para probar que la integraci贸n funciona correctamente.

```bash
sbt "app/run Alex Dim Nah Dim"
```

Deber铆as ver una salida como la siguiente:

```plaintext
Alex
Dim
Nah
Dim
```

<Explanation>
    En este paso utilizamos el comando `sbt` seguido de `"app/run"` para indicar que queremos ejecutar el m贸dulo `app`.  
    Pasamos como argumentos una serie de nombres inspirados en los personajes de *A Clockwork Orange*, que ser谩n procesados por nuestra funci贸n `echoMessage`.

    - `sbt` reconoce `"app/run"` como una instrucci贸n para compilar y ejecutar el subproyecto `app`.
    - Los argumentos posteriores (`Alex Dim Nah Dim`) son pasados directamente a la funci贸n `@main` que definimos en el archivo `app.scala`.
    - Cada uno se imprime individualmente, demostrando que el programa funciona correctamente y que la comunicaci贸n entre m贸dulos est谩 activa.
</Explanation>

Este paso nos permite verificar no solo la funcionalidad del programa, sino tambi茅n la correcta **organizaci贸n del proyecto y resoluci贸n de dependencias** entre los m贸dulos `app` y `lib`.

##  Conclusiones

Dividir un proyecto en m煤ltiples m贸dulos no solo ayuda a organizar mejor el c贸digo, sino que sienta las bases para desarrollar software m谩s escalable, reutilizable y f谩cil de mantener.  
En esta lecci贸n aprendimos a estructurar un proyecto multi-m贸dulo en sbt, separando la l贸gica principal de una aplicaci贸n de consola (`app`) de una biblioteca reutilizable (`lib`), todo dentro de una configuraci贸n com煤n y coherente.

Adem谩s, exploramos c贸mo ejecutar la aplicaci贸n con argumentos personalizados, lo que nos permiti贸 verificar la comunicaci贸n entre los m贸dulos y tener un primer vistazo al dise帽o modular en acci贸n.

###  Puntos clave

- sbt permite declarar m煤ltiples subproyectos en un solo archivo `build.sbt`, usando `lazy val`.
- Usar `commonSettings` ayuda a mantener consistencia entre m贸dulos y facilita la configuraci贸n global.
- El uso de `.dependsOn(...)` permite conectar m贸dulos y compartir funcionalidades entre ellos.
- Scala 3 permite definir funciones de entrada con `@main`, simplificando la estructura del programa.
- Ejecutar un subproyecto requiere usar `"nombreModulo/run"` dentro del comando `sbt`.

### О 驴Qu茅 nos llevamos?

Esta lecci贸n no solo nos ense帽贸 c贸mo configurar un proyecto multi-m贸dulo, sino por qu茅 vale la pena hacerlo desde el comienzo.  
Aprendimos a modularizar nuestra base de c贸digo para poder escalarla con claridad, separando responsabilidades y evitando acoplamientos innecesarios.

Ahora contamos con una estructura s贸lida para:

- A帽adir m谩s funcionalidades a la biblioteca (`lib`) sin afectar directamente la aplicaci贸n (`app`).
- Reutilizar esa misma biblioteca en otros proyectos si lo necesitamos.
- Incorporar m谩s m贸dulos en el futuro, como pruebas, documentaci贸n o herramientas internas.

Empezamos con un simple "echo" y terminamos con una arquitectura preparada para crecer.  
En el desarrollo de bibliotecas, esta capacidad de modularizar desde el principio es un paso esencial hacia proyectos profesionales, sostenibles y colaborativos.

##  Referencias

###  Recomendadas

-  sbt Reference ManualMulti-project builds. (s.f.). Recuperado 5 de abril de 2025, de https://www.scala-sbt.org/1.x/docs/Multi-Project.html

{/* ###  Adicionales */}
