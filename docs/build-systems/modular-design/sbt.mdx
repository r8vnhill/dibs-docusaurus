---
title: Modularizando tu proyecto Scala con sbt
---

import ReadingTime from '@site/src/components/ReadingTime'
import Explanation from '@site/src/components/admonitions/Explanation'
import BoxedTabs from '@site/src/components/cajitas/BoxedTabs'
import TabItem from '@theme/TabItem'
import GithubRepoLink from '@site/src/components/GithubRepoLink'
import Ps from '@site/src/components/mdx/build-systems/modular-design/sbt/ps.mdx'
import Bash from '@site/src/components/mdx/build-systems/modular-design/sbt/bash.mdx'
import Glossary from '@site/src/components/admonitions/Glossary'

<ReadingTime />
<GithubRepoLink user="r8vnhill" repo="echo-app-sbt" />

Antes de que una biblioteca crezca ‚Äîantes de agregar pruebas o automatizar tareas‚Äî, es fundamental estructurar bien el proyecto. Si en la lecci√≥n anterior aprendiste a crear un proyecto b√°sico con sbt y a ejecutar tu primer programa en Scala 3, esta vez daremos un paso m√°s all√°: **modularizar tu aplicaci√≥n**.

En esta lecci√≥n aprender√°s a organizar un proyecto multi-m√≥dulo con sbt, una pr√°ctica esencial para desarrollar bibliotecas reutilizables y aplicaciones escalables. A trav√©s de un ejemplo simple pero completo, veremos c√≥mo:

- Definir m√∫ltiples subproyectos (`lib` y `app`) dentro de un mismo `build.sbt`.
- Compartir configuraciones comunes entre m√≥dulos.
- Reutilizar l√≥gica definida en un m√≥dulo desde otro.
- Ejecutar un subproyecto espec√≠fico desde la l√≠nea de comandos.

Este enfoque modular te permitir√° escribir c√≥digo m√°s limpio, reutilizable y f√°cil de mantener. Lo que comienza como un proyecto simple puede convertirse en una base s√≥lida para bibliotecas profesionales. **Paso a paso, construimos una arquitectura que Scala (hehe).**

<Glossary>

- **Multi-m√≥dulo**: Estructura de proyecto donde el c√≥digo se divide en varios subproyectos (`lib`, `app`, etc.), cada uno con su propia funcionalidad. Permite separar responsabilidades y facilita el mantenimiento y la escalabilidad del c√≥digo.
- **`build.sbt`**: Archivo de configuraci√≥n principal de sbt. Define los m√≥dulos del proyecto, sus dependencias, configuraciones compartidas y m√°s.
- **Paquete**: Estructura jer√°rquica utilizada para organizar el c√≥digo en namespaces. En Scala se suelen usar dominios invertidos, como `com.github.username.echo`.

</Glossary>

## üèóÔ∏è Estructura esperada del proyecto

Antes de configurar el `build.sbt`, es importante visualizar c√≥mo estar√° organizado el proyecto. Nuestro objetivo es dividirlo en dos subproyectos: una **biblioteca (`lib`)** que contendr√° la l√≥gica de negocio reutilizable, y una **aplicaci√≥n (`app`)** que funcionar√° como punto de entrada y consumir√° esa biblioteca.

La siguiente estructura refleja esta separaci√≥n, mostrando c√≥mo se distribuyen los archivos fuente dentro de cada m√≥dulo y c√≥mo se conectan entre s√≠:

```mermaid
graph TD
    subgraph Root [üìÅ echo-app-sbt]
        direction TB

        Build[üìÑ build.sbt]

        subgraph Lib [üìÅ lib]
            subgraph LibMain [üìÅ src/main/scala]
                subgraph LibPkg [üìÅ com/github/username/echo]
                    LibCode[üìÑ EchoMessage.scala]
                end
            end
        end

        subgraph App [üìÅ app]
            subgraph AppMain [üìÅ src/main/scala]
                subgraph AppPkg [üìÅ com/github/username/echo]
                    AppCode[üìÑ App.scala]
                end
            end
        end
    end

    Build --> Lib
    Build --> App
    App -->|depende de| Lib
```

:::info Explicaci√≥n de la estructura

Este proyecto est√° dividido en dos m√≥dulos: una biblioteca (`lib`) y una aplicaci√≥n (`app`). Ambos son definidos en el archivo ra√≠z `build.sbt`, lo que permite que compartan configuraciones y se compilen como parte del mismo proyecto.

- `lib/` contiene la l√≥gica de negocio reutilizable, organizada en el paquete `com.github.username.echo`.
- `app/` define la aplicaci√≥n que importa y utiliza la funcionalidad de `lib`, dentro del mismo paquete para mantener consistencia.
- `EchoMessage.scala` representa una funci√≥n o clase reutilizable en la biblioteca.
- `App.scala` act√∫a como punto de entrada de la aplicaci√≥n.
- El subproyecto `app` declara una dependencia directa sobre `lib`, lo que permite acceder a su c√≥digo sin necesidad de duplicaci√≥n.

Esta estructura modular refleja buenas pr√°cticas de dise√±o en proyectos reales, donde la separaci√≥n entre l√≥gica de negocio y l√≥gica de ejecuci√≥n permite mayor claridad, mantenibilidad y escalabilidad.

:::

:::tip ¬øY la carpeta `src/` que hab√≠amos creado antes?

Puedes eliminar el directorio `src/` que creaste en la lecci√≥n anterior, o guardarlo como recuerdo.

:::


## üì¶ Paso 1: Crear la estructura de carpetas

<BoxedTabs groupId={"os"}>
    <TabItem value="Windows" label="Windows">
        <Ps />
    </TabItem>
    <TabItem value="macOS" label="macOS">
        <Bash />
    </TabItem>
    <TabItem value="Ubuntu/Debian" label="Ubuntu/Debian">
        <Bash />
    </TabItem>
</BoxedTabs>


## üß± Paso 2: Declarar los m√≥dulos del proyecto

Para transformar nuestro proyecto en una estructura multi-m√≥dulo, comenzamos por definir sus componentes principales dentro del archivo `build.sbt` ra√≠z:

```scala showLineNumbers title="build.sbt"
val scala3Version = "3.6.4"

lazy val commonSettings = Seq(
    scalaVersion := scala3Version
)

lazy val lib = project
  .in(file("lib"))
  .settings(commonSettings *)

lazy val app = project
  .in(file("app"))
  .dependsOn(lib)
  .settings(commonSettings *)
```

<Explanation>
    En este paso transformamos nuestro proyecto en una **estructura multi-m√≥dulo**, lo que nos permite separar responsabilidades entre distintos componentes (por ejemplo, una biblioteca reutilizable y una aplicaci√≥n principal).

    - Primero definimos `scala3Version` como una variable para centralizar la versi√≥n del compilador.
    - Luego creamos una lista llamada `commonSettings` que contiene configuraciones compartidas, como `scalaVersion`.
    - A continuaci√≥n declaramos dos m√≥dulos (`lib` y `app`) usando `lazy val`:
        - `lib` se encuentra en el subdirectorio `lib/` y recibe las configuraciones comunes.
        - `app` se encuentra en `app/`, tambi√©n hereda las configuraciones comunes y depende expl√≠citamente de `lib` usando `.dependsOn(lib)`.

    Usamos **`lazy val`** porque `sbt` necesita construir la estructura del proyecto de forma perezosa (lazy): permite que las referencias entre proyectos (como `app.dependsOn(lib)`) se resuelvan sin problemas incluso si a√∫n no se han evaluado por completo.  
    Esto evita errores de orden de inicializaci√≥n y permite que `sbt` maneje correctamente las dependencias entre m√≥dulos.
</Explanation>

Esta estructura modular es especialmente √∫til en proyectos de bibliotecas, ya que permite mantener el c√≥digo reutilizable separado del c√≥digo espec√≠fico de una aplicaci√≥n o herramienta.

## üì¶ Paso 3: Crear el m√≥dulo de biblioteca

Una vez declarado el subproyecto `lib`, es momento de comenzar a escribir la l√≥gica de negocio que deseamos reutilizar. Empezaremos con una funci√≥n sencilla, pensada para ser consumida desde otros m√≥dulos:

```scala title="lib/src/main/scala/com/github/username/echo/EchoMessage.scala" showLineNumbers
package com.github.username
package echo

def echoMessage(message: String): String = message
```

<Explanation>
    Este archivo define un **componente reutilizable** dentro del subproyecto `lib`.

    - El paquete `com.github.username.echo` sigue la convenci√≥n de dominios invertidos, facilitando la organizaci√≥n del c√≥digo en proyectos m√°s grandes.
    - La funci√≥n `echoMessage` simplemente devuelve el mismo mensaje que recibe. Aunque su comportamiento es sencillo, nos servir√° para verificar que otros m√≥dulos pueden importar y utilizar funcionalidades definidas en esta biblioteca.

    Este m√≥dulo marca el punto de partida para construir una biblioteca bien estructurada, que podr√° crecer y evolucionar conforme avancemos en el curso.
</Explanation>

## üöÄ Paso 4: Crear el m√≥dulo de aplicaci√≥n

Ahora que tenemos una biblioteca reutilizable en `lib`, es momento de crear el subproyecto `app`, encargado de ejecutar la l√≥gica principal del programa. Esta aplicaci√≥n imprimir√° en consola los mensajes recibidos como argumentos, utilizando la funci√≥n `echoMessage` definida previamente.

```scala title="app/src/main/scala/com/github/username/echo/App.scala" showLineNumbers
package com.github.username
package echo

@main def app(args: String*): Unit =
  for arg <- args do
    println(echoMessage(arg))
```

<Explanation>
    Este archivo define la **aplicaci√≥n principal** del proyecto. Su objetivo es utilizar la funcionalidad proporcionada por la biblioteca `lib`.

    - La anotaci√≥n `@main` indica que esta es la funci√≥n de entrada del programa. Scala 3 permite definir puntos de entrada sin necesidad de declarar una clase o `object`.
    - La funci√≥n recibe los argumentos de l√≠nea de comandos como una secuencia variable (`String*`) y los recorre con un bucle `for`.
    - Cada argumento se imprime utilizando la funci√≥n `echoMessage`, definida en el subproyecto `lib`.

    Gracias a esta integraci√≥n, podemos verificar que `app` depende correctamente de `lib`, y que los m√≥dulos se comunican de forma efectiva dentro del mismo proyecto multi-m√≥dulo.
</Explanation>

Este paso demuestra c√≥mo separar la l√≥gica de ejecuci√≥n (aplicaci√≥n) de la l√≥gica reutilizable (biblioteca), una pr√°ctica esencial para construir proyectos bien organizados y escalables.

## üß™ Paso 5: Ejecutar la aplicaci√≥n

Con ambos m√≥dulos ya configurados y conectados, es momento de ejecutar `app` desde la ra√≠z del proyecto para comprobar que la integraci√≥n entre m√≥dulos funciona correctamente.

```bash
sbt "app/run Alex Dim Nah Dim"
```

Deber√≠as ver una salida como esta:

```plaintext
Alex
Dim
Nah
Dim
```

<Explanation>
    En este paso usamos el comando `sbt "app/run"` para compilar y ejecutar el subproyecto `app`.  
    Los argumentos que siguen (`Alex Dim Nah Dim`) se env√≠an directamente a la funci√≥n `@main` definida en `App.scala`.

    - Scala ejecuta la funci√≥n principal con los argumentos indicados.
    - Cada uno se procesa mediante `echoMessage`, definida en el subproyecto `lib`, y se imprime por separado.
    - Elegimos nombres de personajes de *A Clockwork Orange* como una forma divertida de verificar el comportamiento del programa.

    Este paso valida que la **estructura modular del proyecto est√° funcionando**: `app` puede usar sin problemas la l√≥gica definida en `lib`, y sbt maneja correctamente la compilaci√≥n y ejecuci√≥n de ambos m√≥dulos.
</Explanation>

Con esta ejecuci√≥n completamos la primera prueba de integraci√≥n de nuestro proyecto multi-m√≥dulo. A partir de aqu√≠, podemos escalar la aplicaci√≥n o la biblioteca de forma independiente, manteniendo una separaci√≥n clara de responsabilidades.

## üéØ Conclusiones

Dividir un proyecto en m√∫ltiples m√≥dulos no solo mejora la organizaci√≥n del c√≥digo, sino que sienta las bases para desarrollar software m√°s **escalable**, **reutilizable** y **mantenible**. En esta lecci√≥n aprendimos a estructurar un proyecto multi-m√≥dulo con sbt, separando la l√≥gica principal de la aplicaci√≥n (`app`) de una biblioteca reutilizable (`lib`), todo dentro de una configuraci√≥n com√∫n y coherente.

Tambi√©n exploramos c√≥mo ejecutar la aplicaci√≥n con argumentos personalizados, lo que nos permiti√≥ validar la integraci√≥n entre m√≥dulos y ver en acci√≥n una arquitectura modular.

### üîë Puntos clave

- sbt permite declarar m√∫ltiples subproyectos con `lazy val` dentro de un √∫nico `build.sbt`.
- Compartir `commonSettings` asegura coherencia entre m√≥dulos y simplifica la configuraci√≥n global.
- La directiva `.dependsOn(...)` conecta m√≥dulos para compartir funcionalidades de forma expl√≠cita.
- Scala 3 permite usar `@main` para definir puntos de entrada sin necesidad de `object` o `App`.
- Para ejecutar un subproyecto, usamos `sbt "nombreModulo/run"` desde la ra√≠z del proyecto.

### üß∞ ¬øQu√© nos llevamos?

Esta lecci√≥n no solo mostr√≥ c√≥mo configurar un proyecto multi-m√≥dulo, sino **por qu√© conviene hacerlo desde el inicio**.  
Aprendimos a separar responsabilidades, reducir el acoplamiento y preparar la base del proyecto para escalar con claridad.

Con esta estructura podemos:

- A√±adir nuevas funcionalidades en `lib` sin afectar directamente a `app`.
- Reutilizar la biblioteca en otros proyectos si es necesario.
- Incorporar m√°s m√≥dulos (como pruebas, documentaci√≥n o herramientas internas) sin perder orden ni coherencia.

Empezamos con un simple "echo" y terminamos con una **arquitectura preparada para crecer**. En el desarrollo de bibliotecas, **modularizar desde el principio** es una decisi√≥n clave para crear proyectos sostenibles y profesionales.

<div class="exclude-from-reading-time">
## üìñ Referencias

### üî• Recomendadas

- [üåê *"Multi-project builds"*](https://www.scala-sbt.org/1.x/docs/Multi-Project.html) en **la documentaci√≥n oficial de sbt**: Introduce c√≥mo estructurar m√∫ltiples subproyectos en un mismo `build.sbt`. Explica c√≥mo definir m√≥dulos (`lazy val`), compartir configuraciones y establecer dependencias con `.dependsOn(...)`. Es clave para entender la arquitectura modular en sbt.

### üîπ Adicionales

- [üé• *"SBT in Scala (part 2) - Setting up Modules, Organizing Builds, Using Plugins"*](https://www.youtube.com/watch?v=HBZDKt9ZqSg) (19m40s) en *YouTube* por **Rock the JVM**: Muestra paso a paso c√≥mo crear un proyecto multi-m√≥dulo en sbt y aplicar buenas pr√°cticas como centralizar configuraciones, usar plugins y definir constantes en archivos Scala. Ideal para complementar la teor√≠a con un caso pr√°ctico.
</div>