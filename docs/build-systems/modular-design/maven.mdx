---
title: Arquitectura Modular con Maven y Java
---
import ReadingTime from '@site/src/components/ReadingTime'
import { ProCons, Pros, Cons } from '@site/src/components/cajitas/ProCons'
import References from '@site/src/components/ReferencesComponent'
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'
import Exercise from '@site/src/components/exercise/Exercise'
import Solution from '@site/src/components/exercise/Solution'
import Hint from '@site/src/components/exercise/Hint'
import Definition from '@site/src/components/Definition'
import Corollary from '@site/src/components/Corollary'
import GithubRepoLink from '@site/src/components/git/GithubRepoLink'
import { LanguageCard, PoetryCard } from '@site/src/components/cards/LanguageCard'
import Explanation from '@site/src/components/admonitions/Explanation'
import RepoClone from '@site/src/components/admonitions/RepoClone'
import BoxedTabs from '@site/src/components/cajitas/BoxedTabs'

<ReadingTime />
<GithubRepoLink user="r8vnhill" repo="echo-app-maven" />

A medida que los proyectos crecen, mantener todo el c√≥digo en un solo m√≥dulo se vuelve poco pr√°ctico. La soluci√≥n est√° en adoptar una **arquitectura modular**, que permita dividir el sistema en partes m√°s peque√±as, reutilizables y mantenibles. Maven, una de las herramientas m√°s populares del ecosistema Java, nos permite implementar esta arquitectura de forma sencilla mediante el uso de proyectos multi-m√≥dulo.

En esta lecci√≥n aprender√°s a transformar un proyecto b√°sico en una estructura modular con Maven. Ver√°s c√≥mo declarar m√≥dulos, reutilizar c√≥digo entre ellos y mantener una organizaci√≥n clara y escalable. Esta es una pr√°ctica esencial cuando desarrollamos **librer√≠as de software** que deben ser f√°ciles de mantener, probar y extender.

Partiremos de un proyecto simple y lo dividiremos en dos m√≥dulos:  
- `lib`, que contiene utilidades reutilizables, y  
- `app`, la aplicaci√≥n principal que depende de `lib`.

Ver√°s c√≥mo configurar los `pom.xml` para conectar estos m√≥dulos entre s√≠, c√≥mo compilar y ejecutar la aplicaci√≥n desde la l√≠nea de comandos, y c√≥mo entender la jerarqu√≠a de un proyecto multi-m√≥dulo.

Todo esto te dar√° una base s√≥lida para dise√±ar bibliotecas profesionales, manteniendo una estructura clara y preparada para escalar.

## üß± Paso 1: Declarar los m√≥dulos del proyecto

Ahora que ya tienes un proyecto Maven b√°sico, es momento de escalar su estructura dividi√©ndolo en **m√≥dulos independientes**.  
Esto te permitir√° separar responsabilidades, reutilizar c√≥digo y preparar tu proyecto para crecer de forma limpia y organizada.

Para comenzar, modifica el archivo `pom.xml` en la ra√≠z del proyecto para declarar los m√≥dulos que lo compondr√°n: `lib` (una biblioteca reutilizable) y `app` (la aplicaci√≥n principal que depender√° de `lib`).

```xml showLineNumbers title="pom.xml (ra√≠z)"
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0
         https://maven.apache.org/maven-v4_0_0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>com.github.username</groupId>
    <artifactId>echo-app-maven</artifactId>
    <packaging>pom</packaging>
    <version>1.0.0</version>
    <name>echo-app-maven</name>

    <modules>
        <module>lib</module>
        <module>app</module>
    </modules>
</project>
```

<Explanation>
    - **`<packaging>pom</packaging>`**: Indica que este proyecto no produce un artefacto (como un `.jar`), sino que act√∫a como **contenedor** de otros m√≥dulos.
    - **`<modules>`**: Enumera los subm√≥dulos del proyecto. Cada entrada debe coincidir con el nombre de una carpeta existente dentro del directorio ra√≠z.
</Explanation>

Esta declaraci√≥n permite a Maven entender c√≥mo se organiza tu proyecto y en qu√© orden deben compilarse los m√≥dulos.

## üì¶ Paso 2: Crear un m√≥dulo de biblioteca

Comenzaremos creando el primer subm√≥dulo de nuestro proyecto: una biblioteca llamada `lib`.  
Este m√≥dulo contendr√° funcionalidades reutilizables que luego ser√°n utilizadas por la aplicaci√≥n principal.

### üìÑ Crear el `pom.xml` del m√≥dulo `lib`

Dentro de la carpeta `lib/`, crea un archivo `pom.xml` con el siguiente contenido:

```xml showLineNumbers title="lib/pom.xml"
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0
         http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <parent>
        <groupId>com.github.username</groupId>
        <artifactId>echo-app-maven</artifactId>
        <version>1.0.0</version>
    </parent>

    <artifactId>lib</artifactId>
</project>
```

<Explanation>
    - **`<parent>`**: Este bloque indica que el m√≥dulo `lib` **hereda configuraci√≥n** del proyecto ra√≠z, incluyendo el `groupId`, las propiedades compartidas y futuras configuraciones comunes.
    - **`<artifactId>lib</artifactId>`**: Define el nombre del artefacto generado para este m√≥dulo.
</Explanation>

### üì¢ Crear una utilidad en el m√≥dulo `lib`

Ahora agregaremos una clase simple con una funci√≥n que el m√≥dulo `app` podr√° utilizar para mostrar mensajes.

```java showLineNumbers title="lib/src/main/java/com/github/username/echo/EchoUtils.java"
package com.github.username.echo;

public class EchoUtils {
    public static String echoMessage(String message) {
        return message;
    }
}
```

<Explanation>
    Esta clase representa una **utilidad b√°sica** que simplemente devuelve el mensaje recibido.  
    La funci√≥n `echoMessage` es **est√°tica** (`static`) para que podamos llamarla sin necesidad de crear una instancia de `EchoUtils`.

    Veremos los m√©todos est√°ticos m√°s adelante en detalle, pero por ahora basta con saber que los usamos en este caso porque **no necesitamos guardar ni modificar ning√∫n estado interno**: solo queremos agrupar una operaci√≥n que es pura y reutilizable.

    Este tipo de dise√±o es com√∫n en bibliotecas que exponen funciones utilitarias sencillas.
</Explanation>

## üöÄ Paso 3: Crear el m√≥dulo de aplicaci√≥n

Despu√©s de definir el m√≥dulo `lib`, es momento de crear el m√≥dulo `app`, el cual ser√° responsable de la l√≥gica principal de la aplicaci√≥n y **depender√°** del m√≥dulo `lib`.

### üìÑ Crear el `pom.xml` del m√≥dulo `app`

Crea un archivo llamado `pom.xml` dentro de la carpeta `app` con el siguiente contenido:

```xml showLineNumbers title="app/pom.xml"
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0
         http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <parent>
        <groupId>com.github.username</groupId>
        <artifactId>echo-app-maven</artifactId>
        <version>1.0.0</version>
    </parent>

    <artifactId>app</artifactId>

    <dependencies>
        <dependency>
            <groupId>com.github.username</groupId>
            <artifactId>lib</artifactId>
            <version>1.0.0</version>
        </dependency>
    </dependencies>
</project>
```

<Explanation>
    Este archivo define al m√≥dulo `app` como un subproyecto del proyecto ra√≠z `echo-app-maven`.  

    - El bloque `<parent>` indica que este m√≥dulo **hereda configuraci√≥n** del `pom.xml` ra√≠z. Esto incluye propiedades comunes, repositorios y posibles versiones definidas en un BOM.
    - Con `<artifactId>app</artifactId>`, damos un nombre √∫nico a este m√≥dulo dentro del proyecto.
    - En `<dependencies>`, declaramos expl√≠citamente que `app` **depende del m√≥dulo `lib`**, permiti√©ndole reutilizar sus clases y funciones.
</Explanation>

### üß™ Crear la clase principal de la aplicaci√≥n

Ahora vamos a crear la clase `App`, que servir√° como **punto de entrada** del programa. Esta clase utilizar√° el m√≥dulo `lib` para imprimir cada argumento recibido.

```java showLineNumbers title="app/src/main/java/com/github/username/App.java"
package com.github.username;

import com.github.username.echo.EchoUtils;

public class App {
    public static void main(String[] args) {
        for (String arg : args) {
            System.out.println(EchoUtils.echoMessage(arg));
        }
    }
}
```

<Explanation>
    Esta clase representa el **inicio del programa**. Su funci√≥n `main` recorre los argumentos pasados por consola (`args`) y, por cada uno, llama al m√©todo `echoMessage` de `EchoUtils`.

    - **`import com.github.username.echo.EchoUtils;`**: Importamos la clase del m√≥dulo `lib` que creamos previamente.
    - **`main(String[] args)`**: Es el punto de entrada est√°ndar en aplicaciones Java.
    - **`for (String arg : args)`**: Usamos un ciclo `for-each` para recorrer los argumentos.
    - **`EchoUtils.echoMessage(arg)`**: Delegamos la l√≥gica al m√≥dulo `lib`.
</Explanation>

## ‚ñ∂Ô∏è Paso 4: Compilar y ejecutar la aplicaci√≥n

Ahora que tienes definidos ambos m√≥dulos (`lib` y `app`), es momento de compilar el proyecto completo y ejecutar la aplicaci√≥n principal.

<BoxedTabs groupId={"os"}>
    <TabItem value="Windows" label="Windows">
        ```powershell
        mvn clean install && `
        mvn -pl app 'exec:java' `
            '-Dexec.mainClass=com.github.username.App' `
            '-Dexec.args=Ryugamine Celty Shizuo'
        ```
    </TabItem>
    <TabItem value="Linux/macOS" label="Linux/macOS">
        ```bash
        mvn clean install && \
        mvn -pl app exec:java \
            -Dexec.mainClass=com.github.username.App \
            -Dexec.args="Ryugamine Celty Shizuo"
        ```
    </TabItem>
</BoxedTabs>

<Explanation>
    Este comando hace dos cosas:

    - **`mvn clean install`**: Limpia los archivos de compilaci√≥n anteriores (`clean`) y compila e instala los m√≥dulos localmente (`install`), respetando el orden de dependencias: primero `lib`, luego `app`.
    - **`mvn -pl app exec:java`**: Ejecuta solo el m√≥dulo `app`, usando el plugin `exec-maven-plugin`. Los argumentos adicionales indican:
        - `-Dexec.mainClass`: la clase principal a ejecutar.
        - `-Dexec.args`: los argumentos pasados por l√≠nea de comandos.

    El m√≥dulo `app` imprimir√° cada palabra recibida como argumento, gracias al m√©todo `echoMessage` definido en el m√≥dulo `lib`.

    En este caso usamos `"Ryugamine Celty Shizuo"` como entrada para rendir homenaje a *Durarara!!*.
</Explanation>

### üí¨ Salida esperada

```plaintext
[INFO] Scanning for projects...
[INFO]
[INFO] --------------------------< com.github.username:app >--------------------------
[INFO] Building app 1.0.0
[INFO]   from pom.xml
[INFO] --------------------------------[ jar ]---------------------------------
[INFO]
[INFO] --- exec:3.5.0:java (default-cli) @ app ---
Ryugamine
Celty
Shizuo
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time:  0.798 s
[INFO] Finished at: 2025-04-06T17:42:03-04:00
[INFO] ------------------------------------------------------------------------
```

Como ves, Maven genera **mucha informaci√≥n de contexto durante la ejecuci√≥n**, no solo la salida de tu programa.  
Esto incluye detalles sobre la compilaci√≥n, ejecuci√≥n de plugins y tiempos de construcci√≥n.  
**Presta atenci√≥n a la secci√≥n donde se imprimen tus argumentos**: es ah√≠ donde ocurre la l√≥gica de tu aplicaci√≥n.

## üîç Visi√≥n general de un proyecto multi-m√≥dulo    

```mermaid
graph TD
    %% Nodo ra√≠z del proyecto
    subgraph root["üìÇ echo-app (ra√≠z)"]
        rootPom["üß© pom.xml"]
        
        %% Subm√≥dulo app
        subgraph appModule["üìÅ app"]
            appPom["üß© pom.xml"]
            subgraph appSrc["üìÅ src"]
                appMain["üìÅ main"]
                appTest["üìÅ test"]
            end
        end

        %% Subm√≥dulo lib
        subgraph libModule["üìÅ lib"]
            libPom["üß© pom.xml"]
            subgraph libSrc["üìÅ src"]
                libMain["üìÅ main"]
                libTest["üìÅ test"]
            end
        end
    end

    %% Relaciones entre m√≥dulos
    root --> rootPom
    root --> appModule
    root --> libModule
    appPom -- hereda de --> rootPom
    libPom -- hereda de --> rootPom
    appPom -- depende de --> libPom
```

:::info Estructura del Proyecto

- **üìÇ `echo-app (root)`**: Contiene el POM padre (`pom.xml`), que define la estructura general del proyecto y centraliza configuraciones comunes.
- **üìÇ `app` (m√≥dulo de aplicaci√≥n)**: Implementa la l√≥gica principal de la aplicaci√≥n y depende del m√≥dulo `lib`.
- **üìÇ `lib` (m√≥dulo de biblioteca)**: Incluye componentes reutilizables que pueden ser consumidos por `app` y otros m√≥dulos o proyectos.

:::

## üì¶ Herencia vs. Dependencias en Proyectos Multi-M√≥dulo

En Maven, un m√≥dulo puede **heredar configuraciones comunes** desde el POM ra√≠z (POM padre) usando la etiqueta `<parent>`. Esto permite compartir elementos como versiones de plugins, propiedades globales, perfiles de compilaci√≥n o configuraci√≥n de repositorios.

Sin embargo, **esta herencia no incluye las dependencias funcionales**. Cada m√≥dulo debe declarar de forma **expl√≠cita** sus propias dependencias en la secci√≥n `<dependencies>`. Esto garantiza que cada m√≥dulo:

- Exprese de forma precisa qu√© necesita para compilarse.
- Se mantenga **modular y reutilizable**, sin acoplamientos impl√≠citos.
- Pueda ser compilado o probado de forma aislada si es necesario.

Esta separaci√≥n clara entre lo que se **hereda** (configuraci√≥n com√∫n) y lo que se **declara** (dependencias funcionales) es esencial para mantener un dise√±o limpio, escalable y f√°cil de mantener en proyectos multi-m√≥dulo.

## üéØ Conclusiones

En esta lecci√≥n construimos paso a paso un proyecto modular utilizando Maven, con un enfoque claro en la **separaci√≥n de responsabilidades**, la **reutilizaci√≥n de c√≥digo** y la **escalabilidad**. Aprendimos a:

- Estructurar un proyecto usando un `pom.xml` ra√≠z que act√∫a como coordinador.
- Crear m√≥dulos independientes con configuraciones heredadas y dependencias expl√≠citas.
- Ejecutar aplicaciones desde la l√≠nea de comandos usando `exec-maven-plugin`.

Este tipo de arquitectura es especialmente √∫til cuando construimos bibliotecas de software que crecer√°n con el tiempo o cuando trabajamos en equipos donde la claridad y la mantenibilidad son fundamentales.

### üîë Puntos clave

- **Multi-m√≥dulos en Maven**: Organizar el proyecto en m√≥dulos independientes ayuda a mantener un dise√±o limpio y escalable.
- **POM ra√≠z como coordinador**: Centraliza configuraciones comunes y define la estructura del proyecto.
- **Herencia vs. dependencias**: Heredamos configuraci√≥n con `<parent>`, pero las dependencias funcionales deben declararse expl√≠citamente.
- **Compilaci√≥n jer√°rquica**: Maven respeta el orden de los m√≥dulos y sus relaciones al compilar.
- **Ejecuci√≥n modular**: Podemos ejecutar un solo m√≥dulo (`app`) mientras reutilizamos el c√≥digo de otros (`lib`).

### üß∞ ¬øQu√© nos llevamos?

M√°s all√° de comandos y configuraciones, lo que realmente nos llevamos es una forma de **pensar modularmente**.

Aprendimos que dividir un proyecto no es solo cuesti√≥n de organizaci√≥n, sino una decisi√≥n que afecta la mantenibilidad, la claridad y la colaboraci√≥n. Un proyecto modular permite que cada parte evolucione de forma independiente, facilita el testing, y reduce el riesgo de efectos colaterales inesperados.

Tambi√©n vimos c√≥mo Maven, a pesar de su rigidez inicial, nos ofrece una base s√≥lida y predecible para construir sistemas robustos.  
Y sobre todo, dimos el primer paso hacia una forma de desarrollar **bibliotecas profesionales**, preparadas para crecer, ser compartidas y mantenerse en el tiempo.

Como en toda buena arquitectura, lo invisible ‚Äîla estructura‚Äî es lo que sostiene todo lo dem√°s.

## üìñ Referencias

### üî• Recomendadas

- üìö Multi-module Projects. (2015). En R. Bharathan, Apache Maven cookbook: Over 90 hands-on recipes to successfully build and automate development life cycle tasks following Maven conventions and best practices (1st ed, pp. 177‚Äì195). Packt Publishing.

### üîπ Adicionales

- üåê Chapter 6. A Multi-Module Project. (s.¬†f.). TheNEXUS. Recuperado 25 de marzo de 2025, de http://www.sonatype.org/nexus/
- üåê Guide to Working with Multiple Subprojects in Maven 4 ‚Äì Maven. (s.¬†f.). Recuperado 19 de marzo de 2025, de https://maven.apache.org/guides/mini/guide-multiple-subprojects-4.html
- üåê Multi-Module Project with Maven | Baeldung. (2018, octubre 14). https://www.baeldung.com/maven-multi-module
