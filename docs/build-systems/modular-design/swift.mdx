---
title: Modularizando tu proyecto Swift
---
import { ProCons, Pros, Cons } from '@site/src/components/cajitas/ProCons'
import Explanation from '@site/src/components/admonitions/Explanation'
import GitHubRepoLink from "@site/src/components/GithubRepoLink";
import BoxedTabs from '@site/src/components/cajitas/BoxedTabs'
import TabItem from '@theme/TabItem'
import Glossary from '@site/src/components/admonitions/Glossary'
import Sh from '@site/src/components/mdx/build-systems/modular-design/swift/sh.mdx'
import ExcludeFromReadingTime from '@site/src/components/reading-time/ExcludeFromReadingTime'
import ReadingTime from '@site/src/components/reading-time/ReadingTime'

<ReadingTime/>
<GitHubRepoLink repo={"echo-app-swift"} user={"r8vnhill"} />

En esta lecci√≥n vamos a ir m√°s all√° del t√≠pico archivo `main.swift`: aprender√°s a **estructurar un proyecto Swift en m√∫ltiples m√≥dulos** usando [Swift Package Manager (SwiftPM)](https://www.swift.org/package-manager/), la herramienta oficial para construir, distribuir y organizar c√≥digo en Swift.

Dividiremos el proyecto en tres partes:
- Un ejecutable (`App`) que act√∫a como punto de entrada.
- Una biblioteca (`Lib`) que contiene la l√≥gica reutilizable.
- Un conjunto de pruebas (`LibTests`) que valida esa l√≥gica.

Este enfoque modular no solo mejora la organizaci√≥n del c√≥digo, sino que sienta las bases para proyectos **escalables, testeables y f√°ciles de mantener** ‚Äî como los que se esperan en entornos profesionales.

:::tip ¬øPor qu√© importa?

Dise√±ar un proyecto con m√≥dulos bien definidos te permite **trabajar por capas**, **reutilizar l√≥gica en distintos contextos**, y **acelerar el desarrollo y las pruebas**.

:::

Al terminar esta lecci√≥n, estar√°s en condiciones de construir tus propias bibliotecas en Swift, integrarlas en aplicaciones y ejecutar proyectos bien estructurados desde la terminal.

_Let's-a go!_ üöÄ

<Glossary>
    - **SwiftPM (Swift Package Manager)**: Herramienta oficial de Swift para gestionar dependencias, compilar, testear y distribuir c√≥digo. Equivalente a Gradle en Kotlin o Cargo en Rust.
    - **Target**: Unidad de compilaci√≥n dentro de un paquete Swift. Puede ser un ejecutable, una biblioteca o un conjunto de pruebas.
    - **Product**: Resultado exportable de uno o m√°s targets. Puede ser una librer√≠a (`library`) o una aplicaci√≥n (`executable`).
    - **Module**: Unidad l√≥gica de c√≥digo importable en Swift. Cada target define un m√≥dulo.
</Glossary>

## üèóÔ∏è Estructura de carpetas para proyectos Swift con SwiftPM

SwiftPM impone una convenci√≥n estricta de carpetas para que los m√≥dulos (targets) funcionen correctamente.
A continuaci√≥n se muestra la estructura completa que debe seguir el proyecto EchoAppSwift para compilar correctamente y mantener una separaci√≥n clara entre ejecutable, biblioteca y pruebas:

```mermaid
graph TD
    subgraph Root [üìÅ EchoAppSwift]
        direction LR

        Package[üìÑ Package.swift]

        subgraph Sources [üìÅ Sources]
            direction TB

            subgraph App [üìÅ App]
                Main[üìÑ main.swift]
            end

            subgraph Lib [üìÅ Lib]
                Echo[üìÑ Echo.swift]
            end
        end

        subgraph Tests [üìÅ Tests]
            direction TB

            subgraph LibTests [üìÅ LibTests]
                EchoTests[üìÑ EchoTests.swift]
            end
        end
    end

    Package -->|define| App
    Package -->|define| Lib
    Package -->|define| LibTests
    Main -->|import| Echo
    EchoTests -->|testea| Echo
```

::::info Explicaci√≥n de la estructura del proyecto

Este diagrama muestra c√≥mo organizar un proyecto modular en Swift utilizando **Swift Package Manager (SwiftPM)**, respetando sus convenciones:

- **`Package.swift`**: Archivo central de configuraci√≥n donde se declaran los m√≥dulos (`App`, `Lib`, `LibTests`) y sus relaciones.
- **`Sources/App/`**: Contiene el ejecutable principal. SwiftPM buscar√° aqu√≠ un archivo `main.swift` como punto de entrada del programa.
- **`Sources/Lib/`**: M√≥dulo de biblioteca reutilizable. Puede ser importado por `App` o cualquier otro m√≥dulo.
- **`Tests/LibTests/`**: M√≥dulo de pruebas unitarias para `Lib`. SwiftPM vincula autom√°ticamente esta carpeta con el target de pruebas `LibTests`.

:::warning Convenci√≥n estricta de nombres

Los nombres de las carpetas dentro de `Sources/` y `Tests/` deben coincidir **exactamente** con los nombres de los targets definidos en `Package.swift`. De lo contrario, SwiftPM no podr√° asociarlos correctamente.

:::
::::

## üì¶ Paso 1: Crear la estructura de carpetas

Desde la ra√≠z del proyecto:

<BoxedTabs groupId={"os"}>
    <TabItem value="Windows" label="Windows">
        ```powershell showLineNumbers title="scripts/ps1/CreateProjectStructure.ps1"
        @{
            App = @("Sources/App/main.swift")
            Lib = @("Sources/Lib/Echo.swift", "Tests/EchoTests.swift")
        }.GetEnumerator() | ForEach-Object {
            $module = $_.Key
            $files = $_.Value

            Write-Host "üìÅ Creating structure for module: $module" -ForegroundColor Cyan

            foreach ($file in $files) {
                $dir = Split-Path $file -Parent
                if (-not (Test-Path $dir)) {
                    New-Item -Path $dir -ItemType Directory -Force | Out-Null
                }
                New-Item -Path $file -ItemType File -Force | Out-Null
                Write-Host "‚úÖ $file" -ForegroundColor Green
            }
        }

        Write-Host "üü¢ Project initialized successfully." -ForegroundColor Green
        ```

        <Explanation>
            Este fragmento de PowerShell crea de forma autom√°tica la estructura m√≠nima de archivos y carpetas para un proyecto modular en Swift usando SwiftPM.

            Se define un diccionario que asocia cada m√≥dulo (`App` y `Lib`) con los archivos que debe contener. Luego, por cada archivo:
            
            - Se crea el directorio padre si no existe (`Sources/App`, `Sources/Lib`, `Tests`).
            - Se crea un archivo vac√≠o (`main.swift`, `Echo.swift`, `EchoTests.swift`).

            Esto garantiza que el proyecto tenga la estructura correcta para compilar sin errores desde el principio.
        </Explanation>

        Puedes crear el archivo `CreateProjectStructure.ps1` y ejecutarlo desde PowerShell para crear la estructura de carpetas y archivos autom√°ticamente.

        ```powershell
        .\scripts\ps1\CreateProjectStructure.ps1
        ```
    </TabItem>
    <TabItem value="macOS" label="macOS">
        <Sh />
    </TabItem>
    <TabItem value="Ubuntu/Debian" label="Ubuntu/Debian">
        <Sh />
    </TabItem>
</BoxedTabs>

## üß© Paso 2: Declarar m√≥dulos y productos

Vamos a definir la configuraci√≥n del proyecto en `Package.swift`. Aqu√≠ declaramos:

- Un ejecutable llamado `App`, que actuar√° como punto de entrada del programa.
- Una biblioteca llamada `Lib`, que contendr√° la l√≥gica reutilizable del proyecto.
- Un m√≥dulo de pruebas llamado `LibTests`, encargado de verificar el comportamiento de `Lib`.

```swift showLineNumbers title="Package.swift"
// swift-tools-version: 6.1
import PackageDescription

let package = Package(
    name: "echo-app-swift",
    products: [
        .executable(name: "App", targets: ["App"]),   // Ejecutable principal
        .library(name: "Lib", targets: ["Lib"])       // Biblioteca reutilizable
    ],
    targets: [
        .target(name: "Lib"),                         // L√≥gica central del proyecto
        .executableTarget(
            name: "App",
            dependencies: ["Lib"]                     // App depende de Lib
        ),
        .testTarget(
            name: "LibTests",
            dependencies: ["Lib"]                     // Pruebas para Lib
        )
    ]
)
```

<Explanation>
    Este archivo configura el proyecto como un **paquete Swift modular y multiplataforma**.

    - `App` es el ejecutable principal: puede compilarse y ejecutarse desde la l√≠nea de comandos.
    - `Lib` es la biblioteca donde colocamos la l√≥gica principal del proyecto (como la funci√≥n `echo`).
    - `LibTests` es un m√≥dulo de pruebas unitarias que verifica el comportamiento de `Lib`.

    Al declarar expl√≠citamente estos m√≥dulos y sus dependencias, SwiftPM entiende c√≥mo construir, enlazar y testear cada componente.
</Explanation>

## üß™ Paso 3: Implementar la l√≥gica reutilizable

Vamos a definir una funci√≥n `echo` dentro de la biblioteca `Lib`. Esta funci√≥n ser√° p√∫blica para que el m√≥dulo `App` pueda utilizarla.

```swift showLineNumbers title="Sources/Lib/Echo.swift"
public func echo(_ message: String) -> String {
    return message
}
```

<Explanation>
    En este paso implementamos una funci√≥n p√∫blica `echo`, que simplemente devuelve el mensaje recibido como argumento.

    - Se utiliza el modificador `public` para que la funci√≥n est√© disponible fuera del m√≥dulo `Lib`. Si omiti√©ramos `public`, la funci√≥n tendr√≠a visibilidad solo dentro del mismo m√≥dulo.
    - Aunque su comportamiento es trivial, la funci√≥n nos permite establecer una separaci√≥n clara entre la **l√≥gica de negocio** (en `Lib`) y el **punto de entrada** (en `App`).

    Este archivo representa la **unidad m√°s b√°sica de l√≥gica reutilizable** y servir√° como base para futuras pruebas y extensiones.
</Explanation>

## üöÄ Paso 4: Crear el punto de entrada de la aplicaci√≥n

Ahora implementamos la funci√≥n principal de la aplicaci√≥n en el m√≥dulo `App`, que utilizar√° la funci√≥n `echo` definida en la biblioteca `Lib`.

```swift showLineNumbers title="Sources/App/main.swift"
import Lib

func main() {
    // Ignora el primer argumento (nombre del ejecutable)
    let args = CommandLine.arguments.dropFirst()
    for arg in args {
        print(echo(arg))
    }
}

main()
```

<Explanation>
    Este archivo define el **punto de entrada** del ejecutable:

    - `import Lib` permite acceder a la funci√≥n `echo` declarada como `public` en el m√≥dulo `Lib`.
    - `CommandLine.arguments` recupera todos los argumentos pasados al ejecutar el programa.
    - `dropFirst()` descarta el primer argumento (el nombre del ejecutable), ya que no nos interesa procesarlo.
    - Se recorre cada argumento restante y se imprime el resultado de `echo(arg)`.

    Este dise√±o deja clara la separaci√≥n entre la **l√≥gica de aplicaci√≥n** (c√≥mo interactuar con el sistema o el usuario) y la **l√≥gica de negocio** (qu√© hacer con esos datos), favoreciendo un estilo modular y mantenible.
</Explanation>

## ‚ñ∂Ô∏è Paso 5: Ejecutar la aplicaci√≥n

Una vez que has definido los m√≥dulos y escrito el c√≥digo, puedes ejecutar la aplicaci√≥n directamente desde la terminal con:

```bash title="En tu terminal"
swift run App Kanna Kenji Friend
```

```plaintext title="Salida esperada"
Kanna
Kenji
Friend
```

<Explanation>
    El comando `swift run App` compila el m√≥dulo `App` (si es necesario) y lo ejecuta, pasando los argumentos `Kanna`, `Kenji` y `Friend` desde la l√≠nea de comandos.

    Cada argumento se imprime en una l√≠nea distinta, lo que demuestra que:

    - `App` est√° invocando correctamente la funci√≥n `echo` definida en `Lib`.
    - El programa responde din√°micamente a entradas del usuario.
    - La separaci√≥n entre l√≥gica de negocio (`Lib`) y l√≥gica de aplicaci√≥n (`App`) funciona de forma efectiva.
</Explanation>

‚úÖ ¬°Tu primer programa modular en Swift est√° en marcha!

## üéØ Conclusiones

En esta lecci√≥n aprendiste a estructurar un proyecto en Swift utilizando una arquitectura modular con **Swift Package Manager (SwiftPM)**.

Partiste desde cero y construiste una estructura clara que separa la **l√≥gica de aplicaci√≥n** (m√≥dulo `App`) de la **l√≥gica reutilizable** (m√≥dulo `Lib`). Tambi√©n sentaste las bases para un desarrollo profesional al incluir un m√≥dulo de pruebas (`LibTests`), aunque a√∫n no hayas escrito tests.

Esta separaci√≥n no solo mejora la organizaci√≥n, sino que te prepara para escalar el proyecto, reutilizar componentes y aplicar buenas pr√°cticas como pruebas automatizadas e integraci√≥n continua.

### üîë Puntos clave

- **SwiftPM** permite definir ejecutables, bibliotecas y pruebas dentro de un mismo proyecto siguiendo convenciones claras.
- El archivo `Package.swift` es el centro de la configuraci√≥n: ah√≠ se declaran los m√≥dulos y sus relaciones.
- El m√≥dulo `App` act√∫a como punto de entrada y puede depender de bibliotecas como `Lib`.
- El m√≥dulo `Lib` encapsula la l√≥gica reutilizable; su visibilidad se controla con el modificador `public`.
- El m√≥dulo `LibTests` permite probar la biblioteca de forma aislada.
- Una estructura modular mejora la escalabilidad, el mantenimiento y la testabilidad del software.

### üß∞ ¬øQu√© nos llevamos?

Pasaste de un archivo Swift suelto a una **estructura profesional y escalable**, donde cada m√≥dulo cumple un rol bien definido.

Aprendiste a:

- Respetar las convenciones de SwiftPM.
- Dise√±ar una arquitectura basada en la separaci√≥n de responsabilidades.
- Compartir funcionalidad entre m√≥dulos mediante `import`.
- Ejecutar tu aplicaci√≥n con argumentos desde la l√≠nea de comandos.

Este enfoque modular ser√° la base para futuras lecciones donde abordaremos pruebas, documentaci√≥n, empaquetado y automatizaci√≥n.  
**Ya est√°s pensando como quien dise√±a software, no solo como quien lo escribe.**

<ExcludeFromReadingTime>

## üìñ Referencias

### üî• Recomendadas

- [üåê "Package Manager"](https://www.swift.org/documentation/package-manager/) de **la documentaci√≥n oficial de Swift**: Explica los fundamentos de **Swift Package Manager (SwiftPM)**, incluyendo c√≥mo definir m√≥dulos (`targets`), productos (`products`) y dependencias. La lecci√≥n usa precisamente estos conceptos para estructurar el proyecto en m√≥dulos (`App`, `Lib`, `LibTests`) y compartir l√≥gica mediante `import`. Esta lectura es clave para entender c√≥mo SwiftPM organiza, compila y vincula proyectos modulares de manera autom√°tica y escalable.

### üîπ Adicionales

- [üì∞ "Modular Project Structure with Swift Package Manager (SPM)"](https://santoshbotre01.medium.com/modular-project-structure-with-swift-package-manager-spm-c81fb62c8619) de **Santosh Botre**: Explica c√≥mo estructurar aplicaciones iOS en m√∫ltiples m√≥dulos usando **Swift Package Manager** para lograr escalabilidad, reutilizaci√≥n y aislamiento. Presenta un enfoque pr√°ctico para dividir el c√≥digo en paquetes locales (como `Network`, `Logger`, `Login`, etc.) y vincularlos al proyecto. Es relevante para esta lecci√≥n porque ilustra los beneficios y el proceso de migrar de un dise√±o monol√≠tico a una arquitectura modular realista con SwiftPM.

</ExcludeFromReadingTime>
