---
title: "Build Systems: el motor oculto de tu biblioteca"
sidebar_label: El rol de los build systems
---
import { Cons, ProCons, Pros } from "@site/src/components/cajitas/ProCons";
import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";
import References from "/src/components/ReferencesComponent";
import ReadingTime from "/src/components/reading-time/ReadingTime";
import ExcludeFromReadingTime from "@site/src/components/reading-time/ExcludeFromReadingTime";
import BoxedTabs from '@site/src/components/cajitas/BoxedTabs'
import Explanation from '@site/src/components/admonitions/Explanation'

import Book from '@site/src/components/references/Book'
import ReferenceList from '@site/src/components/references/ReferenceList'
import WebPage from '@site/src/components/references/WebPage'
import Video from '@site/src/components/references/Video'
import AuthorList from '@site/src/components/references/AuthorList';
import Paper from '@site/src/components/references/Paper';

<ReadingTime />

{/* #region Introducci√≥n */}
<section title="Introducci√≥n">

En el desarrollo de software moderno, **escribir c√≥digo es solo el primer paso**. Para convertir ese c√≥digo en una aplicaci√≥n ejecutable, una biblioteca reutilizable o un servicio desplegable, debe pasar por un proceso que lo compile, verifique, empaquete y, en muchos casos, lo publique.

Ese proceso est√° coordinado por el **build system**: el motor silencioso que transforma tu c√≥digo en software listo para ser distribuido y utilizado.

</section>
{/* #endregion */}

{/* #region ¬øQu√© es un Build System? */}
<section title="¬øQu√© es un Build System?">

## üèóÔ∏è ¬øQu√© es un Build System?

Un *build system* es una herramienta que **automatiza las tareas necesarias para construir software**. Entre las m√°s comunes se encuentran:

:::info Tareas t√≠picas de un build system

- Compilar el c√≥digo fuente.  
- Ejecutar pruebas automatizadas.  
- Analizar el c√≥digo en busca de errores, advertencias o problemas de estilo.  
- Empaquetar el c√≥digo en formatos distribuibles (como `.jar`, `.aar`, `.zip`, etc.).  
- Generar documentaci√≥n.  
- Publicar artefactos en repositorios.

:::

Aunque muchas de estas tareas pueden realizarse manualmente, mantener un proyecto profesional sin automatizaci√≥n **pronto se vuelve inviable**. Un *build system* permite ejecutar todo el proceso de forma **reproducible, coherente y automatizada**, tanto en el entorno local como en sistemas de integraci√≥n continua.

Existen muchos *build systems*, cada uno con enfoques y ecosistemas distintos:

:::tip Ejemplos de build systems

- **Make**, **CMake** y **Bazel** son comunes en proyectos de bajo nivel o multiplataforma.  
- **pnpm** y **Nx** se utilizan en proyectos modernos del ecosistema JavaScript.  
- **Gradle**, **Maven** y **sbt** son habituales en entornos basados en la JVM.

:::

</section>

{/* #endregion */}

{/* #region ¬øPor qu√© es importante en bibliotecas de software? */}
<section title="¬øPor qu√© es importante en bibliotecas de software?">

## üß∞ ¬øPor qu√© es importante en bibliotecas de software?

Dise√±ar una biblioteca no consiste solo en escribir funciones reutilizables: tambi√©n implica **organizar, validar y distribuir ese c√≥digo de forma profesional**. Para lograrlo, el *build system* se convierte en una herramienta clave a lo largo de todo el ciclo de desarrollo.

En particular, un *build system* permite:

- **Organizar el proyecto en m√≥dulos independientes**, separando la l√≥gica de negocio de la l√≥gica de aplicaci√≥n.  
- **Aplicar convenciones compartidas**, garantizando consistencia entre m√∫ltiples proyectos o subm√≥dulos.  
- **Integrar herramientas de validaci√≥n**, como an√°lisis est√°tico, pruebas automatizadas y generaci√≥n de documentaci√≥n.  
- **Automatizar el empaquetado y la publicaci√≥n**, facilitando la distribuci√≥n de la biblioteca en otros sistemas.

En otras palabras, un *build system* no solo ayuda a *construir* una biblioteca, sino tambi√©n a *estructurarla, verificarla y distribuirla* de forma **robusta, coherente y profesional**.

<ProCons>
  <Cons title="Sin un build system">
    Una biblioteca es solo c√≥digo.
  </Cons>
  <Pros title="Con un build system">
    Una biblioteca se convierte en una herramienta **lista para ser utilizada**.
  </Pros>
</ProCons>

</section>
{/* #endregion */}

{/* #region ¬øQu√© es Gradle? */}
<section title="¬øQu√© es Gradle?">

## üêò ¬øQu√© es Gradle?

Existen m√∫ltiples *build systems*, pero no todos est√°n dise√±ados con un enfoque en la **modularidad, extensibilidad y expresividad**. **Gradle** es una herramienta moderna que adopta estos principios y se ha consolidado como una de las opciones m√°s potentes en el ecosistema de la JVM.

Gradle naci√≥ como respuesta a las limitaciones de [Apache Maven](https://maven.apache.org/),[^1] una herramienta ampliamente utilizada, pero basada en convenciones r√≠gidas y configuraciones extensas en XML. Retoma muchas de sus buenas ideas ‚Äîcomo el uso de fases y convenciones‚Äî, pero las combina con una sintaxis m√°s expresiva y un modelo de ejecuci√≥n altamente personalizable basado en tareas.

:::important ¬øPor qu√© Gradle?

Una de las principales razones por las que elegimos **Gradle** para este curso es que ofrece un **DSL (Domain-Specific Language) basado en Kotlin**. Esto significa que no necesitas aprender un lenguaje adicional para definir tareas, configurar m√≥dulos o declarar dependencias: puedes usar las mismas construcciones, tipos y herramientas que ya empleas al desarrollar tu biblioteca.

:::

Los DSL est√°n dise√±ados para expresar configuraciones de forma natural y concisa dentro de un dominio particular. En el caso de Gradle, esto permite que tanto personas expertas como nuevas colaboradoras trabajen con un lenguaje claro, coherente y extensible. Adem√°s, **los plugins de Gradle pueden extender el DSL**, a√±adiendo bloques personalizados que simplifican configuraciones complejas.

:::info Gradle vs. otros build systems

En contraste, otros *build systems* como **Bazel** o **CMake** requieren aprender lenguajes espec√≠ficos para su configuraci√≥n. Bazel utiliza **Starlark**, un lenguaje declarativo inspirado en Python, mientras que CMake emplea su **propio lenguaje imperativo**, con una sintaxis poco convencional y limitada en expresividad.

Esto implica que, al usar herramientas como CMake, necesitas dominar **dos lenguajes distintos**: uno para la l√≥gica de tu biblioteca (por ejemplo, C o C++) y otro para declarar c√≥mo debe construirse. Con Gradle, en cambio, puedes usar **Kotlin tanto para desarrollar como para automatizar tu proyecto**, lo que **reduce la carga cognitiva**, mejora la integraci√≥n entre c√≥digo y configuraci√≥n, y hace que el entorno sea m√°s coherente y productivo.

:::

<ProCons>
  <Pros title="Gradle se alinea perfectamente con los objetivos de este curso">
    - Automatiza todo el ciclo de vida de una biblioteca, desde la compilaci√≥n hasta la publicaci√≥n.  
    - Facilita la organizaci√≥n del proyecto en m√≥dulos separados para la l√≥gica de negocio y la l√≥gica de aplicaci√≥n.  
    - Permite compartir convenciones entre distintos proyectos o subm√≥dulos.  
    - Integra f√°cilmente herramientas de an√°lisis est√°tico, pruebas y generaci√≥n de documentaci√≥n.  
    - Es extensible: puedes definir tus propias tareas, plugins y configuraciones reutilizables.
  </Pros>
</ProCons>

Gradle est√° dise√±ado para ser:

:::tip Caracter√≠sticas clave de Gradle

- **Flexible**: cada parte del proceso puede personalizarse.  
- **Declarativo**: defines *qu√©* debe hacerse, y Gradle se encarga del *c√≥mo*.  
- **Basado en tareas**: todo se modela como tareas que pueden depender entre s√≠.  
- **Extensible**: permite componer l√≥gicas complejas usando clases, funciones y plugins.  
- **Escalable**: soporta de forma nativa proyectos grandes y multi-m√≥dulo.

:::

Hoy en d√≠a, Gradle es ampliamente utilizado en el desarrollo profesional de aplicaciones y bibliotecas en **Kotlin** y **Java**, y cuenta con integraci√≥n nativa en entornos como **IntelliJ IDEA**, **Android Studio**, **Eclipse** y **VS Code**.

</section>
{/* #endregion */}

{/* #region Conclusiones */}
<section title="Conclusiones">

## üéØ Conclusiones

Los *build systems* son una pieza clave del desarrollo de software moderno. Van mucho m√°s all√° de compilar: **automatizan tareas esenciales, establecen convenciones claras y permiten mantener estructuras sostenibles a largo plazo**, algo especialmente importante en el contexto de bibliotecas.

En esta unidad elegimos **Gradle** porque se alinea con los objetivos del curso: es **expresivo, extensible** y permite usar **Kotlin tanto para programar como para configurar**, lo que reduce la fricci√≥n entre el c√≥digo y su automatizaci√≥n.

Esto simplifica el aprendizaje, evita saltos de contexto y facilita la creaci√≥n de proyectos reales desde el primer d√≠a.

### üîë Puntos clave

- Un *build system* automatiza procesos como compilaci√≥n, pruebas, empaquetado, documentaci√≥n y publicaci√≥n.  
- En bibliotecas, permite estructurar el c√≥digo, definir tareas reutilizables y facilitar su integraci√≥n y distribuci√≥n.  
- Gradle retoma lo mejor de herramientas como Maven, pero con mayor flexibilidad y expresividad.  
- Su DSL en Kotlin evita tener que aprender otro lenguaje de configuraci√≥n, a diferencia de herramientas como Bazel o CMake.

### üß∞ ¬øQu√© nos llevamos?

Con esta lecci√≥n dimos el primer paso hacia la creaci√≥n de bibliotecas **robustas y mantenibles**. Aprendimos que **una biblioteca profesional no es solo un conjunto de funciones**, sino un proyecto bien estructurado, automatizado y preparado para escalar.

**Gradle ser√° nuestra herramienta base** para lograrlo. En las siguientes lecciones aprenderemos a utilizarlo paso a paso: desde crear un proyecto b√°sico hasta preparar una biblioteca lista para su publicaci√≥n y reutilizaci√≥n.

</section>
{/* #endregion */}

{/* #region Referencias */}
<section title="Referencias">

## üìñ ¬øCon ganas de m√°s?

<ReferenceList title="üî• Referencias recomendadas" items={[
  <Book 
    chapter="Introduction to Project Automation"
    author={<AuthorList authors={[
        {firstName: "Benjamin", lastName: "Muschko", url: "https://bmuschko.com" }
    ]} />}
    book="Gradle in Action"
    pages={[3, 21]}
  >
    Introducci√≥n pr√°ctica a la automatizaci√≥n de proyectos y las herramientas de construcci√≥n. Expone los problemas comunes de los flujos manuales (como compilaciones inconsistentes, integraci√≥n fallida y despliegues impredecibles) y presenta los beneficios de automatizar mediante herramientas como Ant y Maven. Se analizan sus caracter√≠sticas, ventajas, limitaciones y la necesidad de una herramienta moderna que combine flexibilidad con convenciones sensatas, como Gradle. Ideal para comprender el contexto, prop√≥sito y evoluci√≥n de los sistemas de construcci√≥n en el ecosistema Java.
  </Book>,
]}/>

<ReferenceList
  title="üîπ Referencias adicionales"
  items={[
    <WebPage
      title="What is Gradle and why do we use it as Android developers?"
      url="https://medium.com/@banmarkovic/what-is-gradle-and-why-do-we-use-it-as-android-developers-572a07b3675d"
      location="Medium"
      author={
        <AuthorList authors={[
          { firstName: "Ban", lastName: "Markovic", url: "https://medium.com/@banmarkovic" }
        ]} />
      }
    >
      Una introducci√≥n accesible a Gradle para quienes desarrollan en Android, que explica su prop√≥sito, estructura y la diferencia entre los archivos <code>build.gradle</code> a nivel de proyecto y de m√≥dulo. Se repasan casos de uso comunes, el rol de plugins y dependencias, y la sintaxis del DSL tanto en Groovy como en Kotlin, destacando c√≥mo comprender Gradle permite tener un mayor control sobre el proceso de compilaci√≥n.
    </WebPage>,
    <WebPage
      title="Gradle Build Overview"
      url="https://developer.android.com/build/gradle-build-overview"
      location="la documentaci√≥n oficial de Android"
    >
      Descripci√≥n general del sistema de compilaci√≥n Gradle en Android. Explica qu√© es una build, c√≥mo Gradle organiza las tareas mediante plugins y su DSL declarativo, y c√≥mo se estructura el ciclo de vida de una compilaci√≥n en fases (inicializaci√≥n, configuraci√≥n y ejecuci√≥n). Tambi√©n aborda conceptos clave como dependencias externas, variantes de compilaci√≥n (tipos y sabores), subproyectos, y el uso de Kotlin DSL para especificar la configuraci√≥n de forma segura y expresiva.
    </WebPage>,
    <Video
      title="What is the Gradle Build Tool? A simplified explanation"
      url="https://www.youtube.com/watch?v=cUGWEQ8NLHk"
      duration="1m23s"
      location="YouTube"
      author={<AuthorList authors={[{ fullName: "Gradle", url: "https://www.youtube.com/@GradleInc" }]} />}
    >
      Introducci√≥n general a Gradle como herramienta de automatizaci√≥n de construcci√≥n de software. Explica su prop√≥sito en el proceso de testeo, empaquetado y despliegue, destacando su flexibilidad, extensibilidad mediante una interfaz bien definida y su ecosistema de plugins mantenido por una comunidad activa. Ideal para quienes buscan entender el rol de Gradle en proyectos modernos.
    </Video>,
    <Paper
      title="Build systems √† la carte"
      journal="Communications of the ACM"
      author={<AuthorList authors={[
        { firstName: "Andrey", lastName: "Mokhov", url: "https://dl.acm.org/profile/81367593993" },
        { firstName: "Neil", lastName: "Mitchell", url: "https://dl.acm.org/profile/81337491713" },
        { firstName: "Simon", lastName: "Peyton Jones", url: "https://simon.peytonjones.org" }
      ]}/>}
    >
      Este art√≠culo presenta un marco formal y ejecutable para analizar, comparar y construir sistemas de compilaci√≥n (build systems). Los autores descomponen los sistemas existentes en componentes fundamentales ‚Äîel planificador (scheduler) y el verificador (rebuilder)‚Äî y muestran c√≥mo distintas combinaciones de estos componentes dan lugar a diferentes comportamientos. A trav√©s de una implementaci√≥n en Haskell, modelan sistemas reales como Make, Shake, Excel y Bazel, e introducen la noci√≥n de un ‚Äúpaisaje‚Äù de sistemas de compilaci√≥n donde cada sistema es un punto con propiedades espec√≠ficas. El trabajo permite razonar sobre caracter√≠sticas como dependencias din√°micas, reconstrucci√≥n m√≠nima, cutoff temprano, y compilaci√≥n en la nube. El marco propuesto promueve la exploraci√≥n de nuevos sistemas combinando piezas existentes, como el caso del sistema "Cloud Shake", que combina lo mejor de Shake y Bazel.
    </Paper>
  ]}
/>
</section>
{/* #endregion */}

[^1]: [Gradle es un sistema de automatizaci√≥n de construcci√≥n de c√≥digo de software que construye sobre los conceptos de Apache Ant y Apache Maven](https://es.wikipedia.org/wiki/Gradle#:~:text=Gradle%20es%20un%20sistema%20de%20automatizaci%C3%B3n%20de%20construcci%C3%B3n%20de%20c%C3%B3digo%20de%20software%20que%20construye%20sobre%20los%20conceptos%20de%20Apache%20Ant%20y%20Apache%20Maven)
