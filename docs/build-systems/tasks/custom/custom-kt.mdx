---
title: Tareas Personalizadas
---
import GithubRepoLink from "@site/src/components/GithubRepoLink";
import ReadingTime from '@site/src/components/ReadingTime';
import References from "@site/src/components/ReferencesComponent";
import TabItem from "@theme/TabItem";
import Tabs from "@theme/Tabs";
import Exercise from "@site/src/components/exercise/Exercise";
import Solution from "@site/src/components/exercise/Solution";
import Hint from "@site/src/components/exercise/Hint";
import { LanguageCard } from "@site/src/components/cards/LanguageCard"
import BoxedTabs from '@site/src/components/cajitas/BoxedTabs'
import Explanation from '@site/src/components/admonitions/Explanation'

<ReadingTime/>
<GithubRepoLink user={"r8vnhill"} repo={"echo-app-kt"}/>

Gradle no se limita a tareas predefinidas como `build` o `test`; tambi√©n nos permite definir nuestras **propias tareas** para automatizar procesos espec√≠ficos de nuestro proyecto. Esto es especialmente √∫til cuando trabajamos en bibliotecas o aplicaciones complejas que requieren pasos adicionales como:

- Generar documentaci√≥n.
- Analizar el tama√±o del build.
- Transformar o copiar archivos.
- Automatizar flujos de integraci√≥n.

Crear tareas personalizadas con Kotlin DSL no solo mejora la **claridad del proceso de build**, sino que tambi√©n permite estructurar el proyecto de manera m√°s modular, reutilizable y alineada con principios de dise√±o como el de **abierto/cerrado**.

En esta lecci√≥n aprenderemos a:

- Crear tareas personalizadas simples y complejas.
- Usar acciones como `doFirst` y `doLast` para definir comportamientos en distintos momentos del ciclo de vida.
- Configurar dependencias entre tareas para controlar el orden de ejecuci√≥n.
- Basar nuevas tareas en tareas preexistentes como `Copy` para extender funcionalidad sin duplicar l√≥gica.

Con estas herramientas, podr√°s adaptar el proceso de construcci√≥n a las necesidades de tu proyecto de forma elegante y controlada.

## üìã Creando Tareas Personalizadas en Gradle

Supongamos que queremos crear una tarea simb√≥lica que **inicie el viaje del Pr√≠ncipe**. Podemos comenzar con un saludo personalizado:

```kotlin showLineNumbers title="convention-plugins/src/main/kotlin/playground.gradle.kts"
tasks.register("greetPrince") {
    group = "Playground"
    description = "Greets the Prince of Persia before his next mission"
    println("The sands of time are calling, Prince...")
}
```

Para que esta tarea se ejecute en el proyecto principal, debes aplicar el plugin correspondiente en el archivo `build.gradle.kts` del m√≥dulo principal:

```kotlin showLineNumbers title="build.gradle.kts"
plugins {
    id("jvm.conventions")
    id("playground")
}
// ...
```

Ahora puedes ejecutar la tarea con `./gradlew greetPrince` y ver√°s c√≥mo el mensaje anticipa la misi√≥n del Pr√≠ncipe en tu consola.

### üß™ Ejercicio: Diferencia entre `tasks.register` y `tasks.create`

<Exercise>
    Cambia la definici√≥n de la tarea de `tasks.register` a `tasks.create` en el archivo `playground.gradle.kts`. ¬øQu√© sucede ahora si ejecutas `./gradlew build` en el proyecto? ¬øPor qu√©?

    <Solution>
        Al ejecutar `./gradlew build`, se imprimir√° el mensaje `"The sands of time are calling, Prince..."` incluso si no ejecutamos expl√≠citamente la tarea `greetPrince`.

        Esto ocurre porque al usar `tasks.create`, la tarea se configura y ejecuta su bloque inmediatamente durante la **fase de configuraci√≥n** del build de Gradle. Es decir, cualquier instrucci√≥n dentro del bloque `{ ... }`, como `println(...)`, se ejecuta en ese momento, independientemente de si la tarea se invoca o no m√°s adelante.

        En cambio, con `tasks.register`, la tarea se registra para una **configuraci√≥n diferida**, y su bloque solo se ejecuta si la tarea es requerida durante la **fase de ejecuci√≥n**. Esto evita trabajo innecesario y mejora el rendimiento.

        Por eso, con `tasks.register`, el mensaje no aparece al ejecutar `./gradlew build`, a menos que se llame directamente a `greetPrince`.

        Esta diferencia es clave para mantener builds eficientes y predecibles.
    </Solution>
</Exercise>

## ‚öôÔ∏è Acciones en Gradle

En nuestra implementaci√≥n inicial, notamos un detalle importante: el mensaje se imprime durante la **fase de configuraci√≥n** de Gradle, incluso si la tarea no se ejecuta. Esto no es lo que queremos. Para corregirlo, necesitamos definir **acciones** que se ejecuten en el momento adecuado del ciclo de vida de la tarea.

Las **acciones** son bloques de c√≥digo que definen **qu√© ocurre cuando la tarea se ejecuta**. Las m√°s comunes son:

- üîπ **`doFirst { ... }`:** Ejecuta el bloque **antes** de cualquier otra acci√≥n asociada a la tarea.
- üî∏ **`doLast { ... }`:** Ejecuta el bloque **despu√©s** de todas las dem√°s acciones.

Estas acciones se ejecutan √∫nicamente si la tarea realmente se corre, lo que evita efectos colaterales en otras tareas y mejora la claridad del build.

Un ejemplo simple:

```kotlin showLineNumbers title="convention-plugins/src/main/kotlin/playground.gradle.kts"
tasks.register("greetPrince") {
    group = "Playground"
    description = "Greets the Prince of Persia before his next mission"
    doLast {
        println("The sands of time are calling, Prince...")
    }
}
```

As√≠, el mensaje se imprimir√° solo cuando ejecutes `./gradlew hello`, y no antes.

### üßÆ Ejemplo: Calculando la Secuencia de Fibonacci

Supongamos que queremos crear una tarea que calcule la secuencia de Fibonacci. Usaremos las acciones `doFirst` y `doLast` para estructurar las operaciones:

```kotlin title="convention-plugins/src/main/kotlin/playground.gradle.kts"
tasks.register("printFibonacciSequence") {
    group = "Playground"
    description = "Prints the first 10 Fibonacci numbers and highlights the last one"

    val sequence = mutableListOf<Int>()

    doFirst {
        var first = 0
        var second = 1
        repeat(10) {
            sequence.add(first)
            val temp = first + second
            first = second
            second = temp
        }

        sequence.forEach(::println)
    }

    doLast {
        println("\nThe 10th Fibonacci number is: ${sequence.last()}")
    }
}
```

<Explanation>
    En esta tarea, usamos `doFirst` para construir e imprimir los primeros 10 n√∫meros de la secuencia de Fibonacci.
    La l√≥gica de c√°lculo se ejecuta antes de cualquier otra acci√≥n configurada, lo cual es ideal para preparar datos.

    Luego, en `doLast`, imprimimos el d√©cimo n√∫mero destac√°ndolo por separado. Esto permite separar el procesamiento
    de los datos de su presentaci√≥n final, haciendo la tarea m√°s clara y f√°cil de mantener.

    Esta estructura es √∫til cuando necesitas preparar y reutilizar informaci√≥n dentro de la misma tarea, y quieres que
    la salida final tenga un contexto m√°s destacado o resumido.
</Explanation>

#### üéØ Resultado esperado

Cuando ejecutas esta tarea con `./gradlew printFibonacciSequence`, ver√°s la siguiente salida:

```plaintext
> Task :printFibonacciSequence
0
1
1
2
3
5
8
13
21
34

The 10th Fibonacci number is: 34
```

:::tip ¬øCu√°ndo usar `doFirst` y `doLast`?

- Usa **`doLast`** cuando quieras agregar l√≥gica que **ocurra al final de la tarea**, como mostrar un resultado, guardar un archivo, o imprimir un resumen. Es el m√°s com√∫n y recomendado por defecto.
- Usa **`doFirst`** si necesitas ejecutar algo **antes de cualquier otra acci√≥n** asociada a la tarea, como configurar variables, verificar condiciones previas, o limpiar alg√∫n estado.
- Usa **ambos** si tu tarea requiere l√≥gica **antes y despu√©s** de una acci√≥n principal. Por ejemplo:
    ```kotlin showLineNumbers
    tasks.register("prepareBattle") {
        doFirst {
            println("Sharpening sword...")
        }
        doLast {
            println("The Prince is ready for battle!")
        }
    }
    ```

Esto te permite estructurar la tarea como una mini rutina con un inicio, desarrollo y cierre claros.

:::

## üîó Dependencias entre Tareas

En Gradle, es com√∫n que ciertas tareas dependan de otras. Para esto, puedes usar el m√©todo `dependsOn`. Por ejemplo, si queremos que la tarea `printFibonacciSequence` dependa de una tarea `message`, podemos hacerlo as√≠:

```kotlin title="convention-plugins/src/main/kotlin/playground.gradle.kts" showLineNumbers
// ...
tasks.register("announceFibonacci") {
    group = "Playground"
    description = "Prints a message before calculating the Fibonacci sequence"
    doFirst {
        println("Calculating the Fibonacci sequence...")
    }
}

tasks.named("printFibonacciSequence") {
    dependsOn("announceFibonacci")
}
```

Aqu√≠ noten que hemos usado `tasks.named("printFibonacciSequence")` en lugar de `tasks.register("printFibonacciSequence")` para obtener la tarea `printFibonacciSequence` ya definida y agregarle la dependencia, eso nos permite extender las funcionalidades de la tarea sin modificar su definici√≥n original, lo que se alinea con el principio **open-closed** del dise√±o de software.

:::info Open-closed Principle

El **Principio de Abierto/Cerrado** (Open-closed Principle) es un principio de dise√±o de software que establece que las entidades de software (clases, m√≥dulos, funciones, etc.) deben estar abiertas para la extensi√≥n, pero cerradas para la modificaci√≥n. Esto se traduce en que se deber√≠an poder extender las funcionalidades de una entidad sin modificar su c√≥digo fuente.

:::

Esto hace que `announceFibonacci` se ejecute antes de `printFibonacciSequence`, y el resultado en la consola ser√° algo como:

```plaintext
> Task :announceFibonacci
Calculating the Fibonacci sequence...

> Task :printFibonacciSequence
0
1
1
2
3
5
8
13
21
34

The 10th Fibonacci number is: 34
```

## üìè Ejercicio: Contar el tama√±o del proyecto compilado

<Exercise>
    Implementa una tarea personalizada que cuente el tama√±o de los archivos compilados de tu proyecto.

    <Hint hints={[
        <>
            Usa <code>fileTree("ruta").files</code> para obtener los archivos.
        </>,
        <>
            Utiliza <code>length: File.() -&gt; Long</code> para calcular el tama√±o de un archivo.
        </>,
        <>
            Aseg√∫rate de que la tarea dependa de <code>compileKotlin</code>.
        </>
    ]} />

    <Solution>
        <BoxedTabs>
            <TabItem value="Implementaci√≥n iterativa" label="Implementaci√≥n iterativa">
                ```kotlin title="convention-plugins/src/main/kotlin/playground.gradle.kts"
                tasks.register("countCompiledSize") {
                    group = "build"
                    description = "Counts the size of the compiled classes"
                    dependsOn("compileKotlin")

                    doLast {
                        val files = fileTree("app/build/classes/kotlin/main").files +
                            fileTree("lib/build/classes/kotlin/main").files
                        var size = 0L
                        for (file in files) {
                            size += file.length()
                        }
                        println("The total size of the compiled classes is $size bytes")
                    }
                }
                ```
            </TabItem>
            <TabItem value="Implementaci√≥n funcional" label="Implementaci√≥n funcional">
                ```kotlin title="convention-plugins/src/main/kotlin/playground.gradle.kts"
                tasks.register("countCompiledSize") {
                    group = "build"
                    description = "Counts the size of the compiled classes"
                    dependsOn("compileKotlin")

                    doLast {
                        val files = fileTree("app/build/classes/kotlin/main").files +
                            fileTree("lib/build/classes/kotlin/main").files
                        val size = files.sumOf { it.length() }
                        println("The total size of the compiled classes is $size bytes")
                    }
                }
                ```
            </TabItem>
        </BoxedTabs>
    </Solution>
</Exercise>

## üß± Tareas Basadas en Otras Tareas

Otra forma de crear tareas personalizadas en Gradle es bas√°ndolas en tareas existentes. Esto es √∫til si quieres extender o agregar funcionalidades a una tarea predefinida, como `Copy`, sin duplicar su l√≥gica.

Por ejemplo, si queremos crear una tarea que copie los archivos compilados de varios m√≥dulos a un directorio espec√≠fico despu√©s de la compilaci√≥n, podemos hacer lo siguiente:

```kotlin title="convention-plugins/src/main/kotlin/playground.gradle.kts"
import java.time.LocalDateTime
import java.time.format.DateTimeFormatter

tasks.register<Copy>("copyCompiledClasses") {
    group = "build"
    description = "Copies compiled classes from all modules into a timestamped output directory"
    dependsOn("compileKotlin")

    val modules = listOf("app", "lib")
    val timestamp = LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyyMMdd-HHmmss"))

    from(modules.map { "$it/build/classes/kotlin/main" })
    into("compiled-classes-$timestamp")
}
```

<Explanation>
    Esta tarea utiliza la clase predefinida `Copy` de Gradle, lo que le permite heredar toda su funcionalidad sin necesidad de implementar el comportamiento desde cero. Lo interesante aqu√≠ es c√≥mo la tarea se adapta din√°micamente:

    - **Modularidad**: Se define una lista de m√≥dulos (`app`, `lib`) desde los que se copiar√°n los archivos compilados. Si el proyecto crece, puedes agregar m√°s m√≥dulos f√°cilmente a esta lista.
    - **Organizaci√≥n por timestamp**: El uso de un timestamp (`yyyyMMdd-HHmmss`) asegura que cada ejecuci√≥n de la tarea genere una carpeta √∫nica. Esto evita sobrescribir resultados anteriores y facilita comparar builds o mantener registros hist√≥ricos.
    - **Dependencia expl√≠cita**: Con `dependsOn("compileKotlin")`, nos aseguramos de que los archivos ya est√©n compilados antes de copiarlos, respetando el flujo natural del proceso de construcci√≥n.

    Este patr√≥n es muy √∫til en tareas como generaci√≥n de artefactos, backups de builds, distribuci√≥n de resultados o preparaci√≥n de entornos de prueba.
</Explanation>

### ‚úÖ Resultado esperado

Luego de ejecutar:

```
./gradlew copyCompiledClasses
```

Ver√°s una carpeta como `compiled-classes-20250325-135809` en la ra√≠z del proyecto, conteniendo los archivos compilados.

## üéØ Conclusiones

Crear tareas personalizadas en Gradle es una habilidad esencial para construir procesos de build claros, modulares y alineados con las necesidades espec√≠ficas de tu proyecto. A trav√©s de esta lecci√≥n exploramos c√≥mo definir tareas desde cero, c√≥mo controlar su comportamiento con acciones, c√≥mo componer flujos de tareas usando dependencias, y c√≥mo reutilizar tareas existentes para evitar duplicaci√≥n de l√≥gica.

Ya sea que est√©s desarrollando una aplicaci√≥n o una biblioteca reutilizable, dominar estas herramientas te permite automatizar tareas repetitivas, estructurar tu proceso de compilaci√≥n de forma clara y mantener tu c√≥digo alineado con principios de dise√±o robustos.

### üîë Puntos clave

- **`tasks.register` vs `tasks.create`**: Prefiere `register` para obtener configuraci√≥n diferida y evitar ejecuciones innecesarias.
- **Acciones (`doFirst` / `doLast`)**: √ösalas para definir l√≥gica que se ejecuta solo cuando la tarea se invoca.
- **Dependencias (`dependsOn`)**: Permiten encadenar tareas y controlar su orden de ejecuci√≥n.
- **Reutilizaci√≥n de tareas (`Copy`)**: Permite extender comportamientos existentes con m√≠nima configuraci√≥n adicional.

### üß∞ ¬øQu√© nos llevamos?

Gradle no es solo una herramienta para compilar y empaquetar c√≥digo; tambi√©n es un entorno de automatizaci√≥n altamente expresivo. Al aprender a definir tareas personalizadas, no solo ganamos control sobre el proceso de build, sino que tambi√©n moldeamos el proyecto a nuestras necesidades concretas, de forma clara, reutilizable y alineada con buenas pr√°cticas.

Cada tarea que escribimos se convierte en una pieza m√°s del lenguaje de construcci√≥n de nuestro software. Y como vimos, incluso algo tan simple como saludar al Pr√≠ncipe puede ser el punto de partida para construir rutinas complejas, mantenibles y potentes. Con estas bases, est√°s listx para seguir explorando c√≥mo extender a√∫n m√°s las capacidades de Gradle, con tareas din√°micas, parametrizadas o incluso plugins propios.


<div className="language-card-container">
    <LanguageCard
        logoSrc="/img/sbt-logo.png"
        language="JVM: SBT"
        link="/docs/build-systems/tasks/custom/sbt"
    />
</div>

## üìñ Referencias

### üî• Recomendadas

- üåê Understanding Tasks. (s.¬†f.). Recuperado 25 de marzo de 2025, de https://docs.gradle.org/current/userguide/more_about_tasks.html
